var Ne=Object.defineProperty;var je=(R,u,y)=>u in R?Ne(R,u,{enumerable:!0,configurable:!0,writable:!0,value:y}):R[u]=y;var Pt=(R,u,y)=>(je(R,typeof u!="symbol"?u+"":u,y),y);(function(){"use strict";var ort_min={exports:{}};/*!
* ONNX Runtime Web v1.15.1
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/(function(module,exports){(function(R,u){module.exports=u()})(self,()=>(()=>{var __webpack_modules__={8453:(R,u,y)=>{y.r(u),y.d(u,{InferenceSession:()=>n,Tensor:()=>e,env:()=>s,registerBackend:()=>f});const m={},h=[],f=(r,o,c)=>{if(!o||typeof o.init!="function"||typeof o.createSessionHandler!="function")throw new TypeError("not a valid backend");{const d=m[r];if(d===void 0)m[r]={backend:o,priority:c};else{if(d.priority>c)return;if(d.priority===c&&d.backend!==o)throw new Error(`cannot register backend "${r}" using priority ${c}`)}if(c>=0){const g=h.indexOf(r);g!==-1&&h.splice(g,1);for(let b=0;b<h.length;b++)if(m[h[b]].priority<=c)return void h.splice(b,0,r);h.push(r)}}},s=new class{constructor(){this.wasm={},this.webgl={},this.webgpu={},this.logLevelInternal="warning"}set logLevel(r){if(r!==void 0){if(typeof r!="string"||["verbose","info","warning","error","fatal"].indexOf(r)===-1)throw new Error(`Unsupported logging level: ${r}`);this.logLevelInternal=r}}get logLevel(){return this.logLevelInternal}},l=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),p=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let a=!1;class i{constructor(o,c,d){let g,b,v;if((()=>{if(!a){a=!0;const x=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",T=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";x&&(l.set("int64",BigInt64Array),p.set(BigInt64Array,"int64")),T&&(l.set("uint64",BigUint64Array),p.set(BigUint64Array,"uint64"))}})(),typeof o=="string")if(g=o,v=d,o==="string"){if(!Array.isArray(c))throw new TypeError("A string tensor's data must be a string array.");b=c}else{const x=l.get(o);if(x===void 0)throw new TypeError(`Unsupported tensor type: ${o}.`);if(Array.isArray(c))b=x.from(c);else{if(!(c instanceof x))throw new TypeError(`A ${g} tensor's data must be type of ${x}`);b=c}}else if(v=c,Array.isArray(o)){if(o.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const x=typeof o[0];if(x==="string")g="string",b=o;else{if(x!=="boolean")throw new TypeError(`Invalid element type of data array: ${x}.`);g="bool",b=Uint8Array.from(o)}}else{const x=p.get(o.constructor);if(x===void 0)throw new TypeError(`Unsupported type for tensor data: ${o.constructor}.`);g=x,b=o}if(v===void 0)v=[b.length];else if(!Array.isArray(v))throw new TypeError("A tensor's dims must be a number array");const w=(x=>{let T=1;for(let S=0;S<x.length;S++){const _=x[S];if(typeof _!="number"||!Number.isSafeInteger(_))throw new TypeError(`dims[${S}] must be an integer, got: ${_}`);if(_<0)throw new RangeError(`dims[${S}] must be a non-negative integer, got: ${_}`);T*=_}return T})(v);if(w!==b.length)throw new Error(`Tensor's size(${w}) does not match data length(${b.length}).`);this.dims=v,this.type=g,this.data=b,this.size=w}static bufferToTensor(o,c){if(o===void 0)throw new Error("Image buffer must be defined");if(c.height===void 0||c.width===void 0)throw new Error("Image height and width must be defined");if(c.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:d,width:g}=c,b=c.norm??{mean:255,bias:0};let v,w;v=typeof b.mean=="number"?[b.mean,b.mean,b.mean,b.mean]:[b.mean[0],b.mean[1],b.mean[2],b.mean[3]??255],w=typeof b.bias=="number"?[b.bias,b.bias,b.bias,b.bias]:[b.bias[0],b.bias[1],b.bias[2],b.bias[3]??0];const x=c.bitmapFormat!==void 0?c.bitmapFormat:"RGBA",T=c.tensorFormat!==void 0&&c.tensorFormat!==void 0?c.tensorFormat:"RGB",S=d*g,_=T==="RGBA"?new Float32Array(4*S):new Float32Array(3*S);let A=4,E=0,C=1,D=2,$=3,L=0,P=S,k=2*S,V=-1;x==="RGB"&&(A=3,E=0,C=1,D=2,$=-1),T==="RGBA"?V=3*S:T==="RBG"?(L=0,k=S,P=2*S):T==="BGR"&&(k=0,P=S,L=2*S);for(let z=0;z<S;z++,E+=A,D+=A,C+=A,$+=A)_[L++]=(o[E]+w[0])/v[0],_[P++]=(o[C]+w[1])/v[1],_[k++]=(o[D]+w[2])/v[2],V!==-1&&$!==-1&&(_[V++]=(o[$]+w[3])/v[3]);return new i("float32",_,T==="RGBA"?[1,4,d,g]:[1,3,d,g])}static async fromImage(o,c){const d=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,g=typeof ImageData<"u"&&o instanceof ImageData,b=typeof ImageBitmap<"u"&&o instanceof ImageBitmap,v=typeof o=="string";let w,x=c??{};if(d){const T=document.createElement("canvas");T.width=o.width,T.height=o.height;const S=T.getContext("2d");if(S==null)throw new Error("Can not access image data");{let _=o.height,A=o.width;if(c!==void 0&&c.resizedHeight!==void 0&&c.resizedWidth!==void 0&&(_=c.resizedHeight,A=c.resizedWidth),c!==void 0){if(x=c,c.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(x.tensorFormat="RGBA",c.height!==void 0&&c.height!==_)throw new Error("Image input config height doesn't match HTMLImageElement height");if(x.height=_,c.width!==void 0&&c.width!==A)throw new Error("Image input config width doesn't match HTMLImageElement width");x.width=A}else x.tensorFormat="RGBA",x.height=_,x.width=A;S.drawImage(o,0,0),w=S.getImageData(0,0,A,_).data}}else{if(!g){if(b){if(c===void 0)throw new Error("Please provide image config with format for Imagebitmap");if(c.bitmapFormat!==void 0)throw new Error("Image input config format must be defined for ImageBitmap");const T=document.createElement("canvas").getContext("2d");if(T!=null){const S=o.height,_=o.width;if(T.drawImage(o,0,0,_,S),w=T.getImageData(0,0,_,S).data,c!==void 0){if(c.height!==void 0&&c.height!==S)throw new Error("Image input config height doesn't match ImageBitmap height");if(x.height=S,c.width!==void 0&&c.width!==_)throw new Error("Image input config width doesn't match ImageBitmap width");x.width=_}else x.height=S,x.width=_;return i.bufferToTensor(w,x)}throw new Error("Can not access image data")}if(v)return new Promise((T,S)=>{const _=document.createElement("canvas"),A=_.getContext("2d");if(!o||!A)return S();const E=new Image;E.crossOrigin="Anonymous",E.src=o,E.onload=()=>{_.width=E.width,_.height=E.height,A.drawImage(E,0,0,_.width,_.height);const C=A.getImageData(0,0,_.width,_.height);if(c!==void 0){if(c.height!==void 0&&c.height!==_.height)throw new Error("Image input config height doesn't match height");if(x.height=_.height,c.width!==void 0&&c.width!==_.width)throw new Error("Image input config width doesn't match width");x.width=_.width}else x.height=_.height,x.width=_.width;T(i.bufferToTensor(C.data,x))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{const T="RGBA";let S,_;if(c!==void 0&&c.resizedWidth!==void 0&&c.resizedHeight!==void 0?(S=c.resizedHeight,_=c.resizedWidth):(S=o.height,_=o.width),c!==void 0){if(x=c,c.bitmapFormat!==void 0&&c.bitmapFormat!==T)throw new Error("Image input config format must be RGBA for ImageData");x.bitmapFormat="RGBA"}else x.bitmapFormat="RGBA";if(x.height=S,x.width=_,c!==void 0){const A=document.createElement("canvas");A.width=_,A.height=S;const E=A.getContext("2d");if(E==null)throw new Error("Can not access image data");E.putImageData(o,0,0),w=E.getImageData(0,0,_,S).data}else w=o.data}}if(w!==void 0)return i.bufferToTensor(w,x);throw new Error("Input data provided is not supported - aborted tensor creation")}toDataURL(o){const c=document.createElement("canvas");c.width=this.dims[3],c.height=this.dims[2];const d=c.getContext("2d");if(d!=null){let g,b;(o==null?void 0:o.tensorLayout)!==void 0&&o.tensorLayout==="NHWC"?(g=this.dims[2],b=this.dims[3]):(g=this.dims[3],b=this.dims[2]);const v=(o==null?void 0:o.format)!==void 0?o.format:"RGB",w=o==null?void 0:o.norm;let x,T;w===void 0||w.mean===void 0?x=[255,255,255,255]:typeof w.mean=="number"?x=[w.mean,w.mean,w.mean,w.mean]:(x=[w.mean[0],w.mean[1],w.mean[2],0],w.mean[3]!==void 0&&(x[3]=w.mean[3])),w===void 0||w.bias===void 0?T=[0,0,0,0]:typeof w.bias=="number"?T=[w.bias,w.bias,w.bias,w.bias]:(T=[w.bias[0],w.bias[1],w.bias[2],0],w.bias[3]!==void 0&&(T[3]=w.bias[3]));const S=b*g;let _=0,A=S,E=2*S,C=-1;v==="RGBA"?(_=0,A=S,E=2*S,C=3*S):v==="RGB"?(_=0,A=S,E=2*S):v==="RBG"&&(_=0,E=S,A=2*S);for(let D=0;D<b;D++)for(let $=0;$<g;$++){const L=(this.data[_++]-T[0])*x[0],P=(this.data[A++]-T[1])*x[1],k=(this.data[E++]-T[2])*x[2],V=C===-1?255:(this.data[C++]-T[3])*x[3];d.fillStyle="rgba("+L+","+P+","+k+","+V+")",d.fillRect($,D,1,1)}return c.toDataURL()}throw new Error("Can not access image data")}toImageData(o){const c=document.createElement("canvas").getContext("2d");let d;if(c==null)throw new Error("Can not access image data");{let g,b,v;(o==null?void 0:o.tensorLayout)!==void 0&&o.tensorLayout==="NHWC"?(g=this.dims[2],b=this.dims[1],v=this.dims[3]):(g=this.dims[3],b=this.dims[2],v=this.dims[1]);const w=o!==void 0&&o.format!==void 0?o.format:"RGB",x=o==null?void 0:o.norm;let T,S;x===void 0||x.mean===void 0?T=[255,255,255,255]:typeof x.mean=="number"?T=[x.mean,x.mean,x.mean,x.mean]:(T=[x.mean[0],x.mean[1],x.mean[2],255],x.mean[3]!==void 0&&(T[3]=x.mean[3])),x===void 0||x.bias===void 0?S=[0,0,0,0]:typeof x.bias=="number"?S=[x.bias,x.bias,x.bias,x.bias]:(S=[x.bias[0],x.bias[1],x.bias[2],0],x.bias[3]!==void 0&&(S[3]=x.bias[3]));const _=b*g;if(o!==void 0){if(o.height!==void 0&&o.height!==b)throw new Error("Image output config height doesn't match tensor height");if(o.width!==void 0&&o.width!==g)throw new Error("Image output config width doesn't match tensor width");if(o.format!==void 0&&v===4&&o.format!=="RGBA"||v===3&&o.format!=="RGB"&&o.format!=="BGR")throw new Error("Tensor format doesn't match input tensor dims")}const A=4;let E=0,C=1,D=2,$=3,L=0,P=_,k=2*_,V=-1;w==="RGBA"?(L=0,P=_,k=2*_,V=3*_):w==="RGB"?(L=0,P=_,k=2*_):w==="RBG"&&(L=0,k=_,P=2*_),d=c.createImageData(g,b);for(let z=0;z<b*g;E+=A,C+=A,D+=A,$+=A,z++)d.data[E]=(this.data[L++]-S[0])*T[0],d.data[C]=(this.data[P++]-S[1])*T[1],d.data[D]=(this.data[k++]-S[2])*T[2],d.data[$]=V===-1?255:(this.data[V++]-S[3])*T[3]}return d}reshape(o){return new i(this.type,this.data,o)}}const e=i;class t{constructor(o){this.handler=o}async run(o,c,d){const g={};let b={};if(typeof o!="object"||o===null||o instanceof e||Array.isArray(o))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let v=!0;if(typeof c=="object"){if(c===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(c instanceof e)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(c)){if(c.length===0)throw new TypeError("'fetches' cannot be an empty array.");v=!1;for(const T of c){if(typeof T!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(T)===-1)throw new RangeError(`'fetches' contains invalid output name: ${T}.`);g[T]=null}if(typeof d=="object"&&d!==null)b=d;else if(d!==void 0)throw new TypeError("'options' must be an object.")}else{let T=!1;const S=Object.getOwnPropertyNames(c);for(const _ of this.outputNames)if(S.indexOf(_)!==-1){const A=c[_];(A===null||A instanceof e)&&(T=!0,v=!1,g[_]=A)}if(T){if(typeof d=="object"&&d!==null)b=d;else if(d!==void 0)throw new TypeError("'options' must be an object.")}else b=c}}else if(c!==void 0)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const T of this.inputNames)if(o[T]===void 0)throw new Error(`input '${T}' is missing in 'feeds'.`);if(v)for(const T of this.outputNames)g[T]=null;const w=await this.handler.run(o,g,b),x={};for(const T in w)Object.hasOwnProperty.call(w,T)&&(x[T]=new e(w[T].type,w[T].data,w[T].dims));return x}static async create(o,c,d,g){let b,v={};if(typeof o=="string"){if(b=o,typeof c=="object"&&c!==null)v=c;else if(c!==void 0)throw new TypeError("'options' must be an object.")}else if(o instanceof Uint8Array){if(b=o,typeof c=="object"&&c!==null)v=c;else if(c!==void 0)throw new TypeError("'options' must be an object.")}else{if(!(o instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&o instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const S=o;let _=0,A=o.byteLength;if(typeof c=="object"&&c!==null)v=c;else if(typeof c=="number"){if(_=c,!Number.isSafeInteger(_))throw new RangeError("'byteOffset' must be an integer.");if(_<0||_>=S.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${S.byteLength}).`);if(A=o.byteLength-_,typeof d=="number"){if(A=d,!Number.isSafeInteger(A))throw new RangeError("'byteLength' must be an integer.");if(A<=0||_+A>S.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${S.byteLength-_}].`);if(typeof g=="object"&&g!==null)v=g;else if(g!==void 0)throw new TypeError("'options' must be an object.")}else if(d!==void 0)throw new TypeError("'byteLength' must be a number.")}else if(c!==void 0)throw new TypeError("'options' must be an object.");b=new Uint8Array(S,_,A)}}const w=(v.executionProviders||[]).map(S=>typeof S=="string"?S:S.name),x=await(async S=>{const _=S.length===0?h:S,A=[];for(const E of _){const C=m[E];if(C){if(C.initialized)return C.backend;if(C.aborted)continue;const D=!!C.initPromise;try{return D||(C.initPromise=C.backend.init()),await C.initPromise,C.initialized=!0,C.backend}catch($){D||A.push({name:E,err:$}),C.aborted=!0}finally{delete C.initPromise}}}throw new Error(`no available backend found. ERR: ${A.map(E=>`[${E.name}] ${E.err}`).join(", ")}`)})(w),T=await x.createSessionHandler(b,v);return new t(T)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const n=t},5716:(R,u,y)=>{u.R=void 0;const m=y(6027),h=y(1723);u.R=new class{async init(){}async createSessionHandler(f,s){const l=new m.Session(s);return await l.loadModel(f),new h.OnnxjsSessionHandler(l)}}},2818:(R,u,y)=>{u.c8=u.rX=void 0;const m=y(8453),h=y(5381),f=y(9544),s=y(6640);u.rX=()=>{if((typeof m.env.wasm.initTimeout!="number"||m.env.wasm.initTimeout<0)&&(m.env.wasm.initTimeout=0),typeof m.env.wasm.simd!="boolean"&&(m.env.wasm.simd=!0),typeof m.env.wasm.proxy!="boolean"&&(m.env.wasm.proxy=!1),typeof m.env.wasm.numThreads!="number"||!Number.isInteger(m.env.wasm.numThreads)||m.env.wasm.numThreads<=0){const l=typeof navigator>"u"?(0,h.cpus)().length:navigator.hardwareConcurrency;m.env.wasm.numThreads=Math.min(4,Math.ceil((l||1)/2))}},u.c8=new class{async init(){(0,u.rX)(),await(0,f.initWasm)()}async createSessionHandler(l,p){const a=new s.OnnxruntimeWebAssemblySessionHandler;return await a.loadModel(l,p),Promise.resolve(a)}}},1057:function(R,u,y){var m=this&&this.__createBinding||(Object.create?function(s,l,p,a){a===void 0&&(a=p);var i=Object.getOwnPropertyDescriptor(l,p);i&&!("get"in i?!l.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return l[p]}}),Object.defineProperty(s,a,i)}:function(s,l,p,a){a===void 0&&(a=p),s[a]=l[p]}),h=this&&this.__exportStar||function(s,l){for(var p in s)p==="default"||Object.prototype.hasOwnProperty.call(l,p)||m(l,s,p)};Object.defineProperty(u,"__esModule",{value:!0}),h(y(8453),u);const f=y(8453);{const s=y(5716).R;(0,f.registerBackend)("webgl",s,-10)}{const s=y(2818).c8;(0,f.registerBackend)("cpu",s,10),(0,f.registerBackend)("wasm",s,10),(0,f.registerBackend)("xnnpack",s,9)}},4910:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createAttributeWithCacheKey=void 0;class y{constructor(h){Object.assign(this,h)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(h=>`${this[h]}`).join(";")),this._cacheKey}}u.createAttributeWithCacheKey=m=>new y(m)},6874:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.Attribute=void 0;const m=y(1446),h=y(1287),f=y(9240),s=y(7273);var l=h.onnxruntime.experimental.fbs;class p{constructor(i){if(this._attributes=new Map,i!=null){for(const e of i)e instanceof m.onnx.AttributeProto?this._attributes.set(e.name,[p.getValue(e),p.getType(e)]):e instanceof l.Attribute&&this._attributes.set(e.name(),[p.getValue(e),p.getType(e)]);if(this._attributes.size<i.length)throw new Error("duplicated attribute names")}}set(i,e,t){this._attributes.set(i,[t,e])}delete(i){this._attributes.delete(i)}getFloat(i,e){return this.get(i,"float",e)}getInt(i,e){return this.get(i,"int",e)}getString(i,e){return this.get(i,"string",e)}getTensor(i,e){return this.get(i,"tensor",e)}getFloats(i,e){return this.get(i,"floats",e)}getInts(i,e){return this.get(i,"ints",e)}getStrings(i,e){return this.get(i,"strings",e)}getTensors(i,e){return this.get(i,"tensors",e)}get(i,e,t){const n=this._attributes.get(i);if(n===void 0){if(t!==void 0)return t;throw new Error(`required attribute not found: ${i}`)}if(n[1]!==e)throw new Error(`type mismatch: expected ${e} but got ${n[1]}`);return n[0]}static getType(i){const e=i instanceof m.onnx.AttributeProto?i.type:i.type();switch(e){case m.onnx.AttributeProto.AttributeType.FLOAT:return"float";case m.onnx.AttributeProto.AttributeType.INT:return"int";case m.onnx.AttributeProto.AttributeType.STRING:return"string";case m.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case m.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case m.onnx.AttributeProto.AttributeType.INTS:return"ints";case m.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case m.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${m.onnx.AttributeProto.AttributeType[e]}`)}}static getValue(i){const e=i instanceof m.onnx.AttributeProto?i.type:i.type();if(e===m.onnx.AttributeProto.AttributeType.GRAPH||e===m.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const t=this.getValueNoCheck(i);if(e===m.onnx.AttributeProto.AttributeType.INT&&s.LongUtil.isLong(t))return s.LongUtil.longToNumber(t);if(e===m.onnx.AttributeProto.AttributeType.INTS){const n=t,r=new Array(n.length);for(let o=0;o<n.length;o++){const c=n[o];r[o]=s.LongUtil.longToNumber(c)}return r}if(e===m.onnx.AttributeProto.AttributeType.TENSOR)return i instanceof m.onnx.AttributeProto?f.Tensor.fromProto(t):f.Tensor.fromOrtTensor(t);if(e===m.onnx.AttributeProto.AttributeType.TENSORS){if(i instanceof m.onnx.AttributeProto)return t.map(n=>f.Tensor.fromProto(n));if(i instanceof l.Attribute)return t.map(n=>f.Tensor.fromOrtTensor(n))}if(e===m.onnx.AttributeProto.AttributeType.STRING&&i instanceof m.onnx.AttributeProto){const n=t;return(0,s.decodeUtf8String)(n)}return e===m.onnx.AttributeProto.AttributeType.STRINGS&&i instanceof m.onnx.AttributeProto?t.map(s.decodeUtf8String):t}static getValueNoCheck(i){return i instanceof m.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(i):this.getValueNoCheckFromOrtFormat(i)}static getValueNoCheckFromOnnxFormat(i){switch(i.type){case m.onnx.AttributeProto.AttributeType.FLOAT:return i.f;case m.onnx.AttributeProto.AttributeType.INT:return i.i;case m.onnx.AttributeProto.AttributeType.STRING:return i.s;case m.onnx.AttributeProto.AttributeType.TENSOR:return i.t;case m.onnx.AttributeProto.AttributeType.GRAPH:return i.g;case m.onnx.AttributeProto.AttributeType.FLOATS:return i.floats;case m.onnx.AttributeProto.AttributeType.INTS:return i.ints;case m.onnx.AttributeProto.AttributeType.STRINGS:return i.strings;case m.onnx.AttributeProto.AttributeType.TENSORS:return i.tensors;case m.onnx.AttributeProto.AttributeType.GRAPHS:return i.graphs;default:throw new Error(`unsupported attribute type: ${m.onnx.AttributeProto.AttributeType[i.type]}`)}}static getValueNoCheckFromOrtFormat(i){switch(i.type()){case l.AttributeType.FLOAT:return i.f();case l.AttributeType.INT:return i.i();case l.AttributeType.STRING:return i.s();case l.AttributeType.TENSOR:return i.t();case l.AttributeType.GRAPH:return i.g();case l.AttributeType.FLOATS:return i.floatsArray();case l.AttributeType.INTS:{const e=[];for(let t=0;t<i.intsLength();t++)e.push(i.ints(t));return e}case l.AttributeType.STRINGS:{const e=[];for(let t=0;t<i.stringsLength();t++)e.push(i.strings(t));return e}case l.AttributeType.TENSORS:{const e=[];for(let t=0;t<i.tensorsLength();t++)e.push(i.tensors(t));return e}default:throw new Error(`unsupported attribute type: ${l.AttributeType[i.type()]}`)}}}u.Attribute=p},1975:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.resolveBackend=u.backend=void 0;const m=y(4418),h=new Map;async function f(s){const l=u.backend;if(l[s]!==void 0&&function(p){const a=p;return"initialize"in a&&typeof a.initialize=="function"&&"createSessionHandler"in a&&typeof a.createSessionHandler=="function"&&"dispose"in a&&typeof a.dispose=="function"}(l[s])){const p=l[s];let a=p.initialize();if(typeof a=="object"&&"then"in a&&(a=await a),a)return h.set(s,p),p}}u.backend={webgl:new m.WebGLBackend},u.resolveBackend=async function s(l){if(!l)return s(["webgl"]);{const p=typeof l=="string"?[l]:l;for(const a of p){const i=h.get(a);if(i)return i;const e=await f(a);if(e)return e}}throw new Error("no available backend to use")}},4418:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.WebGLBackend=void 0;const m=y(8453),h=y(1315),f=y(2171),s=y(3389);u.WebGLBackend=class{get contextId(){return m.env.webgl.contextId}set contextId(l){m.env.webgl.contextId=l}get matmulMaxBatchSize(){return m.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(l){m.env.webgl.matmulMaxBatchSize=l}get textureCacheMode(){return m.env.webgl.textureCacheMode}set textureCacheMode(l){m.env.webgl.textureCacheMode=l}get pack(){return m.env.webgl.pack}set pack(l){m.env.webgl.pack=l}get async(){return m.env.webgl.async}set async(l){m.env.webgl.async=l}initialize(){try{return this.glContext=(0,s.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),h.Logger.setWithEnv(m.env),h.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(l){return h.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${l}`),!1}}createSessionHandler(l){return new f.WebGLSessionHandler(this,l)}dispose(){this.glContext.dispose()}}},6859:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.CoordsGlslLib=void 0;const m=y(7273),h=y(1997),f=y(6757),s=y(7618),l=y(432);class p extends h.GlslLib{constructor(i){super(i)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new h.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new h.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const i=this.context.outputTextureLayout;return i.isPacked?this.getPackedOutputSamplingSnippet(i):this.getUnpackedOutputSamplingSnippet(i)}getPackedOutputSamplingSnippet(i){const e=i.unpackedShape,t=[i.width,i.height],n={},r="getOutputCoords";switch(e.length){case 0:n[r]=this.getOutputScalarCoords();break;case 1:n[r]=this.getOutputPacked1DCoords(e,t);break;case 2:n[r]=this.getOutputPacked2DCoords(e,t);break;case 3:n[r]=this.getOutputPacked3DCoords(e,t);break;default:n[r]=this.getOutputPackedNDCoords(e,t)}const o=`
      void setOutput(vec4 val) {
        ${(0,f.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return n.floatTextureSetRGBA=new h.GlslLibRoutine(o),n}getUnpackedOutputSamplingSnippet(i){const e=i.unpackedShape,t=[i.width,i.height],n={},r="getOutputCoords";switch(e.length){case 0:n[r]=this.getOutputScalarCoords();break;case 1:n[r]=this.getOutputUnpacked1DCoords(e,t);break;case 2:n[r]=this.getOutputUnpacked2DCoords(e,t);break;case 3:n[r]=this.getOutputUnpacked3DCoords(e,t);break;case 4:n[r]=this.getOutputUnpacked4DCoords(e,t);break;case 5:n[r]=this.getOutputUnpacked5DCoords(e,t);break;case 6:n[r]=this.getOutputUnpacked6DCoords(e,t);break;default:throw new Error(`Unsupported output dimensionality: ${e.length}`)}const o=`
        void setOutput(float val) {
          ${(0,f.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return n.floatTextureSetR=new h.GlslLibRoutine(o),n}getOutputScalarCoords(){return new h.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(i,e){const t=e;let n="";return t[0]===1?(n=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${t[1]}.0);
          }
        `,new h.GlslLibRoutine(n)):t[1]===1?(n=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${t[0]}.0);
          }
        `,new h.GlslLibRoutine(n)):(n=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${t[0]}, ${t[1]}));
          return 2 * (resTexRC.y * ${t[0]} + resTexRC.x);
        }
      `,new h.GlslLibRoutine(n))}getOutputPacked2DCoords(i,e){let t="";if(m.ArrayUtil.arraysEqual(i,e))return t=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${e[0]}, ${e[1]}));
        }
      `,new h.GlslLibRoutine(t);const n=e,r=Math.ceil(i[1]/2);return t=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));

          int index = resTexRC.y * ${n[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${r}) * 2;
          int c = 2 * (index / ${r});

          return ivec2(r, c);
        }
      `,new h.GlslLibRoutine(t)}getOutputPacked3DCoords(i,e){const t=[e[0],e[1]],n=Math.ceil(i[2]/2),r=n*Math.ceil(i[1]/2),o=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;

          int b = index / ${r};
          index -= b * ${r};

          // reverse r and c order for packed texture
          int r = imod(index, ${n}) * 2;
          int c = 2 * (index / ${n});

          return ivec3(b, r, c);
        }
      `;return new h.GlslLibRoutine(o)}getOutputPackedNDCoords(i,e){const t=[e[0],e[1]],n=Math.ceil(i[i.length-1]/2),r=n*Math.ceil(i[i.length-2]/2);let o=r,c="",d="b, r, c";for(let b=2;b<i.length-1;b++)o*=i[i.length-b-1],c=`
      int b${b} = index / ${o};
      index -= b${b} * ${o};
    `+c,d=`b${b}, `+d;const g=`
      ivec${i.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.y * ${t[0]} + resTexRC.x;

        ${c}

        int b = index / ${r};
        index -= b * ${r};

        // reverse r and c order for packed texture
        int r = imod(index, ${n}) * 2;
        int c = 2 * (index / ${n});

        return ivec${i.length}(${d});
      }
    `;return new h.GlslLibRoutine(g)}getOutputUnpacked1DCoords(i,e){const t=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          return resTexRC.y * ${e[0]} + resTexRC.x;
        }
      `;return new h.GlslLibRoutine(t)}getOutputUnpacked2DCoords(i,e){const t=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;
          int r = index / ${i[1]};
          int c = index - r * ${i[1]};
          return ivec2(r, c);
        }
      `;return new h.GlslLibRoutine(t)}getOutputUnpacked3DCoords(i,e){let t="";const n=i.length;let r=null;n<2&&(r=[]),r=new Array(n-1),r[n-2]=i[n-1];for(let d=n-3;d>=0;--d)r[d]=r[d+1]*i[d+1];const o=["r","c","d"],c=r.map((d,g)=>`int ${o[g]} = index / ${d}; ${g===r.length-1?`int ${o[g+1]} = index - ${o[g]} * ${d}`:`index -= ${o[g]} * ${d}`};`).join("");return t=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;
          ${c}
          return ivec3(r, c, d);
        }
      `,new h.GlslLibRoutine(t)}getOutputUnpacked4DCoords(i,e){let t="";const n=i.length;let r=null;n<2&&(r=[]),r=new Array(n-1),r[n-2]=i[n-1];for(let d=n-3;d>=0;--d)r[d]=r[d+1]*i[d+1];const o=["r","c","d","d2"],c=r.map((d,g)=>`int ${o[g]} = index / ${d}; ${g===r.length-1?`int ${o[g+1]} = index - ${o[g]} * ${d}`:`index -= ${o[g]} * ${d}`};`).join("");return t=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;
          ${c}
          return ivec4(r, c, d, d2);
        }
      `,new h.GlslLibRoutine(t)}getOutputUnpacked5DCoords(i,e){let t="";const n=i.length;let r=null;n<2&&(r=[]),r=new Array(n-1),r[n-2]=i[n-1];for(let d=n-3;d>=0;--d)r[d]=r[d+1]*i[d+1];const o=["r","c","d","d2","d3"],c=r.map((d,g)=>`int ${o[g]} = index / ${d}; ${g===r.length-1?`int ${o[g+1]} = index - ${o[g]} * ${d}`:`index -= ${o[g]} * ${d}`};`).join("");return t=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;
          ${c}
          return ivec5(r, c, d, d2, d3);
        }
      `,new h.GlslLibRoutine(t)}getOutputUnpacked6DCoords(i,e){let t="";const n=i.length;let r=null;n<2&&(r=[]),r=new Array(n-1),r[n-2]=i[n-1];for(let d=n-3;d>=0;--d)r[d]=r[d+1]*i[d+1];const o=["r","c","d","d2","d3","d4"],c=r.map((d,g)=>`int ${o[g]} = index / ${d}; ${g===r.length-1?`int ${o[g+1]} = index - ${o[g]} * ${d}`:`index -= ${o[g]} * ${d}`};`).join("");return t=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${e[0]}, ${e[1]}));
         int index = resTexRC.y * ${e[0]} + resTexRC.x;
         ${c}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new h.GlslLibRoutine(t)}getCommonUtilFuncs(){const i={};let e="uvFromFlat";i[e]=new h.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),e="packedUVfrom1D",i[e]=new h.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),e="packedUVfrom2D",i[e]=new h.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),e="packedUVfrom3D",i[e]=new h.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),e="sampleTexture";const t=(0,f.getGlsl)(this.context.glContext.version);return i[e]=new h.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${t.texture2D}(textureSampler, uv).r;
        }`),i}getInputsSamplingSnippets(){const i={},e=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((t,n)=>{const r=this.context.inputTextureLayouts[n],o=(0,l.generateShaderFuncNameFromInputSamplerName)(t);r.isPacked?i[o]=this.getPackedSamplerFromInput(o,t,r):i[o]=this.getUnpackedSamplerFromInput(o,t,r);const c=(0,l.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(t);r.unpackedShape.length<=e.unpackedShape.length&&(r.isPacked?i[c]=this.getPackedSamplerAtOutputCoords(c,r,e,t):i[c]=this.getUnpackedSamplerAtOutputCoords(c,r,e,t))}),i}getPackedSamplerAtOutputCoords(i,e,t,n){const r=e.unpackedShape,o=t.unpackedShape,c=n,d=(0,l.generateShaderFuncNameFromInputSamplerName)(c),g=r.length,b=o.length,v=m.BroadcastUtil.getBroadcastDims(r,o),w=(0,l.getCoordsDataType)(b),x=b-g;let T;const S=(0,l.getGlChannels)();T=g===0?"":b<2&&v.length>=1?"coords = 0;":v.map($=>`coords.${S[$+x]} = 0;`).join(`
`);let _="";_=b<2&&g>0?"coords":r.map(($,L)=>`coords.${S[L+x]}`).join(", ");let A="return outputValue;";const E=m.ShapeUtil.size(r)===1,C=m.ShapeUtil.size(o)===1;if(g!==1||E||C){if(E&&!C)A=b===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(v.length){const $=g-2,L=g-1;v.indexOf($)>-1&&v.indexOf(L)>-1?A="return vec4(outputValue.x);":v.indexOf($)>-1?A="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":v.indexOf(L)>-1&&(A="return vec4(outputValue.xx, outputValue.zz);")}}else A=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const D=`
      vec4 ${i}() {
        ${w} coords = getOutputCoords();
        
        int lastDim = coords.${S[b-1]};
        coords.${S[b-1]} = coords.${S[b-2]};
        coords.${S[b-2]} = lastDim;
      
        ${T}
        vec4 outputValue = ${d}(${_});
        ${A}
      }
    `;return new h.GlslLibRoutine(D,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(i,e,t,n){const r=[t.width,t.height],o=[e.width,e.height],c=e.unpackedShape.length,d=t.unpackedShape.length,g=e.unpackedShape,b=t.unpackedShape,v=(0,l.generateShaderFuncNameFromInputSamplerName)(n);if(c===d&&m.ArrayUtil.arraysEqual(o,r)){const C=`
          float ${i}() {
            return sampleTexture(${n}, TexCoords);
          }
        `;return new h.GlslLibRoutine(C,["coordinates.sampleTexture"])}const w=(0,l.getCoordsDataType)(d),x=m.BroadcastUtil.getBroadcastDims(g,b),T=d-c;let S;const _=(0,l.getGlChannels)();S=c===0?"":d<2&&x.length>=1?"coords = 0;":x.map(C=>`coords.${_[C+T]} = 0;`).join(`
`);let A="";A=d<2&&c>0?"coords":e.unpackedShape.map((C,D)=>`coords.${_[D+T]}`).join(", ");const E=`
        float ${i}() {
          ${w} coords = getOutputCoords();
          ${S}
          return ${v}(${A});
        }
      `;return new h.GlslLibRoutine(E,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(i,e,t){switch(t.unpackedShape.length){case 0:return this.getPackedSamplerScalar(i,e);case 1:return this.getPackedSampler1D(i,e,t);case 2:return this.getPackedSampler2D(i,e,t);case 3:return this.getPackedSampler3D(i,e,t);default:return this.getPackedSamplerND(i,e,t)}}getUnpackedSamplerFromInput(i,e,t){const n=t.unpackedShape;switch(n.length){case 0:return this.getUnpackedSamplerScalar(i,e,t);case 1:return this.getUnpackedSampler1D(i,e,t);case 2:return this.getUnpackedSampler2D(i,e,t);case 3:return this.getUnpackedSampler3D(i,e,t);case 4:return this.getUnpackedSampler4D(i,e,t);case 5:return this.getUnpackedSampler5D(i,e,t);case 6:return this.getUnpackedSampler6D(i,e,t);default:throw new Error(`Unsupported dimension ${n.length}-D`)}}getPackedSamplerScalar(i,e){const t=`
          vec4 ${i}() {
            return ${(0,f.getGlsl)(this.context.glContext.version).texture2D}(${e}, halfCR);
          }
        `;return new h.GlslLibRoutine(t)}getPackedSampler1D(i,e,t){const n=[t.width,t.height],r=[n[1],n[0]],o=(0,f.getGlsl)(this.context.glContext.version),c=`vec4 ${i}(int index) {
      vec2 uv = packedUVfrom1D(
      ${r[0]}, ${r[1]}, index);
      return ${o.texture2D}(${e}, uv);
    }`;return new h.GlslLibRoutine(c,["coordinates.packedUVfrom1D"])}getPackedSampler2D(i,e,t){const n=t.unpackedShape,r=[t.width,t.height],o=(0,f.getGlsl)(this.context.glContext.version),c=r[0],d=r[1];if(r!=null&&m.ArrayUtil.arraysEqual(n,r)){const w=`vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${c}.0);
        return ${o.texture2D}(${e}, uv);
      }`;return new h.GlslLibRoutine(w)}const g=r,b=Math.ceil(n[1]/2),v=`vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${g[1]}, ${g[0]}, ${b}, row, col);
      return ${o.texture2D}(${e}, uv);
    }`;return new h.GlslLibRoutine(v,["coordinates.packedUVfrom2D"])}getPackedSampler3D(i,e,t){const n=t.unpackedShape,r=[t.width,t.height],o=[r[0],r[1]],c=(0,f.getGlsl)(this.context.glContext.version);if(n[0]===1){const w=n.slice(1),x=[1,2],T=(0,l.squeezeInputShape)(n,w),S=["b","row","col"],_=JSON.parse(JSON.stringify(t));_.unpackedShape=T;const A=this.getPackedSamplerFromInput(i,e,_),E=`${A.routineBody}
      vec4 ${i}(int b, int row, int col) {
        return ${i}(${(0,l.getSqueezedParams)(S,x)});
      } `;return new h.GlslLibRoutine(E,A.dependencies)}const d=o[0],g=o[1],b=Math.ceil(n[2]/2),v=`vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${g}, ${d}, ${b*Math.ceil(n[1]/2)}, ${b}, b, row, col);
      return ${c.texture2D}(${e}, uv);}`;return new h.GlslLibRoutine(v,["coordinates.packedUVfrom3D"])}getPackedSamplerND(i,e,t){const n=t.unpackedShape,r=n.length,o=[t.width,t.height],c=(0,f.getGlsl)(this.context.glContext.version),d=[o[0],o[1]],g=d[1],b=d[0],v=Math.ceil(n[r-1]/2);let w=v*Math.ceil(n[r-2]/2),x="int b, int row, int col",T=`b * ${w} + (row / 2) * ${v} + (col / 2)`;for(let _=2;_<r-1;_++)x=`int b${_}, `+x,w*=n[r-_-1],T=`b${_} * ${w} + `+T;const S=`vec4 ${i}(${x}) {
      int index = ${T};
      int texR = index / ${b};
      int texC = index - texR * ${b};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${b}, ${g});
      return ${c.texture2D}(${e}, uv);
    }`;return new h.GlslLibRoutine(S)}getUnpackedSamplerScalar(i,e,t){const[n,r]=[t.width,t.height];if(n===1&&r===1){const c=`
          float ${i}() {
            return sampleTexture(${e}, halfCR);
          }
        `;return new h.GlslLibRoutine(c,["coordinates.sampleTexture"])}const o=`
        float ${i}() {
          int offset_${e} = coordsToOffset(TexCoords, ${n}, ${r});
          vec2 uv = uvFromFlat(${n}, ${r}, offset_${e});
          return sampleTexture(${e}, uv);
        }
      `;return new h.GlslLibRoutine(o,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(i,e,t){const n=t.width,r=t.height;if(r===1&&n===1){const c=`
        float ${i}(int index) {
          return sampleTexture(${e}, halfCR);
        }
      `;return new h.GlslLibRoutine(c,["coordinates.sampleTexture"])}if(r===1){const c=`
          float ${i}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${n}.0, 0.5);
            return sampleTexture(${e}, uv);
          }
        `;return new h.GlslLibRoutine(c,["coordinates.sampleTexture"])}if(n===1){const c=`
          float ${i}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${r}.0);
            return sampleTexture(${e}, uv);
          }
        `;return new h.GlslLibRoutine(c,["coordinates.sampleTexture"])}const o=`
        float ${i}(int index) {
          vec2 uv = uvFromFlat(${n}, ${r}, index);
          return sampleTexture(${e}, uv);
        }
      `;return new h.GlslLibRoutine(o,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(i,e,t){const n=t.unpackedShape,r=[t.height,t.width];if(r!=null&&m.ArrayUtil.arraysEqual(n,r)){const w=`
          float ${i}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${r[1]}.0, ${r[0]}.0);
            return sampleTexture(${e}, uv);
          }
        `;return new h.GlslLibRoutine(w,["coordinates.sampleTexture"])}const{newShape:o,keptDims:c}=(0,s.squeezeShape)(n),d=o;if(d.length<n.length){const w=(0,l.squeezeInputShape)(n,d),x=JSON.parse(JSON.stringify(t));x.unpackedShape=w;const T=["col","row"],S=`
          ${this.getUnpackedSamplerFromInput(i,e,x).routineBody}
          float ${i}(int row, int col) {
            return ${i}(${(0,l.getSqueezedParams)(T,c)});
          }
        `;return new h.GlslLibRoutine(S,["coordinates.sampleTexture"])}const g=r[1],b=r[0];if(b===1){const w=`
          float ${i}(int row, int col) {
            int offset_${e} = coordsToOffset(TexCoords, ${g}, ${b});
            float index = dot(vec3(row, col, offset_${e}), vec3(${n[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${g}.0);
            return sampleTexture(${e}, uv);
          }
        `;return new h.GlslLibRoutine(w,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(g===1){const w=`
          float ${i}(int row, int col) {
            int offset_${e} = coordsToOffset(TexCoords, ${g}, ${b});
            float index = dot(vec3(row, col, offset_${e}), vec3(${n[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${b}.0, 0.5);
            return sampleTexture(${e}, uv);
          }
        `;return new h.GlslLibRoutine(w,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const v=`
        float ${i}(int row, int col) {
          int index = col * ${n[1]} + row;
          vec2 uv = uvFromFlat(${g}, ${b}, index);
          return sampleTexture(${e}, uv);
        }
      `;return new h.GlslLibRoutine(v,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(i,e,t){const n=t.unpackedShape,r=n[1]*n[2],o=n[2],{newShape:c,keptDims:d}=(0,s.squeezeShape)(n),g=c;if(g.length<n.length){const v=(0,l.squeezeInputShape)(n,g),w=["batch","col","row"],x=JSON.parse(JSON.stringify(t));x.unpackedShape=v;const T=this.getUnpackedSamplerFromInput(i,e,x),S=d.reverse(),_=`
          ${T.routineBody}
          float ${i}(int batch, int row, int col) {
            return ${i}(${(0,l.getSqueezedParams)(w,S)});
          }
        `;return new h.GlslLibRoutine(_,T.dependencies)}const b=`
          float ${i}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${r} + col * ${o} + row;
            vec2 uv = uvFromFlat(${t.width}, ${t.height}, index);
            return sampleTexture(${e}, uv);
          }
      `;return new h.GlslLibRoutine(b,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(i,e,t){const n=t.unpackedShape,r=n[3],o=n[2]*r,c=`
        float ${i}(int row, int col, int depth, int depth2) {
          int index = row * ${n[1]*o} + col * ${o} +
              depth2 * ${r} + depth;
          vec2 uv = uvFromFlat(${t.width}, ${t.height}, index);
          return sampleTexture(${e}, uv);
        }
      `;return new h.GlslLibRoutine(c,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(i,e,t){const n=t.unpackedShape,r=n[4],o=n[3]*r,c=n[2]*o,d=n[1]*c,{newShape:g,keptDims:b}=(0,s.squeezeShape)(n);if(g.length<n.length){const w=(0,l.squeezeInputShape)(n,g),x=["row","col","depth","depth2","depth3"],T=JSON.parse(JSON.stringify(t));T.unpackedShape=w;const S=`
          ${this.getUnpackedSamplerFromInput(i,e,T).routineBody}
          float ${i}(int row, int col, int depth, int depth2, int depth3) {
            return ${i}(${(0,l.getSqueezedParams)(x,b)});
          }
        `;return new h.GlslLibRoutine(S,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const v=`
        float ${i}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${d} + col * ${c} + depth * ${o} +
          depth3 * ${r} + depth2;
          vec2 uv = uvFromFlat(${t.width}, ${t.height}, index);
          return sampleTexture(${e}, uv);
        }
      `;return new h.GlslLibRoutine(v,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(i,e,t){const n=t.unpackedShape,r=n[5],o=n[4]*r,c=n[3]*o,d=n[2]*c,g=n[1]*d,{newShape:b,keptDims:v}=(0,s.squeezeShape)(n);if(b.length<n.length){const x=(0,l.squeezeInputShape)(n,b),T=["row","col","depth","depth2","depth3","depth4"],S=JSON.parse(JSON.stringify(t));S.unpackedShape=x;const _=`
            ${this.getUnpackedSamplerFromInput(i,e,S).routineBody}
            float ${i}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${i}(${(0,l.getSqueezedParams)(T,v)});
            }
          `;return new h.GlslLibRoutine(_,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const w=`
          float ${i}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${g} + col * ${d} + depth * ${c} +
            depth2 * ${o} + depth3 * ${r} + depth4;
            vec2 uv = uvFromFlat(${t.width}, ${t.height}, index);
            return sampleTexture(${e}, uv);
          }
        `;return new h.GlslLibRoutine(w,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const i=this.context.outputTextureLayout,e=i.shape.length,t=i.strides,n=i.width,r=i.height,o=[];for(let d=0;d<e-1;++d)o.push(`
        c[${d}] = offset / ${t[d]};`),o.push(`
        offset -= c[${d}] * ${t[d]};`);o.push(`
        c[${e-1}] = offset;`);const c=`
      void toVec(vec2 texCoords, out int c[${e}]) {
        int offset = coordsToOffset(texCoords, ${n}, ${r});
        ${o.join("")}
      }
      void toVec(int offset, out int c[${e}]) {
        ${o.join("")}
      }
    `;return{toVec:new h.GlslLibRoutine(c,["coordinates.coordsToOffset"])}}valueFrom(){const i={};return this.context.programInfo.inputNames.forEach((e,t)=>{const n=this.context.inputTextureLayouts[t],r=(n.unpackedShape.length>0?n.unpackedShape:n.shape).length;let o=`_${e}`;i[o]=new h.GlslLibRoutine(this.getValueFromSingle(e,r,n.width,n.height,!1),[`shapeUtils.indicesToOffset${o}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),o+="_T",i[o]=new h.GlslLibRoutine(this.getValueFromSingle(e,r,n.width,n.height,!0),[`shapeUtils.indicesToOffset${o}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),i}getValueFromSingle(i,e,t,n,r){let o=`_${i}`;return r&&(o+="_T"),`
        float ${o}(int m[${e}]) {
          int offset = indicesToOffset${o}(m);
          vec2 coords = offsetToCoords(offset, ${t}, ${n});
          float value = getColorAsFloat(${(0,f.getGlsl)(this.context.glContext.version).texture2D}(${i}, coords));
          return value;
        }
        `}getPackedValueFrom(i,e,t,n,r){let o=`_${i}_Pack`;return r&&(o+="_T"),`
        vec4 ${o}(int m[${e}]) {
          int offset = indicesToOffset_${i}(m);
          vec2 coords = offsetToCoords(offset, ${t}, ${n});
          return ${(0,f.getGlsl)(this.context.glContext.version).texture2D}(${i}, coords);
        }
        `}}u.CoordsGlslLib=p},1997:(R,u)=>{var y;Object.defineProperty(u,"__esModule",{value:!0}),u.TopologicalSortGlslRoutines=u.GlslLibRoutineNode=u.GlslLibRoutine=u.GlslLib=u.GlslContext=u.FunctionType=void 0,(y=u.FunctionType||(u.FunctionType={}))[y.ValueBased=0]="ValueBased",y[y.Positional=1]="Positional",u.GlslContext=class{constructor(m,h,f,s){this.glContext=m,this.programInfo=h,this.inputTextureLayouts=f,this.outputTextureLayout=s}},u.GlslLib=class{constructor(m){this.context=m}},u.GlslLibRoutine=class{constructor(m,h){this.routineBody=m,this.dependencies=h}},u.GlslLibRoutineNode=class{constructor(m,h,f){this.name=m,this.dependencies=f||[],h&&(this.routineBody=h)}addDependency(m){m&&this.dependencies.push(m)}},u.TopologicalSortGlslRoutines=class{static returnOrderedNodes(m){if(!m||m.length===0)return[];if(m.length===1)return m;const h=new Set,f=new Set,s=new Array;return this.createOrderedNodes(m,h,f,s),s}static createOrderedNodes(m,h,f,s){for(let l=0;l<m.length;++l)this.dfsTraverse(m[l],h,f,s)}static dfsTraverse(m,h,f,s){if(!m||f.has(m.name))return;if(h.has(m.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");h.add(m.name);const l=m.dependencies;if(l&&l.length>0)for(let p=0;p<l.length;++p)this.dfsTraverse(l[p],h,f,s);s.push(m),f.add(m.name),h.delete(m.name)}}},1371:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.EncodingGlslLib=void 0;const m=y(1997);class h extends m.GlslLib{constructor(s){super(s)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new m.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new m.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const s=h.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new m.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${s}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const s=h.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new m.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${s}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const s=new ArrayBuffer(4),l=new Uint32Array(s),p=new Uint8Array(s);if(l[0]=3735928559,p[0]===239)return!0;if(p[0]===222)return!1;throw new Error("unknown endianness")}}u.EncodingGlslLib=h},2691:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.FragColorGlslLib=void 0;const m=y(1997),h=y(6757);class f extends m.GlslLib{constructor(l){super(l)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const l=(0,h.getGlsl)(this.context.glContext.version);return{setFragColor:new m.GlslLibRoutine(`
        void setFragColor(float value) {
            ${l.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new m.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}u.FragColorGlslLib=f},3878:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.replaceInlines=void 0;const y=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;u.replaceInlines=function(m){const h={};let f;for(;(f=y.exec(m))!==null;){const s=f[3].split(",").map(l=>{const p=l.trim().split(" ");return p&&p.length===2?{type:p[0],name:p[1]}:null}).filter(l=>l!==null);h[f[2]]={params:s,body:f[4]}}for(const s in h){const l="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",s),p=new RegExp(l,"gm");for(;(f=p.exec(m))!==null;){const a=f[1],i=f[2],e=f[3].split(","),t=a?`${a} ${i};`:"";let n=h[s].body,r="";h[s].params.forEach((c,d)=>{c&&(r+=`${c.type} ${c.name} = ${e[d]};
`)}),n=`${r}
 ${n}`,n=n.replace("return",`${i} = `);const o=`
      ${t}
      {
        ${n}
      }
      `;m=m.replace(f[0],o)}}return m.replace(y,"")}},8897:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.GlslPreprocessor=void 0;const m=y(1997),h=y(3878),f=y(1248),s=y(6757);u.GlslPreprocessor=class{constructor(l,p,a,i){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new m.GlslContext(l,p,a,i),Object.keys(f.glslRegistry).forEach(t=>{const n=new f.glslRegistry[t](this.context);this.libs[t]=n});const e=this.glslLibRoutineDependencyGraph;for(const t in this.libs){const n=this.libs[t].getFunctions();for(const r in n){const o=t+"."+r;let c;e[o]?(c=e[o],c.routineBody=n[r].routineBody):(c=new m.GlslLibRoutineNode(o,n[r].routineBody),e[o]=c);const d=n[r].dependencies;if(d)for(let g=0;g<d.length;++g)if(e[d[g]])c.addDependency(e[d[g]]);else{const b=new m.GlslLibRoutineNode(d[g]);e[d[g]]=b,c.addDependency(b)}}}}preprocess(){const l=this.context.programInfo;let p=l.shaderSource;return this.context.programInfo.hasMain||(p=`${p}
      ${(0,s.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),p=(0,h.replaceInlines)(p),`${(0,s.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(l.inputNames,l.variables)}
    ${this.getImports(p)}
    ${p}`}getImports(l){const p=this.selectGlslLibRoutinesToBeIncluded(l);if(p.length===0)return"";let a="";for(let i=0;i<p.length;++i){if(!p[i].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${p[i].name}`);a+=p[i].routineBody+`
`}return a}selectGlslLibRoutinesToBeIncluded(l){const p=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(a=>{const i=a.split(".")[1];l.indexOf(i)!==-1&&p.push(this.glslLibRoutineDependencyGraph[a])}),m.TopologicalSortGlslRoutines.returnOrderedNodes(p)}getUniforms(l,p){const a=[];if(l)for(const i of l)a.push(`uniform sampler2D ${i};`);if(p)for(const i of p)a.push(`uniform ${i.type} ${i.name}${i.arrayLength?`[${i.arrayLength}]`:""};`);return a.join(`
`)}}},1248:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.glslRegistry=void 0;const m=y(6859),h=y(1371),f=y(2691),s=y(9183),l=y(9314);u.glslRegistry={encoding:h.EncodingGlslLib,fragcolor:f.FragColorGlslLib,vec:l.VecGlslLib,shapeUtils:s.ShapeUtilsGlslLib,coordinates:m.CoordsGlslLib}},9183:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.ShapeUtilsGlslLib=void 0;const m=y(1997);class h extends m.GlslLib{constructor(s){super(s)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const s=this.context.outputTextureLayout.shape.length,l={};return this.context.programInfo.inputNames.forEach((p,a)=>{const i=this.context.inputTextureLayouts[a].unpackedShape;if(i.length<=s){const e=i.length,t=s-e,n=`bcastIndices_${p}`;let r="";for(let c=0;c<e;++c)r+=`
          realIndices[${c}] = int( mod(float(bcastedIndices[${t+c}]), ${i[c]}.0) );
          `;const o=`
        void ${n} (int bcastedIndices[${s}], out int realIndices[${e}]) {
          ${r}
        }
        `;l[n]=new m.GlslLibRoutine(o)}}),l}bcastMatmulIndex(){const s=this.context.outputTextureLayout.shape.length,l={};return this.context.programInfo.inputNames.forEach((p,a)=>{const i=this.context.inputTextureLayouts[a].shape;if(!(i.length<2||i.length>s)){const e=i.length,t=s-e,n=`bcastMatmulIndices_${p}`;let r="";for(let c=0;c<e-2;++c)r+=`
          realIndices[${c}] = int( mod(float(bcastedIndices[${t+c}]), ${i[c]}.0) );
          `;const o=`
        void ${n}(int bcastedIndices[${s}], out int realIndices[${e}]) {
          ${r}
          realIndices[${e-1}] = bcastedIndices[${s-1}];
          realIndices[${e-2}] = bcastedIndices[${s-2}];
        }
        `;l[n]=new m.GlslLibRoutine(o)}}),l}indicesToOffset(){const s={};return this.context.programInfo.inputNames.forEach((l,p)=>{const a=this.context.inputTextureLayouts[p].shape,i=this.context.inputTextureLayouts[p].strides,e=a.length;let t=`indicesToOffset_${l}`;s[t]=new m.GlslLibRoutine(h.indexToOffsetSingle(t,e,i)),t=`indicesToOffset_${l}_T`,s[t]=new m.GlslLibRoutine(h.indexToOffsetSingle(t,e,i.slice().reverse()))}),s}static indexToOffsetSingle(s,l,p){let a="";for(let i=l-1;i>=0;--i)a+=`
        offset += indices[${i}] * ${p[i]};
        `;return`
      int ${s}(int indices[${l}]) {
        int offset = 0;
        ${a}
        return offset;
      }
      `}offsetToIndices(){const s={};return this.context.programInfo.inputNames.forEach((l,p)=>{const a=this.context.inputTextureLayouts[p].shape,i=this.context.inputTextureLayouts[p].strides,e=a.length;let t=`offsetToIndices_${l}`;s[t]=new m.GlslLibRoutine(h.offsetToIndicesSingle(t,e,i)),t=`offsetToIndices_${l}_T`,s[t]=new m.GlslLibRoutine(h.offsetToIndicesSingle(t,e,i.slice().reverse()))}),s}static offsetToIndicesSingle(s,l,p){const a=[];for(let i=0;i<l-1;++i)a.push(`
      indices[${i}] = offset / ${p[i]};`),a.push(`
        offset -= indices[${i}] * ${p[i]};`);return a.push(`
      indices[${l-1}] = offset;`),`
      void ${s}(int offset, out int indices[${l}]) {
        ${a.join("")}
      }
      `}incrementIndices(){const s={};return this.context.programInfo.inputNames.forEach((l,p)=>{const a=this.context.inputTextureLayouts[p].shape,i=a.length,e=`incrementIndices_${l}`;let t="";for(let r=0;r<i;++r)t+=`
        shape[${r}] = ${a[r]};`;const n=`
        void ${e}(int axis, out int indices[${i}]) {
          int shape[${i}];
          ${t};
          for(int i = ${i} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;s[e]=new m.GlslLibRoutine(n)}),s}}u.ShapeUtilsGlslLib=h},6757:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.getDefaultFragShaderMain=u.getFragShaderPreamble=u.getVertexShaderSource=u.getGlsl=void 0;const y={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},m={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function h(f){return f===1?y:m}u.getGlsl=h,u.getVertexShaderSource=function(f){const s=h(f);return`${s.version}
      precision highp float;
      ${s.attribute} vec3 position;
      ${s.attribute} vec2 textureCoord;

      ${s.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},u.getFragShaderPreamble=function(f){const s=h(f);return`${s.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${s.varyingFrag} vec2 TexCoords;
    ${s.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},u.getDefaultFragShaderMain=function(f,s){return`
  void main() {
    int indices[${s}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${h(f).output} = result;
  }
  `}},9314:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.VecGlslLib=void 0;const m=y(1997);class h extends m.GlslLib{constructor(s){super(s)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const s=this.context.outputTextureLayout.shape.length,l={add:"+=",sub:"-=",mul:"*=",div:"/="},p={};for(const a in l){const i=`${a}Vec`;let e="";for(let n=0;n<s;++n)e+=`
          dest[${n}] ${l[a]} src[${n}];
          `;const t=`
        void ${i}(int src[${s}], out int dest[${s}]) {
          ${e}
        }
        `;p[i]=new m.GlslLibRoutine(t)}return p}copyVec(){const s=this.context.outputTextureLayout.shape.length;let l="";for(let a=0;a<s;++a)l+=`
        dest[${a}] = src[${a}];
        `;const p=`
      void copyVec(int src[${s}], out int dest[${s}]) {
        ${l}
      }
      `;return{copyVec:new m.GlslLibRoutine(p)}}setVecItem(){const s=this.context.outputTextureLayout.shape.length;let l=`
        if(index < 0)
            index =${s} + index;
        if (index == 0)
            m[0] = value;
        `;for(let a=1;a<s-1;++a)l+=`
        else if (index == ${a})
            m[${a}] = value;
            `;l+=`
        else
            m[${s-1}] = value;
        `;const p=`
      void setVecItem(out int m[${s}], int index, int value) {
        ${l}
      }
        `;return{setVecItem:new m.GlslLibRoutine(p)}}getVecItem(){const s=this.context.outputTextureLayout.shape.length;let l=`
        if(index < 0)
            index = ${s} + index;
        if (index == 0)
            return m[0];
      `;for(let a=1;a<s-1;++a)l+=`
        else if (index == ${a})
            return m[${a}];
      `;l+=`
        else
            return m[${s-1}];
        `;const p=`
      int getVecItem(int m[${s}], int index) {
        ${l}
      }
    `;return{getVecItem:new m.GlslLibRoutine(p)}}}u.VecGlslLib=h},7860:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.WebGLInferenceHandler=void 0;const m=y(1315),h=y(9240),f=y(7273),s=y(9),l=y(7379),p=y(2488),a=y(540),i=y(3314),e=y(5639);u.WebGLInferenceHandler=class{constructor(t){this.session=t,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(t,n){return(0,i.calculateTextureWidthAndHeight)(this.session.layoutStrategy,t,n)}executeProgram(t,n){if(n.length<t.inputNames.length)throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);if(t.inputNames.length!==t.inputTypes.length)throw new Error("input names size does not match input types");const r=[];for(let v=0;v<t.inputNames.length;++v)r[v]=this.getOrCreateTextureData(n[v],t.inputTypes[v]);const o=((v,w)=>{const x=w.map(S=>`${S.unpackedShape.join(",")};${S.width}x${S.height}`).join("_");let T=v.name;return v.cacheHint&&(T+="["+v.cacheHint+"]"),T+=":"+x,T})(t,r);let c=this.session.programManager.getArtifact(o);const d=c?c.programInfo:typeof t.get=="function"?t.get():t,g=(0,i.createTextureLayoutFromTextureType)(this.session.layoutStrategy,d.output.dims,d.output.textureType),b=this.createTextureData(g,d.output.type);return c||(c=this.session.programManager.build(d,r,b),this.session.programManager.setArtifact(o,c)),this.runProgram(c,r,b),b}run(t,n){return this.executeProgram(t,n).tensor}runProgram(t,n,r){for(let o=0;o<n.length;++o)if(!!n[o].isPacked!=(t.programInfo.inputTypes[o]===e.TextureType.packed))throw new Error(`input[${o}] property packed inconsistent`);if(!!r.isPacked!=(t.programInfo.output.textureType===e.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(t,n,r)}getOrCreateTextureData(t,n){let r=this.getTextureData(t.dataId,n===e.TextureType.packed);if(!r&&(r=this.getTextureData(t.dataId,n!==e.TextureType.packed),r))return n===e.TextureType.packed?this.pack(r):this.unpack(r);if(!r){const o=(0,i.createTextureLayoutFromTextureType)(this.session.layoutStrategy,t.dims,n);if(n===e.TextureType.packedLastDimension){const g=t.dims;if(g.length===4){const b=[g[0],Math.ceil(g[1]*g[2]*g[3]/4)],v=(0,i.createTextureLayoutFromTextureType)(this.session.layoutStrategy,b,n);let w=t.numberData;if(g[1]*g[2]*g[3]%4!=0){const x=g[0],T=g[1]*g[2]*g[3],S=Math.ceil(T*1/4)*4;w=new Float32Array(x*S);for(let _=0;_<x;++_){const A=_*T,E=_*S+_%1*T;w.set(t.numberData.subarray(A,A+T),E)}}return this.createTextureData(v,t.type,w,t,1)}}if(n===e.TextureType.packed){const c=(0,i.createTextureLayoutFromShape)(this.session.layoutStrategy,t.dims,1,[],{reverseWH:!0}),d=this.createTextureData(c,t.type,t.numberData,t,1);r=this.pack(d)}else r=this.createTextureData(o,t.type,t.numberData,t,1)}return r}createTextureDataFromLayoutBindTensor(t,n,r,o){return this.createTextureData(t,n,r,o,1)}createTextureData(t,n,r,o,c){m.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(t)}]`);const d=this.session.textureManager.createTextureFromLayout(n,t,r,c);return this.createTextureDataFromTexture(t,n,d,o)}reshapeUnpacked(t,n){const r=this.getOrCreateTextureData(t,e.TextureType.unpacked),o={channels:r.channels,height:r.height,width:r.width,shape:n.length!==0?n:[1],strides:f.ShapeUtil.computeStrides(n),unpackedShape:n};return this.createTextureDataFromTexture(o,t.type,r.texture).tensor}reshapePacked(t,n){const r=this.getOrCreateTextureData(t,e.TextureType.packed);if((0,l.isReshapeCheap)(t.dims,n)){const b={channels:r.channels,height:r.height,width:r.width,shape:n.length!==0?n:[1],strides:f.ShapeUtil.computeStrides(n),unpackedShape:n,isPacked:!0};return this.createTextureDataFromTexture(b,t.type,r.texture).tensor}const o=(0,l.processDims3D)(t.dims),c=(0,l.processDims3D)(n),d=this.reshapePacked(t,o),g=this.run((0,l.createPackedReshape3DProgramInfoLoader)(this,d,c),[d]);return this.reshapePacked(g,n)}cast(t,n){const r=this.getOrCreateTextureData(t,e.TextureType.unpacked);return this.createTextureDataFromTexture(r,n,r.texture).tensor}createTextureDataFromTexture(t,n,r,o,c){const d=Object.assign(Object.assign({},t),{tensor:o||new h.Tensor(t.unpackedShape,n,g=>this.readTexture(d),async g=>this.readTextureAsync(d),void 0,c),texture:r});return this.setTextureData(d.tensor.dataId,d,t.isPacked),d}getTextureData(t,n=!1){return this.session.isInitializer(t)?this.session.getTextureData(t,n):n?this.packedTextureDataCache.get(t):this.unpackedTextureDataCache.get(t)}setTextureData(t,n,r=!1){this.session.isInitializer(t)?this.session.setTextureData(t,n,r):(r?this.packedTextureDataCache:this.unpackedTextureDataCache).set(t,n)}isTextureLayoutCached(t,n=!1){return!!this.getTextureData(t.dataId,n)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(t=>this.session.textureManager.releaseTexture(t)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(t=>this.session.textureManager.releaseTexture(t)),this.unpackedTextureDataCache=new Map}readTexture(t){return t.isPacked?this.readTexture(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,p.encodeAsUint8)(this,t))}async readTextureAsync(t){return t.isPacked?this.readTextureAsync(this.unpack(t)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(t,t.tensor.type,t.channels):this.session.textureManager.readUint8TextureAsFloat((0,p.encodeAsUint8)(this,t))}pack(t){return this.executeProgram((0,s.createPackProgramInfoLoader)(this,t.tensor),[t.tensor])}unpack(t){return this.executeProgram((0,a.createUnpackProgramInfoLoader)(this,t.tensor),[t.tensor])}}},4110:function(R,u,y){var m=this&&this.__createBinding||(Object.create?function(J,q,tt,rt){rt===void 0&&(rt=tt);var Z=Object.getOwnPropertyDescriptor(q,tt);Z&&!("get"in Z?!q.__esModule:Z.writable||Z.configurable)||(Z={enumerable:!0,get:function(){return q[tt]}}),Object.defineProperty(J,rt,Z)}:function(J,q,tt,rt){rt===void 0&&(rt=tt),J[rt]=q[tt]}),h=this&&this.__setModuleDefault||(Object.create?function(J,q){Object.defineProperty(J,"default",{enumerable:!0,value:q})}:function(J,q){J.default=q}),f=this&&this.__importStar||function(J){if(J&&J.__esModule)return J;var q={};if(J!=null)for(var tt in J)tt!=="default"&&Object.prototype.hasOwnProperty.call(J,tt)&&m(q,J,tt);return h(q,J),q};Object.defineProperty(u,"__esModule",{value:!0}),u.WEBGL_OP_RESOLVE_RULES=void 0;const s=y(8817),l=f(y(5194)),p=y(4752),a=y(6668),i=y(9754),e=y(5042),t=y(6742),n=y(4125),r=y(6149),o=y(5378),c=y(6981),d=y(7413),g=y(7006),b=y(8276),v=y(5565),w=y(2834),x=y(1010),T=y(8126),S=y(2801),_=y(565),A=y(2444),E=y(815),C=y(564),D=y(5416),$=y(1240),L=y(5944),P=y(5707),k=f(y(9087)),V=y(7862),z=y(3980);u.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",k.abs],["Acos","","7+",k.acos],["Add","","7+",l.add],["And","","7+",l.and],["Asin","","7+",k.asin],["Atan","","7+",k.atan],["AveragePool","","7+",w.averagePool,w.parseAveragePoolAttributes],["BatchNormalization","","7+",s.batchNormalization,s.parseBatchNormalizationAttributes],["Cast","","6+",p.cast,p.parseCastAttributes],["Ceil","","6+",k.ceil],["Clip","","6-10",k.clip,k.parseClipAttributes],["Clip","","11+",k.clipV11],["Concat","","4+",a.concat,a.parseConcatAttributes],["Conv","","1+",i.conv,i.parseConvAttributes],["ConvTranspose","","1+",e.convTranspose,e.parseConvTransposeAttributes],["Cos","","7+",k.cos],["Div","","7+",l.div],["Dropout","","7+",k.identity],["DepthToSpace","","1+",t.depthToSpace,t.parseDepthToSpaceAttributes],["Equal","","7+",l.equal],["Elu","","6+",k.elu,k.parseEluAttributes],["Exp","","6+",k.exp],["Flatten","","1+",n.flatten,n.parseFlattenAttributes],["Floor","","6+",k.floor],["FusedConv","com.microsoft","1+",i.conv,i.parseConvAttributes],["Gather","","1+",r.gather,r.parseGatherAttributes],["Gemm","","7-10",o.gemm,o.parseGemmAttributesV7],["Gemm","","11+",o.gemm,o.parseGemmAttributesV11],["GlobalAveragePool","","1+",w.globalAveragePool,w.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",w.globalMaxPool],["Greater","","7+",l.greater],["Identity","","1+",k.identity],["ImageScaler","","1+",c.imageScaler,c.parseImageScalerAttributes],["InstanceNormalization","","6+",d.instanceNormalization,d.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",k.leakyRelu,k.parseLeakyReluAttributes],["Less","","7+",l.less],["LRN","","1+",g.lrn,g.parseLrnAttributes],["Log","","6+",k.log],["MatMul","","1+",b.matMul,b.parseMatMulAttributes],["MaxPool","","1+",w.maxPool,w.parseMaxPoolAttributes],["Mul","","7+",l.mul],["Neg","","6+",k.neg],["Not","","1+",k.not],["Or","","7+",l.or],["Pad","","2-10",v.padV2,v.parsePadAttributesV2],["Pad","","11+",v.padV11,v.parsePadAttributesV11],["Pow","","7+",l.pow],["PRelu","","7+",l.pRelu],["ReduceLogSum","","1+",x.reduceLogSum,x.parseReduceAttributes],["ReduceMax","","1+",x.reduceMax,x.parseReduceAttributes],["ReduceMean","","1+",x.reduceMean,x.parseReduceAttributes],["ReduceMin","","1+",x.reduceMin,x.parseReduceAttributes],["ReduceProd","","1+",x.reduceProd,x.parseReduceAttributes],["ReduceSum","","1-12",x.reduceSum,x.parseReduceAttributes],["ReduceSumSquare","","1+",x.reduceLogSumSquare,x.parseReduceAttributes],["Relu","","6+",k.relu],["Reshape","","5+",T.reshape],["Resize","","10",S.resize,S.parseResizeAttributesV10],["Resize","","11+",S.resize,S.parseResizeAttributesV11],["Shape","","1+",_.shape],["Sigmoid","","6+",k.sigmoid],["Sin","","7+",k.sin],["Slice","","10+",A.sliceV10],["Slice","","1-9",A.slice,A.parseSliceAttributes],["Softmax","","1-12",E.softmax,E.parseSoftmaxAttributes],["Softmax","","13+",E.softmaxV13,E.parseSoftmaxAttributesV13],["Split","","2-12",C.split,C.parseSplitAttributes],["Sqrt","","6+",k.sqrt],["Squeeze","","1-12",D.squeeze,D.parseSqueezeAttributes],["Squeeze","","13+",D.squeezeV13],["Sub","","7+",l.sub],["Sum","","6+",$.sum],["Tan","","7+",k.tan],["Tanh","","6+",k.tanh],["Tile","","6+",L.tile],["Transpose","","1+",P.transpose,P.parseTransposeAttributes],["Upsample","","7-8",z.upsample,z.parseUpsampleAttributesV7],["Upsample","","9",z.upsample,z.parseUpsampleAttributesV9],["Unsqueeze","","1-12",V.unsqueeze,V.parseUnsqueezeAttributes],["Unsqueeze","","13+",V.unsqueezeV13],["Xor","","7+",l.xor]]},8817:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseBatchNormalizationAttributes=u.batchNormalization=void 0;const m=y(4910),h=y(6757),f=y(5639),s={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[f.TextureType.unpacked,f.TextureType.unpacked,f.TextureType.unpacked,f.TextureType.unpacked,f.TextureType.unpacked]};u.batchNormalization=(a,i,e)=>(p(i),[a.run(Object.assign(Object.assign({},s),{cacheHint:e.cacheKey,get:()=>l(a,i,e)}),i)]),u.parseBatchNormalizationAttributes=a=>{const i=a.attributes.getFloat("epsilon",1e-5),e=a.attributes.getFloat("momentum",.9),t=a.attributes.getInt("spatial",1);return(0,m.createAttributeWithCacheKey)({epsilon:i,momentum:e,spatial:t})};const l=(a,i,e)=>{const t=(0,h.getGlsl)(a.session.backend.glContext.version),n=i[0].dims.length,[r,o]=a.calculateTextureWidthAndHeight(i[1].dims,f.TextureType.unpacked),c=`
  float process(int[${n}] indices) {
    vec2 position = offsetToCoords(indices[1], ${r}, ${o});
    float scale = getColorAsFloat(${t.texture2D}(Scale, position));
    float mean = getColorAsFloat(${t.texture2D}(Mean, position));
    float variance = getColorAsFloat(${t.texture2D}(Variance, position));
    float b = getColorAsFloat(${t.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${e.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},s),{output:{dims:i[0].dims,type:i[0].type,textureType:f.TextureType.unpacked},shaderSource:c})},p=a=>{if(!a||a.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const i=a[0],e=a[1],t=a[2],n=a[3],r=a[4];if(i.dims.length<3||e.dims.length!==1||t.dims.length!==1||n.dims.length!==1||r.dims.length!==1)throw new Error("invalid input shape.");if(e.dims[0]!==i.dims[1]||t.dims[0]!==i.dims[1]||n.dims[0]!==i.dims[1]||r.dims[0]!==i.dims[1])throw new Error("invalid input shape.");if(i.type!=="float32"&&i.type!=="float64"||e.type!=="float32"&&e.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||n.type!=="float32"&&n.type!=="float64"||r.type!=="float32"&&r.type!=="float64")throw new Error("invalid input tensor types.")}},5194:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.xor=u.sub=u.pRelu=u.pow=u.or=u.mul=u.less=u.greater=u.equal=u.div=u.and=u.add=u.glslPRelu=u.glslPow=u.glslXor=u.glslOr=u.glslAnd=u.glslLess=u.glslGreater=u.glslEqual=u.glslSub=u.glslMul=u.glslDiv=u.glslAdd=void 0;const m=y(7273),h=y(1997),f=y(6757),s=y(5639);function l(){const w="add_";return{body:`
  float ${w}(float a, float b) {
    return a + b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:w,type:h.FunctionType.ValueBased}}function p(){const w="div_";return{body:`
  float ${w}(float a, float b) {
    return a / b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:w,type:h.FunctionType.ValueBased}}function a(){const w="mul_";return{body:`
  float ${w}(float a, float b) {
    return a * b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:w,type:h.FunctionType.ValueBased}}function i(){const w="sub_";return{body:`
  float ${w}(float a, float b) {
    return a - b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:w,type:h.FunctionType.ValueBased}}function e(){const w="equal_";return{body:`
  float ${w}(float a, float b) {
    return float(a == b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:w,type:h.FunctionType.ValueBased}}function t(){const w="greater_";return{body:`
  float ${w}(float a, float b) {
    return float(a > b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:w,type:h.FunctionType.ValueBased}}function n(){const w="less_";return{body:`
  float ${w}(float a, float b) {
    return float(a < b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:w,type:h.FunctionType.ValueBased}}function r(){const w="and_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:w,type:h.FunctionType.ValueBased}}function o(){const w="or_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:w,type:h.FunctionType.ValueBased}}function c(){const w="xor_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:w,type:h.FunctionType.ValueBased}}function d(){return function(w){const x=`${w}_`;return{body:`
  float ${x}(float a, float b) {
    return ${w}(a, b);
  }
  vec4 ${x}(vec4 v1, vec4 v2) {
    return ${w}(v1, v2);
  }
  `,name:x,type:h.FunctionType.ValueBased}}("pow")}function g(){const w="prelu_";return{body:`
  float ${w}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:w,type:h.FunctionType.ValueBased}}u.glslAdd=l,u.glslDiv=p,u.glslMul=a,u.glslSub=i,u.glslEqual=e,u.glslGreater=t,u.glslLess=n,u.glslAnd=r,u.glslOr=o,u.glslXor=c,u.glslPow=d,u.glslPRelu=g;const b=(w,x,T,S=x[0].type,_)=>{const A=w.session.pack?s.TextureType.packed:s.TextureType.unpacked;return{name:T.name,inputNames:["A","B"],inputTypes:[A,A],cacheHint:_,get:()=>v(w,x,T,S)}},v=(w,x,T,S=x[0].type)=>{const _=w.session.pack?s.TextureType.packed:s.TextureType.unpacked,A=!m.ShapeUtil.areEqual(x[0].dims,x[1].dims);let E=x[0].dims;const C=w.session.pack;if(A){const L=m.BroadcastUtil.calcShape(x[0].dims,x[1].dims,!1);if(!L)throw new Error("Can't perform binary op on the given tensors");E=L;const P=E.length,k=x[0].dims.length!==0?x[0].dims.length:1,V=x[1].dims.length!==0?x[1].dims.length:1,z=x[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",J=x[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",q=(0,f.getGlsl)(w.session.backend.glContext.version),tt=C?`
      ${T.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${T.name}(a, b);
        ${q.output} = result;
      }`:`
      ${T.body}
      float process(int indices[${P}]) {
        int aindices[${k}];
        int bindices[${V}];
        ${z}
        ${J}
        return ${T.name}(_A(aindices), _B(bindices));
      }`;return{name:T.name,inputNames:["A","B"],inputTypes:[_,_],output:{dims:E,type:S,textureType:_},shaderSource:tt,hasMain:C}}const D=(0,f.getGlsl)(w.session.backend.glContext.version),$=`
    ${T.body}
    void main() {
      vec4 v1 = ${D.texture2D}(A, TexCoords);
      vec4 v2 = ${D.texture2D}(B, TexCoords);
      vec4 result = ${T.name}(v1, v2);
      ${D.output} = result;
    }
    `;return{name:T.name,inputNames:["A","B"],inputTypes:[_,_],output:{dims:x[0].dims,type:S,textureType:_},shaderSource:$,hasMain:!0}};u.add=(w,x)=>[w.run(b(w,x,l()),x)],u.and=(w,x)=>[w.run(b(w,x,r(),"bool"),x)],u.div=(w,x)=>[w.run(b(w,x,p()),x)],u.equal=(w,x)=>[w.run(b(w,x,e(),"bool"),x)],u.greater=(w,x)=>[w.run(b(w,x,t(),"bool"),x)],u.less=(w,x)=>[w.run(b(w,x,n(),"bool"),x)],u.mul=(w,x)=>[w.run(b(w,x,a()),x)],u.or=(w,x)=>[w.run(b(w,x,o(),"bool"),x)],u.pow=(w,x)=>[w.run(b(w,x,d()),x)],u.pRelu=(w,x)=>[w.run(b(w,x,g()),x)],u.sub=(w,x)=>[w.run(b(w,x,i()),x)],u.xor=(w,x)=>[w.run(b(w,x,c(),"bool"),x)]},4752:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseCastAttributes=u.cast=void 0;const m=y(7273);u.cast=(f,s,l)=>(h(s),[f.cast(s[0],l)]),u.parseCastAttributes=f=>m.ProtoUtil.tensorDataTypeFromProto(f.attributes.getInt("to"));const h=f=>{if(!f||f.length!==1)throw new Error("Cast requires 1 input.");if(f[0].type==="string")throw new Error("Invalid input type.")}},4595:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createPackedConcatProgramInfoLoader=void 0;const m=y(6757),h=y(5639),f=y(432),s=y(5614);u.createPackedConcatProgramInfoLoader=(p,a,i)=>{const e=(t=a.length,n=i.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:t},(r,o)=>`X${o}`),inputTypes:Array(t).fill(h.TextureType.packed),cacheHint:n});var t,n;return Object.assign(Object.assign({},e),{get:()=>((r,o,c,d)=>{const g=c[0].dims.slice();if(d>=g.length||d<-1*g.length)throw new Error("axis specified for concat doesn't match input dimensionality");d<0&&(d=g.length+d);const b=g.slice(0);for(let z=1;z<c.length;z++){const J=c[z].dims.slice();for(let q=0;q<g.length;q++)if(q===d)b[d]+=J[q];else if(g[q]!==J[q])throw new Error("non concat dimensions must match")}const v=b.length,w=(0,s.getChannels)("coords",v),x=(0,f.getCoordsDataType)(v),T=(0,s.unpackFromChannel)(),S=c.map(z=>z.dims),_=(0,f.getGlChannels)(v),A=new Array(S.length-1);A[0]=S[0][d];for(let z=1;z<A.length;z++)A[z]=A[z-1]+S[z][d];const E=_[d],C=_.slice(-2),D=_.join();let $=`if (${E} < ${A[0]}) {
        return getChannel(
            getX0(${D}), vec2(${C.join()}));
        }`;for(let z=1;z<A.length;z++){const J=A[z-1];$+=`
            if (${E} < ${A[z]}  && ${E} >= ${A[z-1]}) {
              return getChannel(
                getX${z}(${l(_,E,J)}),
                vec2(${l(C,E,J)}));
            }`}const L=A.length,P=A[A.length-1];$+=`
            return getChannel(
              getX${L}(${l(_,E,P)}),
              vec2(${l(C,E,P)}));`;const k=(0,m.getGlsl)(r.session.backend.glContext.version),V=`
          ${T}
          float getValue(${_.map(z=>"int "+z)}) {
            ${$}
          }

          void main() {
            ${x} coords = getOutputCoords();
            int lastDim = coords.${_[v-1]};
            coords.${_[v-1]} = coords.${_[v-2]};
            coords.${_[v-2]} = lastDim;

            vec4 result = vec4(getValue(${w}), 0., 0., 0.);

            ${w[v-1]} = ${w[v-1]} + 1;
            if (${w[v-1]} < ${b[v-1]}) {
              result.g = getValue(${w});
            }

            ${w[v-2]} = ${w[v-2]} + 1;
            if (${w[v-2]} < ${b[v-2]}) {
              result.a = getValue(${w});
            }

            ${w[v-1]} = ${w[v-1]} - 1;
            if (${w[v-2]} < ${b[v-2]} &&
                ${w[v-1]} < ${b[v-1]}) {
              result.b = getValue(${w});
            }
            ${k.output} = result;
          }
        `;return Object.assign(Object.assign({},o),{output:{dims:b,type:c[0].type,textureType:h.TextureType.packed},shaderSource:V,hasMain:!0})})(p,e,a,i.axis)})};const l=(p,a,i)=>{const e=p.indexOf(a);return p.map((t,n)=>n===e?`${t} - ${i}`:t).join()}},6668:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseConcatAttributes=u.concat=void 0;const m=y(4910),h=y(5639),f=y(4595);u.concat=(t,n,r)=>(e(n),t.session.pack&&n[0].dims.length>1?[t.run((0,f.createPackedConcatProgramInfoLoader)(t,n,r),n)]:[t.run(s(t,n,r),n)]);const s=(t,n,r)=>{const o=(c=n.length,d=r.cacheKey,{name:"Concat",inputNames:Array.from({length:c},(g,b)=>`X${b}`),inputTypes:Array(c).fill(h.TextureType.unpacked),cacheHint:d});var c,d;return Object.assign(Object.assign({},o),{get:()=>((g,b,v,w)=>{const x=v[0].dims.slice();if(w>=x.length||w<-1*x.length)throw new Error("axis specified for concat doesn't match input dimensionality");w<0&&(w=x.length+w);const T=x.slice(0);for(let D=1;D<v.length;D++){const $=v[D].dims.slice();for(let L=0;L<x.length;L++)if(L===w)T[w]+=$[L];else if(x[L]!==$[L])throw new Error("non concat dimensions must match")}const S=T.length,_=new Array(v.length);let A=0;for(let D=0;D<_.length;++D)A+=v[D].dims[w],_[D]=A;let E="";E=v.length<5?l(_):p(_);const C=`
        ${a(v.length,S)}
        ${i(_)}
        ${E}
        float process(int indices[${S}]) {
          int textureIndex = getTextureWhereDataResides (indices[${w}]);

          if(textureIndex != 0) {
            indices[${w}] = indices[${w}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},b),{output:{dims:T,type:v[0].type,textureType:h.TextureType.unpacked},shaderSource:C})})(0,o,n,r.axis)})},l=t=>`int getTextureWhereDataResides(int index) {
      ${t.map((n,r)=>`if(index<${n}) {return ${r};}
`).join("")}
    }`,p=t=>l(t),a=(t,n)=>{const r=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${n}]) {`];for(let o=0;o<t;++o)o===0?r.push(`	if (textureIndex == ${o}) { return _X${o}(indices); }`):o===t-1?r.push(`	else { return _X${o}(indices); }`):r.push(`	else if (textureIndex == ${o}) { return _X${o}(indices); }`);return r.push("	}"),r.join(`
`)},i=t=>{const n=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let r=0;r<t.length;++r)r===0?n.push(`	if (index == ${r}) { return ${t[r]}; }`):r===t.length-1?n.push(`	else { return ${t[r]}; }`):n.push(`	else if (index == ${r}) { return ${t[r]}; }`);return n.push("	}"),n.join(`
`)};u.parseConcatAttributes=t=>(0,m.createAttributeWithCacheKey)({axis:t.attributes.getInt("axis")});const e=t=>{if(!t||t.length<1)throw new Error("too few inputs");const n=t[0].type,r=t[0].dims.length;if(n==="string")throw new Error("string tensor is not supported yet");for(const o of t){if(o.type!==n)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}}},7825:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createUnpackedGroupedConvProgramInfoLoader=void 0;const m=y(1315),h=y(6757),f=y(5639),s=y(9754),l=y(2150);u.createUnpackedGroupedConvProgramInfoLoader=(p,a,i)=>{const e=(t=a.length>2,n=i.cacheKey,{name:"GroupedConv",inputNames:t?["X","W","Bias"]:["X","W"],inputTypes:t?[f.TextureType.unpacked,f.TextureType.unpacked,f.TextureType.unpacked]:[f.TextureType.unpacked,f.TextureType.unpacked],cacheHint:n});var t,n;return Object.assign(Object.assign({},e),{get:()=>((r,o,c,d)=>{const g=o.length>2?"value += getBias(output_channel);":"",b=o[0].dims.slice(),v=o[1].dims.slice(),w=v[0]/d.group;m.Logger.verbose("GroupedConv",`autpPad:${d.autoPad}, dilations:${d.dilations}, group:${d.group}, kernelShape:${d.kernelShape}, pads:${d.pads}, strides:${d.strides}`);const x=(0,s.calculateOutputShape)(b,v,d.dilations,d.pads,d.strides),T=(0,h.getGlsl)(r.session.backend.glContext.version),{activationFunction:S,applyActivation:_}=(0,l.getActivationSnippet)(d),A=`
  const ivec2 strides = ivec2(${d.strides[0]}, ${d.strides[1]});
  const ivec2 pads = ivec2(${d.pads[0]}, ${d.pads[1]});
  ${S}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${w};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${v[1]}; wInChannel++) {
      int input_channel = group_id * ${v[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${v[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${d.dilations[0]};

        if (xHeight < 0 || xHeight >= ${b[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${v[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${d.dilations[1]};
          if (xWidth < 0 || xWidth >= ${b[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${g}
    ${_}
    ${T.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},c),{output:{dims:x,type:o[0].type,textureType:f.TextureType.unpacked},shaderSource:A,hasMain:!0})})(p,a,e,i)})}},7708:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.conv2DPacked=u.conv2DPackedPointwise=void 0;const m=y(9754),h=y(5950),f=y(5632);u.conv2DPackedPointwise=(s,l,p)=>{const a=l[0].dims,i=l[1].dims,e=(0,m.calculateOutputShape)(a,i,p.dilations,p.pads,p.strides),t=s.reshapePacked(l[0],[a[1],a[2]*a[3]]),n=s.reshapePacked(l[1],[i[0],i[1]]),r=l.length>2?[n,t,l[2]]:[n,t],o=s.run((0,f.createPackedMatmulProgramInfoLoader)(s,r,p),r);return s.reshapePacked(o,e)},u.conv2DPacked=(s,l,p)=>{const a=l[0].dims,i=l[1].dims,e=(0,m.calculateOutputShape)(a,i,p.dilations,p.pads,p.strides),t=s.run((0,h.createPackedIm2ColProgramInfoLoader)(s,l[0],l[1],e,p),[l[0]]),n=s.reshapePacked(l[1],[i[0],i[1]*i[2]*i[3]]),r=l.length===3?[n,t,l[2]]:[n,t],o=s.run((0,f.createPackedMatmulProgramInfoLoader)(s,r,p),r);return s.reshapePacked(o,e)}},5042:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseConvTransposeAttributes=u.convTranspose=void 0;const m=y(4910),h=y(6757),f=y(5639),s=y(2150),l=(n,r,o,c,d,g)=>(n-1)*r+o+(c-1)*d+1-g,p=(n,r,o,c,d)=>{const g=Math.floor(n/2);r==="SAME_UPPER"?(o[c]=g,o[d]=n-g):r==="SAME_LOWER"&&(o[c]=n-g,o[d]=g)};u.convTranspose=(n,r,o)=>(t(r,o),a(n,r,o));const a=(n,r,o)=>{const c=e(o,r);return[i(n,r,c)]},i=(n,r,o)=>n.run(((c,d,g)=>{const b=(v=d.length>2,w=g.cacheKey,{name:"ConvTranspose",inputNames:v?["X","W","B"]:["X","W"],inputTypes:v?[f.TextureType.unpacked,f.TextureType.unpacked,f.TextureType.unpacked]:[f.TextureType.unpacked,f.TextureType.unpacked],cacheHint:w});var v,w;return Object.assign(Object.assign({},b),{get:()=>((x,T,S,_)=>{const A=T.length>2?"getB(output_channel)":"0.0",E=T[0].dims,C=T[1].dims,D=C[1],$=C[0]/_.group,L=[T[0].dims[0],T[1].dims[1]*_.group,..._.outputShape],P=(0,h.getGlsl)(x.session.backend.glContext.version),{activationFunction:k,applyActivation:V}=(0,s.getActivationSnippet)(_),z=`
  const ivec2 strides = ivec2(${_.strides[0]}, ${_.strides[1]});
  const ivec2 pads = ivec2(${_.pads[0]}, ${_.pads[1]});
  ${k}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${D};
    int wOutChannel = output_channel - group_id * ${D};

    float value = ${A};
    for (int inChannelOffset = 0; inChannelOffset < ${$}; inChannelOffset++) {
      int input_channel = group_id * ${$} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${C[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${C[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${_.dilations[0]}, wHOff * ${_.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${E[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${E[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${V}
    ${P.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},S),{output:{dims:L,type:T[0].type,textureType:f.TextureType.unpacked},shaderSource:z,hasMain:!0})})(c,d,b,g)})})(n,r,o),r),e=(n,r)=>{const o=n.kernelShape.slice();if(n.kernelShape.length===0)for(let b=2;b<r[1].dims.length;++b)o.push(r[1].dims[b]);const c=n.pads.slice(),d=n.outputShape.slice();((b,v,w,x,T,S,_,A)=>{const E=b.length-2,C=A.length===0;for(let D=0;D<E;++D){const $=C?b[D+2]*S[D]:A[D],L=l(b[D+2],S[D],T[D],v[D],w[D],$);p(L,x,T,D,D+E),C&&A.push(S[D]*(b[D+2]-1)+_[D]+(v[D]-1)*w[D]+1-T[D]-T[D+E])}})(r[0].dims,o,n.dilations,n.autoPad,c,n.strides,n.outputPadding,d);const g=Object.assign({},n);return Object.assign(g,{kernelShape:o,pads:c,outputShape:d,cacheKey:n.cacheKey}),g};u.parseConvTransposeAttributes=n=>{const r=n.attributes,o=(0,s.parseInternalActivationAttributes)(r),c=r.getString("auto_pad","NOTSET"),d=r.getInts("dilations",[1,1]),g=r.getInt("group",1),b=r.getInts("kernel_shape",[]),v=r.getInts("output_padding",[0,0]),w=r.getInts("output_shape",[]),x=r.getInts("pads",[0,0,0,0]),T=r.getInts("strides",[1,1]);return(0,m.createAttributeWithCacheKey)(Object.assign({autoPad:c,dilations:d,group:g,kernelShape:b,outputPadding:v,outputShape:w,pads:x,strides:T},o))};const t=(n,r)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4||n[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(n[0].dims[1]!==n[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const o=n[1].dims[1]*r.group;if(n.length===3&&(n[2].dims.length!==1||n[2].dims[0]!==o))throw new Error("invalid bias");const c=n[0].dims.length-2;if(r.dilations.length!==c)throw new Error(`dilations should be ${c}D`);if(r.strides.length!==c)throw new Error(`strides should be ${c}D`);if(r.pads.length!==2*c)throw new Error(`pads should be ${2*c}D`);if(r.outputPadding.length!==c)throw new Error(`output_padding should be ${c}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==n[0].dims.length-2)throw new Error("invalid output shape");if(n[0].type!=="float32"||n[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(n.length===3&&n[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseConvAttributes=u.conv=u.calculateOutputShape=void 0;const m=y(4910),h=y(7273),f=y(7825),s=y(7708),l=y(3281),p=y(2150),a=y(1625),i=y(8276);u.calculateOutputShape=(c,d,g,b,v)=>{const w=c[0],x=c.slice(2),T=x.length,S=d[0],_=d.slice(2).map((E,C)=>E+(E-1)*(g[C]-1)),A=x.map((E,C)=>E+b[C]+b[C+T]).map((E,C)=>Math.floor((E-_[C]+v[C])/v[C]));return[w,S].concat(...A)},u.conv=(c,d,g)=>(o(d,g),e(c,d,g));const e=(c,d,g)=>{const b=r(g,d),v=c.session.pack,w=b.kernelShape[0]===1&&b.kernelShape[1]===1;return b.group>1?[c.run((0,f.createUnpackedGroupedConvProgramInfoLoader)(c,d,b),d)]:w&&v?[t(c,d,b)]:v&&d[0].dims.length===4&&d[0].dims[0]===1&&!w?[(0,s.conv2DPacked)(c,d,b)]:[n(c,d,b)]},t=(c,d,g)=>{const b=d[0].dims,v=d[1].dims,w=(0,u.calculateOutputShape)(b,v,g.dilations,g.pads,g.strides),x=c.reshapeUnpacked(d[0],[b[1],b[2]*b[3]]),T=c.reshapeUnpacked(d[1],[v[0],v[1]]),S=d.length>2?[T,x,d[2]]:[T,x],_=c.run((0,i.createMatmulProgramInfoLoader)(S,g),S);return c.reshapeUnpacked(_,w)},n=(c,d,g)=>{const b=d[0].dims,v=d[1].dims,w=(0,u.calculateOutputShape)(b,v,g.dilations,g.pads,g.strides),x=c.run((0,a.createIm2ColProgramInfoLoader)(c,d[0],d[1],w,g),[d[0]]),T=d.length===3?[x,d[1],d[2]]:[x,d[1]];return c.run((0,l.createDotProductProgramInfoLoader)(c,d,w,g),T)},r=(c,d)=>{const g=c.kernelShape.slice();if(c.kernelShape.length===0)for(let w=2;w<d[1].dims.length;++w)g.push(d[1].dims[w]);const b=c.pads.slice();h.PoolConvUtil.adjustPadsBasedOnAutoPad(d[0].dims,c.strides,c.dilations,g,b,c.autoPad);const v=Object.assign({},c);return Object.assign(v,{kernelShape:g,pads:b,cacheKey:c.cacheKey}),v};u.parseConvAttributes=c=>{const d=c.attributes,g=(0,p.parseInternalActivationAttributes)(d),b=d.getString("auto_pad","NOTSET"),v=d.getInts("dilations",[1,1]),w=d.getInt("group",1),x=d.getInts("kernel_shape",[]),T=d.getInts("pads",[0,0,0,0]),S=d.getInts("strides",[1,1]);return(0,m.createAttributeWithCacheKey)(Object.assign({autoPad:b,dilations:v,group:w,kernelShape:x,pads:T,strides:S},g))};const o=(c,d)=>{if(!c||c.length!==2&&c.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(c[0].dims.length!==4||c[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(c[0].dims[1]!==c[1].dims[1]*d.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(c.length===3&&(c[2].dims.length!==1||c[1].dims[0]!==c[2].dims[0]))throw new Error("invalid bias");const g=c[0].dims.length-2;if(d.dilations.length!==g)throw new Error(`dilations should be ${g}D`);if(d.strides.length!==g)throw new Error(`strides should be ${g}D`);if(d.pads.length!==2*g)throw new Error(`pads should be ${2*g}D`);if(d.kernelShape.length!==0&&d.kernelShape.length!==c[1].dims.length-2)throw new Error("invalid kernel shape");if(c[0].type!=="float32"||c[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(c.length===3&&c[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},6742:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseDepthToSpaceAttributes=u.depthToSpace=void 0;const m=y(5707);u.depthToSpace=(f,s,l)=>{h(s);const p=l.blocksize,a=p*p,i=l.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],e=l.mode==="DCR"?[s[0].dims[0],p,p,s[0].dims[1]/a,s[0].dims[2],s[0].dims[3]]:[s[0].dims[0],s[0].dims[1]/a,p,p,s[0].dims[2],s[0].dims[3]],t=f.reshapeUnpacked(s[0],e),n={perm:i,cacheKey:`${i}`},[r]=(0,m.transpose)(f,[t],n),o=[s[0].dims[0],s[0].dims[1]/a,s[0].dims[2]*p,s[0].dims[3]*p];return[f.reshapeUnpacked(r,o)]},u.parseDepthToSpaceAttributes=f=>{const s=f.attributes.getInt("blocksize");if(s<1)throw new Error(`blocksize must be >= 1, but got : ${s} for DepthToSpace`);const l=f.attributes.getString("mode","DCR");if(l!=="DCR"&&l!=="CRD")throw new Error(`unrecognized mode: ${l} for DepthToSpace`);return{mode:l,blocksize:s}};const h=f=>{if(f.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${f.length}`);if(f[0].type==="string"||f[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createDotProductProgramInfoLoader=void 0;const m=y(7273),h=y(6757),f=y(5639),s=y(2150),l=y(1625);u.createDotProductProgramInfoLoader=(p,a,i,e)=>{const t=((n,r)=>({name:"ConvDotProduct",inputNames:n?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:n?[f.TextureType.unpacked,f.TextureType.packedLastDimension,f.TextureType.unpacked]:[f.TextureType.unpacked,f.TextureType.packedLastDimension],cacheKey:r.activationCacheKey}))(a.length>2,e);return Object.assign(Object.assign({},t),{get:()=>((n,r,o,c,d)=>{const g=o[0].dims,b=o[1].dims,v=[b[0],Math.ceil(g[1]*b[2]*b[3]/4)],w=(0,l.calculateIm2ColDims)(g,b,c),[x,T]=n.calculateTextureWidthAndHeight(v,f.TextureType.packedLastDimension),S=m.ShapeUtil.computeStrides(w),[_,A]=n.calculateTextureWidthAndHeight(w,f.TextureType.packedLastDimension),E=c.length,C=o.length<3?"0.0":"_B(b)",D=Math.ceil(g[1]*b[2]*b[3]/4),{activationFunction:$,applyActivation:L}=(0,s.getActivationSnippet)(d),P=(0,h.getGlsl)(n.session.backend.glContext.version),k=`
${$}
float process(int indices[${E}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${S[0]} + im2col[1] * ${S[1]} + im2col[2] * ${S[2]};
  int kernelOffset = indices[1] * ${v[1]};
  float value = ${C};
  for (int i = 0; i < ${D}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${_}, ${A});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${x}, ${T});
    value += dot(${P.texture2D}(Im2Col, im2colCoords), ${P.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${L}
  return value;
}`;return Object.assign(Object.assign({},r),{output:{dims:c,type:o[0].type,textureType:f.TextureType.unpacked},shaderSource:k})})(p,t,a,i,e)})}},4125:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseFlattenAttributes=u.flatten=void 0;const m=y(7273);u.flatten=(f,s,l)=>{h(s,l);const p=m.ShapeUtil.flattenShape(s[0].dims,l);return[f.reshapeUnpacked(s[0],p)]},u.parseFlattenAttributes=f=>f.attributes.getInt("axis",1);const h=(f,s)=>{if(!f||f.length!==1)throw new Error("Flatten requires 1 input.");const l=f[0].dims.length;if(l===0)throw new Error("scalar tensor is not supported.");if(s<-l||s>l)throw new Error("Invalid axis");if(f[0].type==="string")throw new Error("string tensor is not supported.")}},2150:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseInternalActivationAttributes=u.getActivationSnippet=void 0;const m=y(7273),h=y(9087);u.getActivationSnippet=function(f){let s;switch(f.activation){case"Relu":s=(0,h.glslRelu)();break;case"Sigmoid":s=(0,h.glslSigmoid)();break;case"Clip":s=(0,h.glslClip)(f.clipMin,f.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const l=s.name;return{activationFunction:s.body,applyActivation:`value = ${l}_(value);`}},u.parseInternalActivationAttributes=f=>{const s=f.getString("activation","");if(s==="Clip"){const[l,p]=f.getFloats("activation_params",[m.MIN_CLIP,m.MAX_CLIP]);return{activation:s,clipMax:p,clipMin:l,activationCacheKey:`${s}:${l},${p}`}}return{activation:s,activationCacheKey:s}}},6149:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseGatherAttributes=u.gather=void 0;const m=y(4910),h=y(6145),f=y(7273),s=y(5639);u.gather=(i,e,t)=>(a(e,t.axis),[i.run(p(i,e,t),e)]),u.parseGatherAttributes=i=>(0,m.createAttributeWithCacheKey)({axis:i.attributes.getInt("axis",0)});const l={name:"Gather",inputNames:["A","B"],inputTypes:[s.TextureType.unpacked,s.TextureType.unpacked]},p=(i,e,t)=>{const n=Object.assign(Object.assign({},l),{cacheHint:t.cacheKey});return Object.assign(Object.assign({},n),{get:()=>((r,o,c,d)=>{const g=c[0].dims.slice(),b=c[1].dims.slice(),v=new Array(g.length+b.length-1);d=f.ShapeUtil.normalizeAxis(d,g.length);const w=[];for(let T=0;T<v.length;T++)T<d?(v[T]=g[T],w.push(`inputIdx[${T}] = outputIdx[${T}];`)):T<d+b.length?(v[T]=b[T-d],w.push(`indexDataIdx[${T-d}] = outputIdx[${T}];`)):(v[T]=g[T-b.length+1],w.push(`inputIdx[${T-b.length+1}] = outputIdx[${T}];`));const x=`
      float process(int outputIdx[${v.length||1}]) {
        int inputIdx[${g.length}];
        int indexDataIdx[${b.length||1}];
        indexDataIdx[0] = 0;
        ${w.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${d}] = idx < 0 ? idx + ${g[d]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},o),{output:{dims:v,type:c[0].type,textureType:s.TextureType.unpacked},shaderSource:x})})(0,n,e,t.axis)})},a=(i,e)=>{if(!i||i.length!==2)throw new Error("Gather requires 2 inputs.");const t=i[0].dims.length;if(t<1)throw new Error("Invalid input shape.");if(e<-t||e>t-1)throw new Error("Invalid axis.");if(h.NUMBER_TYPES.indexOf(i[0].type)===-1)throw new Error("Invaid input type.");if(i[1].type!=="int32"&&i[1].type!=="int16")throw new Error("Invaid input type.")}},5378:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseGemmAttributesV11=u.parseGemmAttributesV7=u.gemm=void 0;const m=y(4910),h=y(7273),f=y(5639);u.gemm=(i,e,t)=>(a(e,t),[i.run(l(e,t),e)]);const s=(i,e)=>{const t=i.attributes.getInt("transA",0)!==0,n=i.attributes.getInt("transB",0)!==0,r=i.attributes.getFloat("alpha",1),o=i.attributes.getFloat("beta",1);return(0,m.createAttributeWithCacheKey)({transA:t,transB:n,alpha:r,beta:o,isOptionalC:e})};u.parseGemmAttributesV7=i=>s(i,!1),u.parseGemmAttributesV11=i=>s(i,!0);const l=(i,e)=>{const t={name:"Gemm",inputNames:i.length===3?["A","B","C"]:["A","B"],inputTypes:i.length===3?[f.TextureType.unpacked,f.TextureType.unpacked,f.TextureType.unpacked]:[f.TextureType.unpacked,f.TextureType.unpacked],key:e.cacheKey};return Object.assign(Object.assign({},t),{get:()=>p(t,i,e)})},p=(i,e,t)=>{const n=e[0].dims.slice(),r=e[1].dims.slice(),[o,c]=h.GemmUtil.getShapeOfGemmResult(n,t.transA,r,t.transB,e.length===3?e[2].dims:void 0),d=[o,c];if(!d)throw new Error("Can't use gemm on the given tensors");let g=n[n.length-1],b="";t.transA&&(g=n[0]),t.transA&&t.transB?b="value += _A_T(a) * _B_T(b);":t.transA&&!t.transB?b="value += _A_T(a) * _B(b);":!t.transA&&t.transB?b="value += _A(a) * _B_T(b);":t.transA||t.transB||(b="value += _A(a) * _B(b);");const v=d.length,w=`
      float process(int indices[${v}]) {
          int a[${v}];
          int b[${v}];
          ${e.length===3?`int c[${e[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${e.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${g}; ++k) {
              a[${v-1}] = k;
              b[${v-2}] = k;
              ${b}
          }

          value = value * alpha;
          ${e.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},i),{output:{dims:d,type:e[0].type,textureType:f.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:t.alpha},{name:"beta",type:"float",data:t.beta}],shaderSource:w})},a=(i,e)=>{if(!i)throw new Error("Input is missing");if(e.isOptionalC&&(i.length<2||i.length>3))throw new Error("Invaid input shape.");if(!e.isOptionalC&&i.length!==3)throw new Error("Gemm requires 3 inputs");if(i.length===3&&i[2].dims.length!==1&&i[2].dims.length!==2)throw new Error("Invalid input shape of C");if(i[0].type!=="float32"&&i[0].type!=="float64"||i[1].type!=="float32"&&i[1].type!=="float64"||i.length===3&&i[2].type!=="float32"&&i[2].type!=="float64")throw new Error("Invalid input type.");if(i[0].type!==i[1].type||i.length===3&&i[0].type!==i[2].type)throw new Error("Input types are mismatched")}},5950:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createPackedIm2ColProgramInfoLoader=void 0;const m=y(6757),h=y(5639),f=y(5614);u.createPackedIm2ColProgramInfoLoader=(s,l,p,a,i)=>{const e=(t=i.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[h.TextureType.packed],cacheHint:t});var t;return Object.assign(Object.assign({},e),{get:()=>((n,r,o,c,d,g)=>{const b=o.dims,v=c.dims,w=d.length,x=[v[1]*v[2]*v[3],d[2]*d[3]],T=v[2]*v[3],S=(0,f.unpackFromChannel)(),_=(0,m.getGlsl)(n.session.backend.glContext.version);let A="";for(let C=0;C<=1;C++)for(let D=0;D<=1;D++)A+=`
            blockIndex = rc.x + ${D};
            pos = rc.y + ${C};

            if(blockIndex < ${x[1]} && pos < ${x[0]}) {
              offsetY = int(blockIndex / (${d[w-1]})) * ${g.strides[0]} -
                ${g.pads[0]};
              d0 = offsetY + ${g.dilations[0]} * (imod(pos, ${T}) / ${v[2]});

              if(d0 < ${b[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${d[w-1]}) * ${g.strides[1]} -
                  ${g.pads[1]};
                d1 = offsetX + ${g.dilations[1]} * imod(imod(pos, ${T}), ${v[2]});

                if(d1 < ${b[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${T}.);
                    innerDims = vec2(d0, d1);
                    result[${2*C+D}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const E=`
      ${S}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${A}
          ${_.output} = result;
      }
            `;return Object.assign(Object.assign({},r),{output:{dims:x,type:o.type,textureType:h.TextureType.packed},shaderSource:E,hasMain:!0})})(s,e,l,p,a,i)})}},1625:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.calculateIm2ColDims=u.createIm2ColProgramInfoLoader=void 0;const m=y(5639);u.createIm2ColProgramInfoLoader=(h,f,s,l,p)=>{const a=(i=p.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[m.TextureType.unpacked],cacheHint:i});var i;return Object.assign(Object.assign({},a),{get:()=>((e,t,n,r,o,c)=>{const d=n.dims,g=r.dims,b=o.length,v=(0,u.calculateIm2ColDims)(d,g,o,4),w=`
        const int XC = ${d[1]};
        const int XH = ${d[2]};
        const int XW = ${d[3]};
        const int KH = ${c.kernelShape[0]};
        const int KW = ${c.kernelShape[1]};
        const int dilationH = ${c.dilations[0]};
        const int dilationW = ${c.dilations[1]};
        const int strideH = ${c.strides[0]};
        const int strideW = ${c.strides[1]};
        const int padH = ${c.pads[0]};
        const int padW = ${c.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${b}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${d.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},t),{output:{dims:v,type:n.type,textureType:m.TextureType.packedLastDimension},shaderSource:w})})(0,a,f,s,l,p)})},u.calculateIm2ColDims=(h,f,s,l=4)=>[s[0],s[2],s[3],Math.ceil(h[1]*f[2]*f[3]/l)]},6981:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseImageScalerAttributes=u.imageScaler=void 0;const m=y(4910),h=y(5639);u.imageScaler=(a,i,e)=>(p(i),[a.run(s(a,i,e),i)]),u.parseImageScalerAttributes=a=>{const i=a.attributes.getFloat("scale"),e=a.attributes.getFloats("bias");return(0,m.createAttributeWithCacheKey)({scale:i,bias:e})};const f={name:"ImageScaler",inputNames:["X"],inputTypes:[h.TextureType.unpacked]},s=(a,i,e)=>{const t=Object.assign(Object.assign({},f),{cacheHint:e.cacheKey});return Object.assign(Object.assign({},t),{get:()=>((n,r,o,c)=>{const d=o[0].dims.slice(),g=d.length,b=`
      ${l(c.bias.length)}
      float process(int indices[${g}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},r),{output:{dims:d,type:o[0].type,textureType:h.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:c.bias.length,data:c.bias},{name:"scale",type:"float",data:c.scale}],shaderSource:b})})(0,t,i,e)})},l=a=>{const i=[`float getBias(float bias[${a}], int channel) {`];for(let e=0;e<a;++e)e===0?i.push(`	if (channel == ${e}) { return bias[${e}]; }`):e===a-1?i.push(`	else { return bias[${e}]; }`):i.push(`	else if (channel == ${e}) { return bias[${e}]; }`);return i.push("	}"),i.join(`
`)},p=a=>{if(!a||a.length!==1)throw new Error("ImageScaler requires 1 input.");if(a[0].dims.length!==4)throw new Error("Invalid input shape.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.")}},7413:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseInstanceNormalizationAttributes=u.instanceNormalization=void 0;const m=y(6757),h=y(5639);u.instanceNormalization=(i,e,t)=>{a(e);const n=i.run(s(e[0]),e);return[i.run(p(i,e[0],t,n.dims),[e[0],n,e[1],e[2]])]},u.parseInstanceNormalizationAttributes=i=>i.attributes.getFloat("epsilon",1e-5);const f={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[h.TextureType.unpacked]},s=i=>Object.assign(Object.assign({},f),{get:()=>((e,t)=>{const n=t.dims.slice(),r=n[1],o=n[2]*n[3],c=[n[0],r],d=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${o});
        temp = 0.0;
        for(int a2=0; a2<${n[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${o});

        return v;
      }`;return Object.assign(Object.assign({},e),{output:{dims:c,type:t.type,textureType:h.TextureType.packedLastDimension},shaderSource:d})})(f,i)}),l={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[h.TextureType.unpacked,h.TextureType.packedLastDimension,h.TextureType.unpacked,h.TextureType.unpacked]},p=(i,e,t,n)=>{const r=Object.assign(Object.assign({},l),{cacheHint:`${t}`});return Object.assign(Object.assign({},r),{get:()=>((o,c,d,g,b)=>{const v=(0,m.getGlsl)(o.session.backend.glContext.version),[w,x]=o.calculateTextureWidthAndHeight(b,h.TextureType.packedLastDimension),[T,S]=[w/4,x],_=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${T}, ${S});
        return ${v.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},c),{output:{dims:d.dims,type:d.type,textureType:h.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:g}],shaderSource:_})})(i,r,e,t,n)})},a=i=>{if(!i||i.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const e=i[0],t=i[1],n=i[2];if(e.dims.length<3||t.dims.length!==1||n.dims.length!==1)throw new Error("Invalid input shape.");if(t.dims[0]!==e.dims[1]||n.dims[0]!==e.dims[1])throw new Error("Input shapes are mismatched.");if(e.type!=="float32"&&e.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||n.type!=="float32"&&n.type!=="float64")throw new Error("Invalid input type.");if(i[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},7006:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createLrnProgramInfoLoader=u.parseLrnAttributes=u.lrn=void 0;const m=y(4910),h=y(5639);u.lrn=(p,a,i)=>(l(a),[p.run(s(a,i),a)]),u.parseLrnAttributes=p=>{const a=p.attributes.getFloat("alpha",1e-4),i=p.attributes.getFloat("beta",.75),e=p.attributes.getFloat("bias",1),t=p.attributes.getInt("size");return(0,m.createAttributeWithCacheKey)({alpha:a,beta:i,bias:e,size:t})};const f={name:"LRN",inputNames:["X"],inputTypes:[h.TextureType.unpacked]};function s(p,a){return Object.assign(Object.assign({},f),{cacheHint:a.cacheKey,get:()=>function(i,e){const t=i[0].dims[1],n=i[0].dims.length,r=-Math.floor((e.size-1)/2),o=Math.ceil((e.size-1)/2),c=`float(${e.alpha}) / float(${e.size})`,d=`
    float process(int indices[${n}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${r}; i <= ${o}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${t}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${e.bias}) + ${c} * square_sum, float(${e.beta}));
    }`;return Object.assign(Object.assign({},f),{cacheHint:e.cacheKey,output:{dims:i[0].dims,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:d})}(p,a)})}u.createLrnProgramInfoLoader=s;const l=p=>{if(!p||p.length!==1)throw new Error("LRN requires 1 input.");if(p[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(p[0].type!=="float32")throw new Error("input should be float type")}},5632:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createPackedMatmulProgramInfoLoader=void 0;const m=y(7273),h=y(6757),f=y(5639),s=y(432),l=y(2150),p=y(8276);u.createPackedMatmulProgramInfoLoader=(a,i,e)=>{const t=(n=i.length>2,r=e.activationCacheKey,{name:"MatMul (packed)",inputNames:n?["A","B","Bias"]:["A","B"],inputTypes:n?[f.TextureType.packed,f.TextureType.packed,f.TextureType.packed]:[f.TextureType.packed,f.TextureType.packed],cacheHint:r});var n,r;return Object.assign(Object.assign({},t),{get:()=>((o,c,d,g)=>{const b=d.length>2,v=b?"value += getBiasForMatmul();":"",w=d[0].dims,x=d[1].dims,T=m.BroadcastUtil.calcShape(w,x,!0),S=!m.ShapeUtil.areEqual(d[0].dims,d[1].dims);if(!T)throw new Error("Can't use matmul on the given tensors");const _=w[w.length-1],A=Math.ceil(_/2),E=w.length,C=x.length,D=(0,h.getGlsl)(o.session.backend.glContext.version),$=(0,s.getCoordsDataType)(T.length),L=T.length,P=(0,s.getGlChannels)(),{activationFunction:k,applyActivation:V}=(0,l.getActivationSnippet)(g),z=b?`${(0,p.getBiasForMatmul)($,P,d[2].dims,T,!0)}`:"",J=S?`${function(Z,at,st,et){let dt=[],nt=[];const gt=st[0].dims,ct=st[1].dims,mt=gt.length,ut=ct.length,wt=et.length,Et=wt-mt,kt=wt-ut;dt=gt.map((_t,xt)=>`coords.${at[xt+Et]}`),dt[mt-1]="i*2",dt.join(", "),nt=ct.map((_t,xt)=>`coords.${at[xt+kt]}`),nt[ut-2]="i*2",nt.join(", ");const Ct=m.BroadcastUtil.getBroadcastDims(gt,et),Rt=m.BroadcastUtil.getBroadcastDims(ct,et),Mt=Ct.map(_t=>`coords.${at[_t+Et]} = 0;`).join(`
`),bt=Rt.map(_t=>`coords.${at[_t+kt]} = 0;`).join(`
`),It=`int lastDim = coords.${at[wt-1]};
  coords.${at[wt-1]} = coords.${at[wt-2]};
  coords.${at[wt-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${Z} coords = getOutputCoords();
  ${It}
  ${Mt}
  vec4 outputValue = getA(${dt});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${Z} coords = getOutputCoords();
  ${It}
  ${bt}
  vec4 outputValue = getB(${nt});
  return outputValue;
}`}($,P,d,T)}`:"",q=S?"getAAtOutCoordsMatmul(i)":`getA(${function(Z,at){let st="";for(let et=0;et<at-2;et++)st+=`rc.${Z[et]}, `;return st+=`rc.${Z[at-2]}, i*2`,st}(P,E)})`,tt=S?"getBAtOutCoordsMatmul(i)":`getB(${function(Z,at){let st="";for(let et=0;et<at-2;et++)st+=`rc.${Z[et]}, `;return st+=`i*2, rc.${Z[at-1]}`,st}(P,C)})`,rt=`
            ${J}
            ${z}
            ${k}
            void main() {
              ${S?"":`${$} rc =
          getOutputCoords(); int lastDim = rc.${P[L-1]}; rc.${P[L-1]} =
          rc.${P[L-2]}; rc.${P[L-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${A}; i++) {
                vec4 a = ${q};
                vec4 b = ${tt};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${v}
              ${V}
              ${D.output} = value;
            }`;return Object.assign(Object.assign({},c),{output:{dims:T,type:d[0].type,textureType:f.TextureType.packed},shaderSource:rt,hasMain:!0})})(a,t,i,e)})}},8276:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.getBiasForMatmul=u.createMatmulProgramInfoLoader=u.parseMatMulAttributes=u.matMul=void 0;const m=y(7273),h=y(5639),f=y(432),s=y(2150),l=y(5632);u.matMul=(t,n,r)=>(i(n),t.session.pack?[t.run((0,l.createPackedMatmulProgramInfoLoader)(t,n,r),n)]:[t.run(a(n,r),n)]),u.parseMatMulAttributes=t=>(0,s.parseInternalActivationAttributes)(t.attributes);const p=(t,n)=>({name:"MatMul",inputNames:t?["A","B","Bias"]:["A","B"],inputTypes:t?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],cacheHint:n});function a(t,n){const r=p(t.length>2,n.activationCacheKey);return Object.assign(Object.assign({},r),{get:()=>function(o,c,d){const g=c[0].dims,b=c[1].dims,v=m.BroadcastUtil.calcShape(g,b,!0);if(!v)throw new Error("Can't use matmul on the given tensors");const w=(0,f.getCoordsDataType)(v.length),x=(0,f.getGlChannels)(),{activationFunction:T,applyActivation:S}=(0,s.getActivationSnippet)(d),_=c.length>2,A=_?"value += getBiasForMatmul();":"",E=_?`${e(w,x,c[2].dims,v,!1)}`:"",C=v.length,D=g.length,$=b.length,L=`
    ${T}
    ${E}
    float process(int indices[${C}]) {
        int a[${D}];
        int b[${$}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${g[g.length-1]}; ++k) {
            a[${D-1}] = k;
            b[${$-2}] = k;
            value += _A(a) * _B(b);
        }
        ${A}
        ${S}
        return value;
    }`;return Object.assign(Object.assign({},o),{output:{dims:v,type:c[0].type,textureType:h.TextureType.unpacked},shaderSource:L})}(r,t,n)})}u.createMatmulProgramInfoLoader=a;const i=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.");if(t[0].type!=="float32"&&t[0].type!=="float64"||t[1].type!=="float32"&&t[1].type!=="float64")throw new Error("inputs should be float type");if(t[0].type!==t[1].type)throw new Error("inputs types should match")};function e(t,n,r,o,c){let d="";const g=r.length,b=o.length,v=b-g;d=b<2&&g>0?"coords":r.map((T,S)=>`coords.${n[S+v]}`).join(", ");const w=m.BroadcastUtil.getBroadcastDims(r,o).map(T=>`coords.${n[T+v]} = 0;`).join(`
`);let x="vec4(outputValue.xx, outputValue.yy)";return m.ShapeUtil.size(r)===1&&(x="vec4(outputValue.x)"),c?`
vec4 getBiasForMatmul() {
  ${t} coords = getOutputCoords();
  ${w}
  vec4 outputValue = getBias(${d});
  return ${x};
}`:`
float getBiasForMatmul() {
  ${t} coords = getOutputCoords();
  ${w}
  return getBias(coords.x);
}`}u.getBiasForMatmul=e},9:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createPackProgramInfoLoader=void 0;const m=y(6757),h=y(5639),f=y(432),s=y(5614),l={name:"pack",inputNames:["A"],inputTypes:[h.TextureType.unpackedReversed]};u.createPackProgramInfoLoader=(p,a)=>Object.assign(Object.assign({},l),{get:()=>((i,e)=>{const t=(0,m.getGlsl)(i.session.backend.glContext.version),n=e.dims,r=n.length,o=e.dims.length,c=(0,f.getCoordsDataType)(o),d=(0,s.getChannels)("rc",o),g=(b=o,v=d,w=n[n.length-2],x=n[n.length-1],b===0||b===1?"":`
    int r = ${v[b-2]};
    int c = ${v[b-1]};
    int rp1 = ${v[b-2]} + 1;
    int cp1 = ${v[b-1]} + 1;
    bool rEdge = rp1 >= ${x};
    bool cEdge = cp1 >= ${w};
    `);var b,v,w,x;let T;T=r===0?[1,1]:r===1?[n[0],1]:[n[o-1],n[o-2]];const S=function(E,C,D){if(E===0)return"false";if(E===1)return`rc > ${C[0]}`;let $="";for(let L=E-2;L<E;L++)$+=`${D[L]} >= ${C[L-E+2]}`,L<E-1&&($+="||");return $}(o,T,d),_=function(E,C){const D=E.length;if(D===0)return"getA(), 0, 0, 0";if(D===1)return`getA(rc),
            rc + 1 >= ${E[0]} ? 0. : getA(rc + 1),
            0, 0`;let $="";if(D>2)for(let L=0;L<D-2;++L)$+=`${C[L]},`;return`getA(${$}r, c),
          rEdge ? 0. : getA(${$}rp1, c),
          cEdge ? 0. : getA(${$}r, cp1),
          rEdge || cEdge ? 0. : getA(${$}rp1, cp1)`}(n,d),A=`
        void main() {
          ${c} rc = getOutputCoords();

          if(${S}) {
            ${t.output} = vec4(0);
          } else {
            ${g}

            ${t.output} = vec4(${_});
          }
        }
      `;return Object.assign(Object.assign({},l),{hasMain:!0,output:{dims:e.dims,type:e.type,textureType:h.TextureType.packed},shaderSource:A})})(p,a)})},5614:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.unpackFromChannel=u.getChannels=u.getVecChannels=void 0;const m=y(432);function h(f,s){return(0,m.getGlChannels)(s).map(l=>`${f}.${l}`)}u.getVecChannels=h,u.getChannels=function(f,s){return s===1?[f]:h(f,s)},u.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},5565:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parsePadAttributesV11=u.padV11=u.parsePadAttributesV2=u.padV2=void 0;const m=y(4910),h=y(7273),f=y(6757),s=y(5639),l={name:"Pad",inputNames:["A"],inputTypes:[s.TextureType.unpacked]};u.padV2=(c,d,g)=>(i(d),[c.run(Object.assign(Object.assign({},l),{cacheHint:g.cacheKey,get:()=>a(c,d[0],g)}),d)]),u.parsePadAttributesV2=c=>{const d=c.attributes.getString("mode","constant"),g=c.attributes.getFloat("value",0),b=c.attributes.getInts("pads");return(0,m.createAttributeWithCacheKey)({mode:d,value:g,pads:b})},u.padV11=(c,d,g)=>{e(d);const b=p(c,d,g);return(0,u.padV2)(c,[d[0]],b)},u.parsePadAttributesV11=c=>c.attributes.getString("mode","constant");const p=(c,d,g)=>{if(!c.session.isInitializer(d[1].dataId)||d.length>=3&&!c.session.isInitializer(d[2].dataId))throw new Error("dynamic pad attributes are not allowed");const b=Array.from(d[1].integerData),v=d.length>=3?d[2].floatData[0]:0;return(0,m.createAttributeWithCacheKey)({mode:g,pads:b,value:v})},a=(c,d,g)=>{const b=h.ShapeUtil.padShape(d.dims.slice(),g.pads),v=b.length,w=`
      ${t(c,d,g)}
      float process(int[${v}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[s.TextureType.unpacked],output:{dims:b,type:d.type,textureType:s.TextureType.unpacked},shaderSource:w}},i=c=>{if(!c||c.length!==1)throw new Error("Pad requires 1 input");if(c[0].type!=="float32"&&c[0].type!=="float64")throw new Error("Invalid input type.")},e=c=>{if(!c||c.length!==2&&c.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(c[1].type!=="int32")throw new Error("Invalid input type.");if(c.length>=3&&c[2].type==="string")throw new Error("Invalid input type.")},t=(c,d,g)=>{const b=(0,f.getGlsl)(c.session.backend.glContext.version),[v,w]=c.calculateTextureWidthAndHeight(d.dims,s.TextureType.unpacked),x=h.ShapeUtil.computeStrides(d.dims);switch(g.mode){case"constant":return n(b,d.dims,x,v,w,g.pads,g.value);case"reflect":return r(b,d.dims,x,v,w,g.pads);case"edge":return o(b,d.dims,x,v,w,g.pads);default:throw new Error("Invalid mode")}},n=(c,d,g,b,v,w,x)=>{const T=d.length;let S="";for(let _=T-1;_>=0;--_)S+=`
        k = m[${_}] - ${w[_]};
        if (k < 0)  return constant;
        if (k >= ${d[_]}) return constant;
        offset += k * ${g[_]};
        `;return`
      float padA(int m[${T}]) {
        const float constant = float(${x});
        int offset = 0;
        int k = 0;
        ${S}
        vec2 coords = offsetToCoords(offset, ${b}, ${v});
        float value = getColorAsFloat(${c.texture2D}(A, coords));
        return value;
      }
      `},r=(c,d,g,b,v,w)=>{const x=d.length;let T="";for(let S=x-1;S>=0;--S)T+=`
        k = m[${S}] - ${w[S]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(d[S]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${d[S]}) { k = _2n_1 - k; }
        }
        offset += k * ${g[S]};
        `;return`
      float padA(int m[${x}]) {
        int offset = 0;
        int k = 0;
        ${T}
        vec2 coords = offsetToCoords(offset, ${b}, ${v});
        float value = getColorAsFloat(${c.texture2D}(A, coords));
        return value;
      }
      `},o=(c,d,g,b,v,w)=>{const x=d.length;let T="";for(let S=x-1;S>=0;--S)T+=`
        k = m[${S}] - ${w[S]};
        if (k < 0)  k = 0;
        if (k >= ${d[S]}) k = ${d[S]-1};
        offset += k * ${g[S]};
      `;return`
      float padA(int m[${x}]) {
        int offset = 0;
        int k = 0;
        ${T}
        vec2 coords = offsetToCoords(offset, ${b}, ${v});
        float value = getColorAsFloat(${c.texture2D}(A, coords));
        return value;
      }
      `}},2834:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.globalMaxPool=u.parseMaxPoolAttributes=u.maxPool=u.parseGlobalAveragePoolAttributes=u.globalAveragePool=u.parseAveragePoolAttributes=u.averagePool=void 0;const m=y(4910),h=y(7273),f=y(5639);u.averagePool=(o,c,d)=>{e(c);const g={name:"AveragePool",inputNames:["X"],inputTypes:[f.TextureType.unpacked],cacheHint:d.cacheKey};return[o.run(Object.assign(Object.assign({},g),{get:()=>s(c,g,!1,d)}),c)]},u.parseAveragePoolAttributes=o=>{const c=o.attributes.getString("auto_pad","NOTSET"),d=o.attributes.getInt("ceil_mode",0),g=o.attributes.getInt("count_include_pad",0)!==0,b=o.attributes.getInts("kernel_shape"),v=o.attributes.getInts("strides",[]),w=o.attributes.getInts("pads",[]);if(d!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,m.createAttributeWithCacheKey)({autoPad:c,ceilMode:d,countIncludePad:g,kernelShape:b,strides:v,pads:w})};const s=(o,c,d,g)=>{const[b,v]=p(o,g,d),w=h.ShapeUtil.size(b.kernelShape);let x="";b.countIncludePad?x+=`value /= float(${w});`:x+=`value /= float(${w} - pad);`;const T=`
        ${t(o[0].dims,b,"value += _X(x);",x,"0.0")}
      `;return Object.assign(Object.assign({},c),{output:{dims:v,type:o[0].type,textureType:f.TextureType.unpacked},shaderSource:T})};u.globalAveragePool=(o,c,d)=>{e(c);const g={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[f.TextureType.unpacked],cacheHint:`${d.countIncludePad}`};return[o.run(Object.assign(Object.assign({},g),{get:()=>s(c,g,!0,d)}),c)]},u.parseGlobalAveragePoolAttributes=o=>{const c=o.attributes.getInt("count_include_pad",0)!==0;return(0,m.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:c,kernelShape:[],strides:[],pads:[]})},u.maxPool=(o,c,d)=>{e(c);const g={name:"MaxPool",inputNames:["X"],inputTypes:[f.TextureType.unpacked],cacheHint:d.cacheKey};return[o.run(Object.assign(Object.assign({},g),{get:()=>l(c,g,!1,d)}),c)]},u.parseMaxPoolAttributes=o=>{const c=o.attributes.getString("auto_pad","NOTSET"),d=o.attributes.getInt("ceil_mode",0),g=o.attributes.getInts("kernel_shape"),b=o.attributes.getInts("strides",[]),v=o.attributes.getInts("pads",[]),w=o.attributes.getInt("storage_order",0),x=o.attributes.getInts("dilations",[]);if(w!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(d!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,m.createAttributeWithCacheKey)({autoPad:c,ceilMode:d,countIncludePad:!1,kernelShape:g,strides:b,pads:v,storageOrder:w,dilations:x})};const l=(o,c,d,g)=>{const[b,v]=p(o,g,d),w=`
      ${t(o[0].dims,b,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},c),{output:{dims:v,type:o[0].type,textureType:f.TextureType.unpacked},shaderSource:w})},p=(o,c,d)=>{const g=o[0].dims.slice(),b=Object.hasOwnProperty.call(c,"dilations"),v=c.kernelShape.slice(),w=c.strides.slice(),x=b?c.dilations.slice():[],T=c.pads.slice();h.PoolConvUtil.adjustPoolAttributes(d,g,v,w,x,T);const S=h.PoolConvUtil.computePoolOutputShape(d,g,w,x,v,T,c.autoPad),_=Object.assign({},c);return b?Object.assign(_,{kernelShape:v,strides:w,pads:T,dilations:x,cacheKey:c.cacheKey}):Object.assign(_,{kernelShape:v,strides:w,pads:T,cacheKey:c.cacheKey}),[_,S]},a={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},i={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[f.TextureType.unpacked]};u.globalMaxPool=(o,c)=>(e(c),[o.run(Object.assign(Object.assign({},i),{get:()=>l(c,i,!0,a)}),c)]);const e=o=>{if(!o||o.length!==1)throw new Error("Pool ops requires 1 input.");if(o[0].type!=="float32"&&o[0].type!=="float64")throw new Error("Invalid input type.")},t=(o,c,d,g,b)=>{const v=o.length;if(c.kernelShape.length<=2){const w=c.kernelShape[c.kernelShape.length-1],x=c.strides[c.strides.length-1],T=c.pads[c.pads.length/2-1],S=c.pads[c.pads.length-1],_=o[v-1];let A="",E="",C="";if(A=T+S!==0?`
          for (int i = 0; i < ${w}; i++) {
            x[${v} - 1] = indices[${v} - 1] * ${x} - ${T} + i;
            if (x[${v} - 1] < 0 || x[${v} - 1] >= ${_}) {
              pad++;
              continue;
            }
            ${d}
          }`:`
          for (int i = 0; i < ${w}; i++) {
            x[${v} - 1] = indices[${v} - 1] * ${x} - ${T} + i;
            ${d}
          }`,c.kernelShape.length===2){const D=c.kernelShape[c.kernelShape.length-2],$=c.strides[c.strides.length-2],L=c.pads[c.pads.length/2-2],P=c.pads[c.pads.length-2],k=o[v-2];E=L+P!==0?`
            for (int j = 0; j < ${D}; j++) {
              x[${v} - 2] = indices[${v} - 2] * ${$} - ${L} + j;
              if (x[${v} - 2] < 0 || x[${v} - 2] >= ${k}) {
                pad+= ${w};
                continue;
              }
          `:`
            for (int j = 0; j < ${D}; j++) {
              x[${v} - 2] = indices[${v} - 2] * ${$} - ${L} + j;
            `,C=`
          }
        `}return`
        float process(int indices[${v}]) {
          int x[${v}];
          copyVec(indices, x);

          float value = ${b};
          int pad = 0;
          ${E}
          ${A}
          ${C}
          ${g}
          return value;
        }
      `}{const w=h.ShapeUtil.size(c.kernelShape),x=h.ShapeUtil.computeStrides(c.kernelShape),T=x.length,S=c.pads.length,_=r(T),A=n(o,"inputDims"),E=n(c.pads,"pads"),C=n(x,"kernelStrides"),D=n(c.strides,"strides");let $="";return $=c.pads.reduce((L,P)=>L+P)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${d}
          }`:`
          }
          ${d}
        `,`
        ${_}
        float process(int indices[${v}]) {
          int x[${v}];
          copyVec(indices, x);
          int offset[${T}];
          int pads[${S}];
          int inputDims[${v}];
          int kernelStrides[${T}];
          int strides[${T}];
          ${E}
          ${A}
          ${D}
          ${C}

          float value = ${b};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${w}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${v} - ${T}; j < ${v}; j++) {
              x[j] = indices[j] * strides[j - ${v} + ${T}]
                + offset[j - ${v} + ${T}] - pads[j - 2];
              ${$}
          }
          ${g}

          return value;
        }
      `}},n=(o,c)=>{let d="";for(let g=0;g<o.length;g++)d+=`
      ${c}[${g}] = ${o[g]};
    `;return d},r=o=>`
  void offsetToIndices(int offset, int[${o}] strides, out int[${o}] indices) {
    if (${o} == 0) {
      return;
    }
    for (int i = 0; i < ${o} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${o} - 1] = offset;
  }`},1010:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.reduceLogSumSquare=u.reduceLogSum=u.reduceProd=u.reduceMin=u.reduceMax=u.reduceMean=u.reduceSum=u.parseReduceAttributes=void 0;const m=y(4910),h=y(6145),f=y(7273),s=y(5639),l=(i,e,t,n,r)=>{a(e);const o={name:n,inputNames:["A"],inputTypes:[s.TextureType.unpacked]};return[i.run(Object.assign(Object.assign({},o),{cacheHint:t.cacheKey,get:()=>p(i,e,t,n,r,o)}),e)]};u.parseReduceAttributes=i=>{const e=i.attributes.getInts("axes",[]),t=i.attributes.getInt("keepdims",1)===1;return(0,m.createAttributeWithCacheKey)({axes:e,keepDims:t})};const p=(i,e,t,n,r,o)=>{const c=[],d=e[0].dims.length||1,g=[],b=f.ShapeUtil.normalizeAxes(t.axes,e[0].dims.length),v=r(e,b);let w=v[1];for(let T=0;T<e[0].dims.length;T++)b.indexOf(T)>=0||b.length===0?(t.keepDims&&c.push(1),w=`
          for(int j${T} = 0; j${T} < ${e[0].dims[T]}; j${T}++) {
            inputIdx[${T}] = j${T};
            ${w}
          }`):(g.push(`inputIdx[${T}] = outputIdx[${c.length}];`),c.push(e[0].dims[T]));const x=`
      float process(int outputIdx[${c.length||1}]) {
        float value;                 // final result
        int inputIdx[${d}];      // addressing input data
        ${g.join(`
`)}
        ${v[0]}       // init ops for reduce max/min
        ${w}
        ${v[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},o),{output:{dims:c,type:e[0].type,textureType:s.TextureType.unpacked},shaderSource:x})},a=i=>{if(!i||i.length!==1)throw new Error("Reduce op requires 1 input.");if(h.NUMBER_TYPES.indexOf(i[0].type)===-1)throw new Error("Invalid input type.")};u.reduceSum=(i,e,t)=>l(i,e,t,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),u.reduceMean=(i,e,t)=>l(i,e,t,"ReduceMean",(n,r)=>{let o=1;for(let c=0;c<n[0].dims.length;c++)(r.indexOf(c)>=0||r.length===0)&&(o*=n[0].dims[c]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${o}.;`]}),u.reduceMax=(i,e,t)=>l(i,e,t,"ReduceMax",(n,r)=>{const o=[];for(let c=0;c<n[0].dims.length;c++)(r.indexOf(c)>=0||r.length===0)&&o.push(`inputIdx[${c}] = 0;`);return[`${o.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),u.reduceMin=(i,e,t)=>l(i,e,t,"ReduceMin",(n,r)=>{const o=[];for(let c=0;c<n[0].dims.length;c++)(r.indexOf(c)>=0||r.length===0)&&o.push(`inputIdx[${c}] = 0;`);return[`${o.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),u.reduceProd=(i,e,t)=>l(i,e,t,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),u.reduceLogSum=(i,e,t)=>l(i,e,t,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),u.reduceLogSumSquare=(i,e,t)=>l(i,e,t,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7379:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.isReshapeCheap=u.processDims3D=u.createPackedReshape3DProgramInfoLoader=void 0;const m=y(7273),h=y(6757),f=y(5639),s=y(5614);u.createPackedReshape3DProgramInfoLoader=(l,p,a)=>{const i=(e=>({name:"Reshape (packed)",inputTypes:[f.TextureType.packed],inputNames:["A"],cacheHint:`${e}`}))(a);return Object.assign(Object.assign({},i),{get:()=>((e,t,n,r)=>{const o=t.dims,c=r;let d="";for(let v=0;v<4;v++){let w="";switch(v){case 0:w="outputCoords = rc;";break;case 1:w="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:w="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:w="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}d+=`
        ${w}
        ${v>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${v}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${v>0?"}":""}
      `}const g=(0,h.getGlsl)(e.session.backend.glContext.version),b=`
      ${function(v){const w=m.ShapeUtil.computeStrides(v),x=["b","r","c"],T="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${w.map((S,_)=>`int ${x[_]} = ${T} / ${S}; ${_===w.length-1?`int ${x[_+1]} = ${T} - ${x[_]} * ${S}`:`index -= ${x[_]} * ${S}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(o)}
      ${function(v){const w=m.ShapeUtil.computeStrides(v);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${w[0]} + coords.z * ${w[1]} + coords.y;
  }
`}(c)}
      ${(0,s.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${c[2]};
        int cols = ${c[1]};

        ${d}
        ${g.output} = result;
      }
    `;return Object.assign(Object.assign({},n),{output:{dims:c,type:t.type,textureType:f.TextureType.packed},shaderSource:b,hasMain:!0})})(l,p,i,a)})},u.processDims3D=function(l){if(l.length===0)return[1,1,1];let p=1;for(let a=0;a<l.length-2;++a)p*=l[a];return[p,l.length>1?l[l.length-2]:1,l[l.length-1]]},u.isReshapeCheap=function(l,p){let a=!1;return a=l.length===0||p.length===0||(l.length<2||p.length<2?l[l.length-1]===p[p.length-1]:l[l.length-1]===p[p.length-1]&&l[l.length-2]===p[p.length-2]),a}},8126:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.reshape=void 0;const m=y(7273);u.reshape=(h,f)=>{const s=m.ShapeUtil.calculateReshapedDims(f[0].dims,f[1].integerData);return h.session.pack?[h.reshapePacked(f[0],s)]:[h.reshapeUnpacked(f[0],s)]}},2801:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseResizeAttributesV11=u.parseResizeAttributesV10=u.resize=void 0;const m=y(6757),h=y(5639),f=y(432),s=y(5614),l=y(3980),p={name:"Resize",inputNames:["A"],inputTypes:[h.TextureType.packed]};u.resize=(n,r,o)=>((0,l.validateInputs)(r,o),[n.run(Object.assign(Object.assign({},p),{cacheHint:o.cacheKey,get:()=>a(n,r,o)}),r)]),u.parseResizeAttributesV10=n=>(0,l.parseUpsampleAttributes)(n,10),u.parseResizeAttributesV11=n=>(0,l.parseUpsampleAttributes)(n,11);const a=(n,r,o)=>{const c=(0,m.getGlsl)(n.session.backend.glContext.version),[d,g]=i(r,o);if(d.every($=>$===1)&&o.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},p),{output:{dims:g,type:r[0].type,textureType:h.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${c.texture2D}(X, TexCoords);
                    ${c.output} = v;
                }`});const b=g.length;if(b<2)throw new Error(`output dimension should be at least 2, but got ${b}`);const v=g[b-2],w=g[b-1],x=r[0].dims;if(b!==x.length)throw new Error(`output dimension should match input ${x.length}, but got ${b}`);const T=x[b-2],S=x[b-1],_=d[b-2],A=d[b-1];let E="";if(o.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${o.mode}'`);switch(o.coordinateTransformMode){case"asymmetric":E=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":E=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":E=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${w}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${v}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${w}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${v}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":E=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${w}.0 - 1.0, ${v}.0 - 1.0, ${w}.0 - 1.0,
                            ${v}.0 - 1.0);
                        vec4 original = vec4(${S}.0 - 1.0, ${T}.0 - 1.0, ${S}.0 - 1.0,
                            ${T}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${o.coordinateTransformMode}'`)}const C=(0,f.getCoordsDataType)(b),D=`
            const vec2 inputWH = vec2(${T}.0, ${S}.0);
            const vec4 scaleWHWH = vec4(float(${_}), float(${A}), float(${_}), float(${A}));
            ${(0,s.unpackFromChannel)()}
            ${E}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${C} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${v-1};
                bool hasNextCol = rc.z < ${w-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${c.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},p),{output:{dims:g,type:r[0].type,textureType:h.TextureType.packed},hasMain:!0,shaderSource:D})},i=(n,r)=>{const o=n[0].dims;let c,d=r.scales;if(d.length===0){const b=n[r.scalesInputIdx];if(b&&b.size!==0){if(n[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");d=e(b,r.mode,r.isResize)}else{const v=n[r.sizesInputIdx];if(!v||v.size===0)throw new Error("Either scales or sizes MUST be provided as input.");c=Array.from(v.integerData),d=t(c,o,r.mode,r.isResize)}}else if(n[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const g=c||o.map((b,v)=>Math.floor(b*d[v]));return[d,g]},e=(n,r,o)=>{const c=Array.from(n.floatData);return(0,l.scalesValidation)(c,r,o),c},t=(n,r,o,c)=>{const d=r.length,g=new Array(d);for(let b=0,v=d;b<v;b++)if(r[b]===0){if(n[b]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");g[b]=1}else g[b]=n[b]/r[b];return(0,l.scalesValidation)(g,o,c),g}},565:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.shape=void 0;const m=y(9240);u.shape=(f,s)=>(h(s),[new m.Tensor([s[0].dims.length],"int32",void 0,void 0,new Int32Array(s[0].dims))]);const h=f=>{if(!f||f.length!==1)throw new Error("Shape requires 1 input.")}},2444:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.sliceV10=u.parseSliceAttributes=u.slice=void 0;const m=y(4910),h=y(6145),f=y(7273),s=y(5639),l={name:"Slice",inputNames:["A"],inputTypes:[s.TextureType.unpacked]};u.slice=(t,n,r)=>(a(n),[t.run(Object.assign(Object.assign({},l),{cacheHint:r.cacheKey,get:()=>p(t,n[0],r)}),n)]),u.parseSliceAttributes=t=>{const n=t.attributes.getInts("starts"),r=t.attributes.getInts("ends"),o=t.attributes.getInts("axes",[]);return(0,m.createAttributeWithCacheKey)({starts:n,ends:r,axes:o})};const p=(t,n,r)=>{const o=r.axes.length===0?n.dims.slice(0).map((x,T)=>T):r.axes,c=f.ShapeUtil.normalizeAxes(o,n.dims.length),d=r.starts.map((x,T)=>x>n.dims[c[T]]-1?n.dims[c[T]]:f.ShapeUtil.normalizeAxis(x,n.dims[c[T]])),g=r.ends.map((x,T)=>x>n.dims[c[T]]-1?n.dims[c[T]]:f.ShapeUtil.normalizeAxis(x,n.dims[c[T]])),b=n.dims.slice(),v=[];for(let x=0;x<c.length;x++)b[c[x]]=g[x]-d[x],d[x]>0&&v.push(`outputIdx[${c[x]}] += ${d[x]};`);const w=`
      float process(int outputIdx[${b.length}]) {
        ${v.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},l),{output:{dims:b,type:n.type,textureType:s.TextureType.unpacked},shaderSource:w})},a=t=>{if(!t||t.length!==1)throw new Error("Slice requires 1 input.");if(h.NUMBER_TYPES.indexOf(t[0].type)===-1)throw new Error("Invalid input type.")};u.sliceV10=(t,n)=>{e(n);const r=i(t,n);return[t.run(Object.assign(Object.assign({},l),{cacheHint:r.cacheKey,get:()=>p(t,n[0],r)}),[n[0]])]};const i=(t,n)=>{if(!t.session.isInitializer(n[1].dataId)||!t.session.isInitializer(n[2].dataId)||n.length>=4&&!t.session.isInitializer(n[3].dataId)||n.length>=5&&!t.session.isInitializer(n[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(n.length>=5&&n[4].integerData.some(d=>d!==1))throw new Error("currently non-1 steps is not supported for Slice");const r=Array.from(n[1].integerData),o=Array.from(n[2].integerData),c=n.length>=4?Array.from(n[3].integerData):[];return{starts:r,ends:o,axes:c,cacheKey:`${c};${r};${o}`}},e=t=>{if(!t||t.length<3||t.length>5)throw new Error("Invalid input number.");if(t[1].type!=="int32"||t[1].dims.length!==1)throw new Error("Invalid input type.");if(t[2].type!=="int32"||t[2].dims.length!==1)throw new Error("Invalid input type.");if(t.length>=4&&(t[3].type!=="int32"||t[3].dims.length!==1))throw new Error("Invalid input type.");if(t.length>=5&&(t[4].type!=="int32"||t[4].dims.length!==1))throw new Error("Invalid input type.")}},815:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.softmaxV13=u.parseSoftmaxAttributesV13=u.parseSoftmaxAttributes=u.softmax=void 0;const m=y(4910),h=y(7273),f=y(6757),s=y(5639),l=y(5707),p={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[s.TextureType.unpacked]},a={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[s.TextureType.unpacked,s.TextureType.unpacked]},i={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[s.TextureType.unpacked,s.TextureType.unpacked,s.TextureType.unpacked]};u.softmax=(c,d,g)=>{o(d);const b=d[0].dims.slice(),v=h.ShapeUtil.normalizeAxis(g.axis,b.length),w=h.ShapeUtil.sizeToDimension(b,v),x=h.ShapeUtil.sizeFromDimension(b,v);return e(c,d,g,w,x)},u.parseSoftmaxAttributes=c=>(0,m.createAttributeWithCacheKey)({axis:c.attributes.getInt("axis",1)}),u.parseSoftmaxAttributesV13=c=>(0,m.createAttributeWithCacheKey)({axis:c.attributes.getInt("axis",-1)}),u.softmaxV13=(c,d,g)=>{o(d);const b=d[0].dims.slice(),v=h.ShapeUtil.normalizeAxis(g.axis,b.length),w=b.length,x=v!==w-1,T=[];let S,_=[],A=[];x&&(_=Array.from({length:w}).map(($,L)=>L),_[v]=w-1,_[w-1]=v,_.map($=>T.push(b[$])),S=(0,m.createAttributeWithCacheKey)({perm:_}),A=(0,l.transpose)(c,d,S));const E=x?h.ShapeUtil.sizeToDimension(T,w-1):h.ShapeUtil.sizeToDimension(b,w-1),C=x?h.ShapeUtil.sizeFromDimension(T,w-1):h.ShapeUtil.sizeFromDimension(b,w-1),D=e(c,x?A:d,g,E,C);return x?(0,l.transpose)(c,D,S):D};const e=(c,d,g,b,v)=>{const w=t(c,d[0],b,v,[b]),x=c.run(Object.assign(Object.assign({},p),{cacheHint:g.cacheKey,get:()=>w}),d),T=n(c,d[0],b,v,w.output.dims,[b]),S=c.run(Object.assign(Object.assign({},a),{cacheHint:g.cacheKey,get:()=>T}),[d[0],x]),_=r(c,d[0],b,v,w.output.dims,T.output.dims);return[c.run(Object.assign(Object.assign({},i),{cacheHint:g.cacheKey,get:()=>_}),[d[0],x,S])]},t=(c,d,g,b,v)=>{const[w,x]=c.calculateTextureWidthAndHeight(d.dims,s.TextureType.unpacked),T=v.length;if(g<1||b<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(v.length!==1)throw new Error("Dimensionality of the output should be 1");if(v[0]!==g)throw new Error("Shape of the output should be equal to logical row count");const S=(0,f.getGlsl)(c.session.backend.glContext.version),_=`
      float process(int[${T}] indices) {
        int logical_row_start_offset = indices[0] * ${b};

        float max = getColorAsFloat(${S.texture2D}(A, offsetToCoords(logical_row_start_offset, ${w},
        ${x} )));
        for(int i=1; i<${b}; ++i)
        {
          float current = getColorAsFloat(${S.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${w}, ${x})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},p),{output:{dims:v,type:d.type,textureType:s.TextureType.unpacked},shaderSource:_})},n=(c,d,g,b,v,w)=>{const[x,T]=c.calculateTextureWidthAndHeight(d.dims,s.TextureType.unpacked),S=w.length;if(g<1||b<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(w.length!==1)throw new Error("Dimensionality of the output should be 1");if(w[0]!==g)throw new Error("Shape of the output should be equal to logical row count");if(v.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(v[0]!==g)throw new Error("Shape of the intermediate results should be equal to logical row count");const _=`
      float process(int[${S}] indices) {
        int logical_row_start_offset = indices[0] * ${b};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${b}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,f.getGlsl)(c.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${x}, ${T}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},a),{output:{dims:w,type:d.type,textureType:s.TextureType.unpacked},shaderSource:_})},r=(c,d,g,b,v,w)=>{const[x,T]=c.calculateTextureWidthAndHeight(d.dims,s.TextureType.unpacked),S=d.dims.length;if(g<1||b<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(v.length!==1||w.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(v[0]!==g||w[0]!==g)throw new Error("Shape of the intermediate results should be equal to logical row count");const _=`
      float process(int[${S}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${x}, ${T});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${b};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},i),{output:{dims:d.dims,type:d.type,textureType:s.TextureType.unpacked},shaderSource:_})},o=c=>{if(!c||c.length!==1)throw new Error("Softmax requires 1 input.");if(c[0].type!=="float32"&&c[0].type!=="float64")throw new Error("Invalid input type")}},564:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseSplitAttributes=u.split=void 0;const m=y(4910),h=y(7273),f=y(5639),s={name:"Split",inputNames:["A"],inputTypes:[f.TextureType.unpacked]};u.split=(i,e,t)=>{a(e);const n=h.ShapeUtil.normalizeAxis(t.axis,e[0].dims.length),r=l(i,e,n,t),o=[];for(let c=0;c<r;++c)o.push(i.run(Object.assign(Object.assign({},s),{cacheHint:`${t.cacheKey};${c}`,get:()=>p(i,e[0],t,n,c)}),e));return o},u.parseSplitAttributes=i=>{const e=i.attributes.getInt("axis",0),t=i.attributes.getInts("split",[]),n=i.outputs.length;return(0,m.createAttributeWithCacheKey)({axis:e,split:t,numOutputs:n})};const l=(i,e,t,n)=>{const[,r]=h.SplitUtil.splitShape(e[0].dims,t,n.split,n.numOutputs);return r.length},p=(i,e,t,n,r)=>{const[o,c]=h.SplitUtil.splitShape(e.dims,n,t.split,t.numOutputs),d=c[r],g=o[r],b=`
      float process(int indices[${g.length}]) {
        indices[${n}] += ${d};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},s),{cacheHint:`${t.cacheKey}:${r}`,output:{dims:g,type:e.type,textureType:f.TextureType.unpacked},shaderSource:b})},a=i=>{if(!i||i.length!==1)throw new Error("Split requires one input.");if(i[0].type!=="int8"&&i[0].type!=="uint8"&&i[0].type!=="int16"&&i[0].type!=="uint16"&&i[0].type!=="int32"&&i[0].type!=="uint32"&&i[0].type!=="float32"&&i[0].type!=="float64"&&i[0].type!=="bool")throw new Error("Invalid input type.")}},5416:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseSqueezeAttributes=u.squeezeV13=u.squeeze=void 0;const m=y(7273);u.squeeze=(s,l,p)=>{h(l);const a=m.ShapeUtil.squeezeShape(l[0].dims,p);return[s.reshapeUnpacked(l[0],a)]},u.squeezeV13=(s,l)=>(f(l),(0,u.squeeze)(s,[l[0]],Array.from(l[1].integerData))),u.parseSqueezeAttributes=s=>s.attributes.getInts("axes");const h=s=>{if(!s||s.length!==1)throw new Error("Squeeze requires 1 input.");if(s[0].type==="string")throw new Error("invalid input tensor types.")},f=s=>{if(!s||s.length!==2)throw new Error("Squeeze requires 2 inputs.");if(s[1].type!=="int32")throw new Error("Invalid input type.")}},1240:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.sum=void 0;const m=y(6757),h=y(5639);u.sum=(l,p)=>{s(p);const a={name:"Sum",inputNames:p.map((i,e)=>`X${e}`),inputTypes:new Array(p.length).fill(h.TextureType.unpacked)};return[l.run(Object.assign(Object.assign({},a),{get:()=>f(l,p,a)}),p)]};const f=(l,p,a)=>{const i=(0,m.getGlsl)(l.session.backend.glContext.version),e=p[0].dims.slice(),t=`
      void main() {
        vec4 result = ${p.map((n,r)=>`${i.texture2D}(X${r},TexCoords)`).join(" + ")};
        ${i.output} = result;
      }
    `;return Object.assign(Object.assign({},a),{output:{dims:e,type:p[0].type,textureType:h.TextureType.unpacked},hasMain:!0,shaderSource:t})},s=l=>{if(!l||l.length===0)throw new Error("Sum requires inputs.");const p=l[0].dims.length;for(let a=1;a<l.length;a++){if(p!==l[a].dims.length)throw new Error("Input shapes are mismatched.");for(let i=0;i<p;i++)if(l[0].dims[i]!==l[a].dims[i])throw new Error("Input shapes are not matched.")}if(l[0].type!=="float32"&&l[0].type!=="float64")throw new Error("Invalid input type.");for(let a=1;a<l.length;a++)if(l[0].type!==l[a].type)throw new Error("Input types are not matched.")}},5944:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.tile=void 0;const m=y(6145),h=y(5639);u.tile=(l,p)=>{s(p);const a={name:"Tile",inputNames:["A"],inputTypes:[h.TextureType.unpacked]};return[l.run(Object.assign(Object.assign({},a),{get:()=>f(l,p,a)}),p)]};const f=(l,p,a)=>{const i=p[0].dims.slice(),e=new Array(i.length),t=[];for(let o=0;o<i.length;o++)e[o]=i[o]*p[1].numberData[o],t.push(`inputIdx[${o}] = int(mod(float(outputIdx[${o}]), ${i[o]}.));`);const n=e.length,r=`
      float process(int outputIdx[${n}]) {
        int inputIdx[${n}];
        ${t.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},a),{output:{dims:e,type:p[0].type,textureType:h.TextureType.unpacked},shaderSource:r})},s=l=>{if(!l||l.length!==2)throw new Error("Tile requires 2 input.");if(l[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(l[1].dims[0]!==l[0].dims.length)throw new Error("Invalid input shape.");if(m.NUMBER_TYPES.indexOf(l[0].type)===-1)throw new Error("Invalid input type.");if(l[1].type!=="int32"&&l[1].type!=="int16")throw new Error("Invalid repeat type.")}},5707:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseTransposeAttributes=u.transpose=void 0;const m=y(4910),h=y(7273),f=y(5639),s={name:"Transpose",inputNames:["A"],inputTypes:[f.TextureType.unpacked]};u.transpose=(t,n,r)=>(e(n),[t.run(Object.assign(Object.assign({},s),{cacheHint:r.cacheKey,get:()=>l(t,n[0],r.perm)}),n)]),u.parseTransposeAttributes=t=>(0,m.createAttributeWithCacheKey)({perm:t.attributes.getInts("perm",[])});const l=(t,n,r)=>{const o=n.dims;r=p(o,r);const c=a(o,r),d=o.length,g=`
      ${i("perm",r,d)}
      float process(int indices[${d}]) {
        int a[${d}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},s),{output:{dims:c,type:n.type,textureType:f.TextureType.unpacked},shaderSource:g})},p=(t,n)=>(n&&n.length!==t.length&&(n=[...t.keys()].reverse()),n),a=(t,n)=>(n=p(t,n),h.ShapeUtil.sortBasedOnPerm(t,n)),i=(t,n,r)=>{const o=[];o.push(`void ${t}(out int a[${r}], int src[${r}]) {`);for(let c=0;c<r;++c)o.push(`	a[${n[c]}]=src[${c}];`);return o.push("	}"),o.join(`
`)},e=t=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.");if(t[0].type!=="float32"&&t[0].type!=="float64")throw new Error("input should be float tensor")}},2488:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.encodeAsUint8=void 0;const m=y(6757),h=y(5639);u.encodeAsUint8=(f,s)=>{const l=s.shape,p=(0,m.getGlsl)(f.session.backend.glContext.version),a=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${p.texture2D}(X,TexCoords).r;
      ${p.output} = encodeAsUint8(value);
    }`,i={name:"Uint8Encode",inputTypes:[h.TextureType.unpacked],inputNames:["X"],output:{dims:l,type:s.tensor.type,textureType:h.TextureType.downloadUint8AsFloat},shaderSource:a,hasMain:!0};return f.executeProgram(i,[s.tensor])}},9087:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.tanh=u.tan=u.sqrt=u.sin=u.sigmoid=u.relu=u.not=u.neg=u.log=u.parseLeakyReluAttributes=u.leakyRelu=u.identity=u.floor=u.exp=u.parseEluAttributes=u.elu=u.cos=u.ceil=u.clipV11=u.parseClipAttributes=u.clip=u.atan=u.asin=u.acos=u.abs=u.glslTanh=u.glslTan=u.glslSqrt=u.glslSigmoid=u.glslRelu=u.glslSin=u.glslNot=u.glslNeg=u.glslLog=u.glslLeakyRelu=u.glslIdentity=u.glslClip=u.glslFloor=u.glslExp=u.glslElu=u.glslCos=u.glslCeil=u.glslAtan=u.glslAsin=u.glslAcos=u.glslAbs=void 0;const m=y(4910),h=y(7273),f=y(1997),s=y(6757),l=y(5639);function p(){return D("abs")}function a(){return D("acos")}function i(){return D("asin")}function e(){return D("atan")}function t(){return D("ceil")}function n(){return D("cos")}function r(P){const k="elu";return{body:`
  const float alpha = float(${P});

  float ${k}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${k}_(vec4 v) {
    return vec4(${k}_(v.x), ${k}_(v.y), ${k}_(v.z), ${k}_(v.w));
  }
  `,name:k,type:f.FunctionType.ValueBased}}function o(){return D("exp")}function c(){return D("floor")}function d(P,k){const V="clip";return{body:`
  const float min = float(${P});
  const float max = float(${k});

  float ${V}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${V}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:V,type:f.FunctionType.ValueBased}}function g(){const P="indentity";return{body:`
  float ${P}_(float a) {
    return a;
  }
  vec4 ${P}_(vec4 v) {
    return v;
  }
  `,name:P,type:f.FunctionType.ValueBased}}function b(P){const k="leakyRelu";return{body:`
  const float alpha = float(${P});

  float ${k}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${k}_(vec4 v) {
    return vec4(${k}_(v.x), ${k}_(v.y), ${k}_(v.z), ${k}_(v.w));
  }
  `,name:k,type:f.FunctionType.ValueBased}}function v(){return D("log")}function w(){const P="neg";return{body:`
  float ${P}_(float a) {
    return -a;
  }
  vec4 ${P}_(vec4 v) {
    return -v;
  }
  `,name:P,type:f.FunctionType.ValueBased}}function x(){const P="not";return{body:`
  float ${P}_(float a) {
    return float( ! bool(a) );
  }
  bool ${P}_(bool a) {
    return !a;
  }
  vec4 ${P}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${P}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:P,type:f.FunctionType.ValueBased}}function T(){return D("sin")}function S(){const P="relu";return{body:`
  float ${P}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${P}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:P,type:f.FunctionType.ValueBased}}function _(){const P="sigmoid";return{body:`
  float ${P}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${P}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:P,type:f.FunctionType.ValueBased}}function A(){return D("sqrt")}function E(){return D("tan")}function C(){const P="tanh";return{body:`
  float ${P}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${P}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:P,type:f.FunctionType.ValueBased}}function D(P){return{body:`
  float ${P}_(float a) {
    return ${P}(a);
  }
  vec4 ${P}_(vec4 v) {
    return ${P}(v);
  }
  `,name:P,type:f.FunctionType.ValueBased}}u.glslAbs=p,u.glslAcos=a,u.glslAsin=i,u.glslAtan=e,u.glslCeil=t,u.glslCos=n,u.glslElu=r,u.glslExp=o,u.glslFloor=c,u.glslClip=d,u.glslIdentity=g,u.glslLeakyRelu=b,u.glslLog=v,u.glslNeg=w,u.glslNot=x,u.glslSin=T,u.glslRelu=S,u.glslSigmoid=_,u.glslSqrt=A,u.glslTan=E,u.glslTanh=C;const $=(P,k,V,z)=>{const J=P.session.pack?l.TextureType.packed:l.TextureType.unpacked,q={name:V.name,inputTypes:[J],inputNames:["A"],cacheHint:z};return Object.assign(Object.assign({},q),{get:()=>((tt,rt,Z,at)=>{const st=tt.session.pack?l.TextureType.packed:l.TextureType.unpacked,et=(0,s.getGlsl)(tt.session.backend.glContext.version);return Object.assign(Object.assign({},rt),{output:{dims:Z.dims,type:Z.type,textureType:st},shaderSource:`
     ${at.body}
     void main() {
       vec4 v = ${et.texture2D}(A, TexCoords);
       v = ${at.name}_(v);
       ${et.output} = v;
     }
     `,hasMain:!0})})(P,q,k,V)})};u.abs=(P,k)=>[P.run($(P,k[0],p()),k)],u.acos=(P,k)=>[P.run($(P,k[0],a()),k)],u.asin=(P,k)=>[P.run($(P,k[0],i()),k)],u.atan=(P,k)=>[P.run($(P,k[0],e()),k)],u.clip=(P,k,V)=>[P.run($(P,k[0],d(V.min,V.max),V.cacheKey),k)],u.parseClipAttributes=P=>(0,m.createAttributeWithCacheKey)({min:P.attributes.getFloat("min",h.MIN_CLIP),max:P.attributes.getFloat("max",h.MAX_CLIP)}),u.clipV11=(P,k)=>{const V=L(P,k);return(0,u.clip)(P,[k[0]],V)};const L=(P,k)=>{if(k.length>=3&&(!P.session.isInitializer(k[1].dataId)||!P.session.isInitializer(k[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const V=k.length>=3?k[1].numberData[0]:h.MIN_CLIP,z=k.length>=3?k[2].numberData[0]:h.MAX_CLIP;return(0,m.createAttributeWithCacheKey)({min:V,max:z})};u.ceil=(P,k)=>[P.run($(P,k[0],t()),k)],u.cos=(P,k)=>[P.run($(P,k[0],n()),k)],u.elu=(P,k,V)=>[P.run($(P,k[0],r(V.alpha),V.cacheKey),k)],u.parseEluAttributes=P=>(0,m.createAttributeWithCacheKey)({alpha:P.attributes.getFloat("alpha",1)}),u.exp=(P,k)=>[P.run($(P,k[0],o()),k)],u.floor=(P,k)=>[P.run($(P,k[0],c()),k)],u.identity=(P,k)=>[P.run($(P,k[0],g()),k)],u.leakyRelu=(P,k,V)=>[P.run($(P,k[0],b(V.alpha),V.cacheKey),k)],u.parseLeakyReluAttributes=P=>(0,m.createAttributeWithCacheKey)({alpha:P.attributes.getFloat("alpha",.01)}),u.log=(P,k)=>[P.run($(P,k[0],v()),k)],u.neg=(P,k)=>[P.run($(P,k[0],w()),k)],u.not=(P,k)=>[P.run($(P,k[0],x()),k)],u.relu=(P,k)=>[P.run($(P,k[0],S()),k)],u.sigmoid=(P,k)=>[P.run($(P,k[0],_()),k)],u.sin=(P,k)=>[P.run($(P,k[0],T()),k)],u.sqrt=(P,k)=>[P.run($(P,k[0],A()),k)],u.tan=(P,k)=>[P.run($(P,k[0],E()),k)],u.tanh=(P,k)=>[P.run($(P,k[0],C()),k)]},540:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createUnpackProgramInfoLoader=u.createUnpackProgramInfo=void 0;const m=y(6757),h=y(5639),f=y(432),s=y(5614),l={name:"unpack",inputNames:["A"],inputTypes:[h.TextureType.packed]};u.createUnpackProgramInfo=(p,a)=>{const i=a.dims.length,e=(0,s.getChannels)("rc",i),t=e.slice(-2),n=(0,f.getCoordsDataType)(i),r=(0,s.unpackFromChannel)(),o=a.dims.length===0?"":function(g,b){if(g===1)return"rc";let v="";for(let w=0;w<g;w++)v+=b[w],w<g-1&&(v+=",");return v}(i,e),c=i<=1?"rc":`vec2(${t.join(",")})`,d=`
    ${r}
    void main() {
      ${n} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${o});

       ${(0,m.getGlsl)(p.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${c}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},l),{hasMain:!0,output:{dims:a.dims,type:a.type,textureType:h.TextureType.unpacked},shaderSource:d})},u.createUnpackProgramInfoLoader=(p,a)=>Object.assign(Object.assign({},l),{get:()=>(0,u.createUnpackProgramInfo)(p,a)})},7862:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseUnsqueezeAttributes=u.unsqueezeV13=u.unsqueeze=void 0;const m=y(7273);u.unsqueeze=(s,l,p)=>{h(l);const a=m.ShapeUtil.unsqueezeShape(l[0].dims,p);return[s.reshapeUnpacked(l[0],a)]},u.unsqueezeV13=(s,l)=>(f(l),(0,u.unsqueeze)(s,[l[0]],Array.from(l[1].integerData))),u.parseUnsqueezeAttributes=s=>s.attributes.getInts("axes");const h=s=>{if(!s||s.length!==1)throw new Error("Unsqueeze requires 1 input.");if(s[0].type==="string")throw new Error("invalid input tensor types.")},f=s=>{if(!s||s.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(s[1].type!=="int32")throw new Error("Invalid input type.")}},3980:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.scalesValidation=u.validateInputs=u.parseUpsampleAttributes=u.parseUpsampleAttributesV9=u.parseUpsampleAttributesV7=u.upsample=void 0;const m=y(4910),h=y(6757),f=y(5639),s={name:"Upsample",inputNames:["X"],inputTypes:[f.TextureType.unpacked]};u.upsample=(p,a,i)=>((0,u.validateInputs)(a,i),[p.run(Object.assign(Object.assign({},s),{cacheHint:i.cacheKey,get:()=>l(p,a,i)}),a)]),u.parseUpsampleAttributesV7=p=>(0,u.parseUpsampleAttributes)(p,7),u.parseUpsampleAttributesV9=p=>(0,u.parseUpsampleAttributes)(p,9),u.parseUpsampleAttributes=(p,a)=>{const i=a>=10,e=p.attributes.getString("mode","nearest");if(e!=="nearest"&&e!=="linear"&&(a<11||e!=="cubic"))throw new Error(`unrecognized mode: ${e}`);let t=[];a<9&&(t=p.attributes.getFloats("scales"),(0,u.scalesValidation)(t,e,i));const n=p.attributes.getFloat("extrapolation_value",0),r=a>10?p.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(r)===-1)throw new Error(`coordinate_transform_mode '${r}' is not supported`);const o=r==="tf_crop_and_resize",c=o,d=e==="nearest"&&a>=11?p.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(d)===-1)throw new Error(`nearest_mode '${d}' is not supported`);const g=p.attributes.getFloat("cubic_coeff_a",-.75),b=p.attributes.getInt("exclude_outside",0)!==0;if(b&&e!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const v=a<11||e==="nearest"&&r==="asymmetric"&&d==="floor";let w=0,x=0,T=0;return a>10?p.inputs.length>2?(w=1,x=2,T=3):(x=1,T=2):a===9&&(x=1),(0,m.createAttributeWithCacheKey)({opset:a,isResize:i,mode:e,scales:t,extrapolationValue:n,coordinateTransformMode:r,useExtrapolation:c,needRoiInput:o,nearestMode:d,cubicCoefficientA:g,excludeOutside:b,useNearest2xOptimization:v,roiInputIdx:w,scalesInputIdx:x,sizesInputIdx:T})};const l=(p,a,i)=>{const e=(0,h.getGlsl)(p.session.backend.glContext.version),[t,n]=p.calculateTextureWidthAndHeight(a[0].dims,f.TextureType.unpacked),r=a[0].dims.map((T,S)=>Math.floor(T*i.scales[S])),[o,c]=p.calculateTextureWidthAndHeight(r,f.TextureType.unpacked),d=r.length,g=new Array(d),b=new Array(d);let v=`
      int output_pitches[${d}];
      int input_pitches[${d}];
      `;for(let T=d-1;T>=0;T--)g[T]=T===d-1?1:g[T+1]*r[T+1],b[T]=T===d-1?1:b[T+1]*a[0].dims[T+1],v+=`
        output_pitches[${T}] = ${g[T]};
        input_pitches[${T}] = ${b[T]};
        `;const w=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${t}, ${n});
        float value = getColorAsFloat(${e.texture2D}(X, coords));
        return value;
      }
      `,x=i.mode==="nearest"?`
    ${w}
    float process(int indices[${d}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${o}, ${c});

      ${v}

      int d, m;
      for (int dim = 0; dim < ${d}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:d===4?`
    ${w}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${o}, ${c});

      ${v}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${a[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${w}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${o}, ${c});

      ${v}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${a[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},s),{output:{dims:r,type:a[0].type,textureType:f.TextureType.unpacked},shaderSource:x,variables:[{name:"scales",type:"int",arrayLength:i.scales.length,data:i.scales.map(T=>Math.ceil(T))}]})};u.validateInputs=(p,a)=>{if(!p||a.opset<9&&p.length!==1||a.opset>=9&&a.opset<11&&p.length!==2||a.opset>=11&&p.length<2)throw new Error("invalid inputs.");if(a.scales.length>0&&p[0].dims.length!==a.scales.length)throw new Error("Invalid input shape.");if(p[0].type==="string")throw new Error("Invalid input tensor types.")},u.scalesValidation=(p,a,i)=>{if(i){for(const e of p)if(e<=0)throw new Error("Scale value should be greater than 0.")}else for(const e of p)if(e<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(a!=="linear"&&a!=="cubic"||p.length===2||p.length===4&&p[0]===1&&p[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${i?"Resize":"Upsample"} opeartor.`)}},2757:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.ProgramManager=void 0;const m=y(8453),h=y(1315),f=y(8897),s=y(6757);u.ProgramManager=class{constructor(l,p,a){this.profiler=l,this.glContext=p,this.textureLayoutStrategy=a,this.repo=new Map,this.attributesBound=!1}getArtifact(l){return this.repo.get(l)}setArtifact(l,p){this.repo.set(l,p)}run(l,p,a){var i;this.profiler.event("op",`ProgramManager.run ${(i=l.programInfo.name)!==null&&i!==void 0?i:"unknown kernel"}`,()=>{var e;const t=this.glContext.gl,n=l.program;t.useProgram(n);try{this.bindOutput(a),this.attributesBound||this.bindAttributes(l.attribLocations),this.bindUniforms(l.uniformLocations,(e=l.programInfo.variables)!==null&&e!==void 0?e:[],p)}catch(r){throw h.Logger.error("ProgramManager",l.programInfo.shaderSource),r}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(l=>this.glContext.deleteProgram(l.program))}build(l,p,a){return this.profiler.event("backend","ProgramManager.build",()=>{const i=new f.GlslPreprocessor(this.glContext,l,p,a),e=i.preprocess(),t=this.compile(e);return{programInfo:l,program:t,uniformLocations:this.getUniformLocations(t,i.context.programInfo.inputNames,i.context.programInfo.variables),attribLocations:this.getAttribLocations(t)}})}compile(l){if(!this.vertexShader){h.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const i=(0,s.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(i,this.glContext.gl.VERTEX_SHADER)}m.env.debug&&h.Logger.verbose("ProrgramManager",`FragShader:
${l}
`);const p=this.glContext.compileShader(l,this.glContext.gl.FRAGMENT_SHADER),a=this.glContext.createProgram(this.vertexShader,p);return this.glContext.deleteShader(p),a}bindOutput(l){const p=l.width,a=l.height;h.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${p}/${a}, shape=${l.shape}, type=${l.tensor.type}`),this.glContext.attachFramebuffer(l.texture,p,a)}bindAttributes(l){const p=l.position,a=l.textureCoord;this.glContext.setVertexAttributes(p,a),this.attributesBound=!0}bindUniforms(l,p,a){var i;const e=this.glContext.gl;let t=0;for(const{name:n,type:r,location:o,arrayLength:c}of l){const d=(i=p.find(g=>g.name===n))===null||i===void 0?void 0:i.data;if(r!=="sampler2D"&&!d)throw new Error(`variable '${n}' does not have data defined in program info`);switch(r){case"sampler2D":this.bindTexture(a[t],o,t),t++;break;case"float":c?e.uniform1fv(o,d):e.uniform1f(o,d);break;case"int":c?e.uniform1iv(o,d):e.uniform1i(o,d);break;default:throw new Error(`Uniform not implemented: ${r}`)}}}bindTexture(l,p,a){this.glContext.bindTextureToUniform(l.texture,a,p)}getAttribLocations(l){return{position:this.getAttribLocation(l,"position"),textureCoord:this.getAttribLocation(l,"textureCoord")}}getUniformLocations(l,p,a){const i=[];if(p)for(const e of p)i.push({name:e,type:"sampler2D",location:this.getUniformLocation(l,e)});if(a)for(const e of a)i.push(Object.assign(Object.assign({},e),{location:this.getUniformLocation(l,e.name)}));return i}getUniformLocation(l,p){const a=this.glContext.gl.getUniformLocation(l,p);if(a===null)throw new Error(`Uniform ${p} not found.`);return a}getAttribLocation(l,p){return this.glContext.gl.getAttribLocation(l,p)}}},2171:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.WebGLSessionHandler=void 0;const m=y(1315),h=y(5881),f=y(7860),s=y(4110),l=y(2757),p=y(7618),a=y(5243);u.WebGLSessionHandler=class{constructor(i,e){this.backend=i,this.context=e,this.layoutStrategy=new p.PreferLogicalStrategy(i.glContext.maxTextureSize),this.programManager=new l.ProgramManager(this.context.profiler,i.glContext,this.layoutStrategy),this.textureManager=new a.TextureManager(i.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:i.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=i.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new f.WebGLInferenceHandler(this)}onGraphInitialized(i){const e=i.getValues().filter(t=>t.from===-1&&t.tensor).map(t=>t.tensor.dataId);this.initializers=new Set(e)}isInitializer(i){return!!this.initializers&&this.initializers.has(i)}addInitializer(i){this.initializers.add(i)}getTextureData(i,e){return e?this.packedTextureDataCache.get(i):this.unpackedTextureDataCache.get(i)}setTextureData(i,e,t=!1){m.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),t?this.packedTextureDataCache.set(i,e):this.unpackedTextureDataCache.set(i,e)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(i=>this.textureManager.releaseTexture(i,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(i=>this.textureManager.releaseTexture(i,!0)),this.unpackedTextureDataCache=new Map}resolve(i,e,t){const n=(0,h.resolveOperator)(i,e,s.WEBGL_OP_RESOLVE_RULES);return{impl:n.opImpl,context:n.opInit?n.opInit(i,t):i}}}},9622:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.Uint8DataEncoder=u.RGBAFloatDataEncoder=u.RedFloat32DataEncoder=void 0;const m=y(1315);u.RedFloat32DataEncoder=class{constructor(h,f=1){if(f===1)this.internalFormat=h.R32F,this.format=h.RED,this.textureType=h.FLOAT,this.channelSize=f;else{if(f!==4)throw new Error(`Invalid number of channels: ${f}`);this.internalFormat=h.RGBA32F,this.format=h.RGBA,this.textureType=h.FLOAT,this.channelSize=f}}encode(h,f){let s,l;return h.constructor!==Float32Array&&(m.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),l=new Float32Array(h)),f*this.channelSize>h.length?(m.Logger.warning("Encoder","Source data too small. Allocating larger array"),l=h,s=this.allocate(f*this.channelSize),l.forEach((p,a)=>s[a]=p)):(l=h,s=l),s}allocate(h){return new Float32Array(4*h)}decode(h,f){return this.channelSize===1?h.filter((s,l)=>l%4==0).subarray(0,f):h.subarray(0,f)}},u.RGBAFloatDataEncoder=class{constructor(h,f=1,s){if(f!==1&&f!==4)throw new Error(`Invalid number of channels: ${f}`);this.internalFormat=h.RGBA,this.format=h.RGBA,this.channelSize=f,this.textureType=s||h.FLOAT}encode(h,f){let s=h;return this.channelSize===1&&(m.Logger.verbose("Encoder","Exploding into a larger array"),s=this.allocate(f),h.forEach((l,p)=>s[4*p]=l)),s}allocate(h){return new Float32Array(4*h)}decode(h,f){return this.channelSize===1?h.filter((s,l)=>l%4==0).subarray(0,f):h.subarray(0,f)}},u.Uint8DataEncoder=class{constructor(h,f=1){if(this.channelSize=4,f===1)this.internalFormat=h.ALPHA,this.format=h.ALPHA,this.textureType=h.UNSIGNED_BYTE,this.channelSize=f;else{if(f!==4)throw new Error(`Invalid number of channels: ${f}`);this.internalFormat=h.RGBA,this.format=h.RGBA,this.textureType=h.UNSIGNED_BYTE,this.channelSize=f}}encode(h,f){return new Uint8Array(h.buffer,h.byteOffset,h.byteLength)}allocate(h){return new Uint8Array(h*this.channelSize)}decode(h,f){if(h instanceof Uint8Array)return h.subarray(0,f);throw new Error(`Invalid array type: ${h.constructor}`)}}},7618:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.getBatchDim=u.sizeToSquarishShape=u.getRowsCols=u.sizeFromShape=u.isInt=u.parseAxisParam=u.squeezeShape=u.PreferLogicalStrategy=u.AlwaysKeepOriginalSizeStrategy=void 0;const m=y(1315),h=y(7273);function f(i,e){const t=[],n=[],r=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||r?null:s(e,i).sort();let c=0;for(let d=0;d<i.length;++d){if(o!=null){if(o[c]===d&&i[d]!==1)throw new Error(`Can't squeeze axis ${d} since its dim '${i[d]}' is not 1`);(o[c]==null||o[c]>d)&&i[d]===1&&(t.push(i[d]),n.push(d)),o[c]<=d&&c++}i[d]!==1&&(t.push(i[d]),n.push(d))}return{newShape:t,keptDims:n}}function s(i,e){const t=e.length;return i=i==null?e.map((n,r)=>r):[].concat(i),(0,h.assert)(i.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${i}`),(0,h.assert)(i.every(l),()=>`All values in axis param must be integers but got axis ${i}`),i.map(n=>n<0?t+n:n)}function l(i){return i%1==0}function p(i){if(i.length===0)return 1;let e=i[0];for(let t=1;t<i.length;t++)e*=i[t];return e}function a(i){const e=Math.ceil(Math.sqrt(i));return[e,Math.ceil(i/e)]}u.AlwaysKeepOriginalSizeStrategy=class{constructor(i){this.maxTextureSize=i}computeTextureWH(i,e){if(i.length===0)return[1,1];const t=this.maxTextureSize;if(e&&e.breakAxis!==void 0){const o=e.breakAxis>=i.length?1:i.slice(e.breakAxis).reduce((d,g)=>d*g),c=e.breakAxis<=0?1:i.slice(0,e.breakAxis).reduce((d,g)=>d*g);if(!(o>t||c>t))return[o,c];m.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${i}, breakAxis:${e.breakAxis}`)}const n=i.reduce((o,c)=>o*c);let r=Math.floor(Math.sqrt(n));for(;r<t&&r<n&&n%r!=0;r++);if(r>=t||n%r!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${i}`);return[r,n/r]}},u.PreferLogicalStrategy=class{constructor(i){this.maxTextureSize=i}computeTextureWH(i,e){const t=this.computeTexture(i,e);return e&&e.isPacked&&(t[0]/=2,t[1]/=2),e&&e.reverseWH?[t[1],t[0]]:t}computeTexture(i,e){const t=e&&e.isPacked;if(i.length===0)return t?[2,2]:[1,1];let n=this.maxTextureSize;if(e&&e.breakAxis!==void 0){const c=e.breakAxis>=i.length?1:i.slice(e.breakAxis).reduce((g,b)=>g*b),d=e.breakAxis<=0?1:i.slice(0,e.breakAxis).reduce((g,b)=>g*b);if(!(c>n||d>n))return[c,d];m.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${i}, breakAxis:${e.breakAxis}`)}let r=i.slice(0);t&&(n*=2,r=r.map((c,d)=>d>=r.length-2?r[d]%2==0?r[d]:r[d]+1:r[d]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=f(r).newShape);const o=p(r);return r.length<=1&&o<=n?[1,o]:r.length===2&&r[0]<=n&&r[1]<=n?r:r.length===3&&r[0]*r[1]<=n&&r[2]<=n?[r[0]*r[1],r[2]]:r.length===3&&r[0]<=n&&r[1]*r[2]<=n?[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=n&&r[3]<=n?[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=n&&r[1]*r[2]*r[3]<=n?[r[0],r[1]*r[2]*r[3]]:t?a(o/4).map(c=>2*c):a(o)}},u.squeezeShape=f,u.parseAxisParam=s,u.isInt=l,u.sizeFromShape=p,u.getRowsCols=function(i){if(i.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[i.length>1?i[i.length-2]:1,i[i.length-1]]},u.sizeToSquarishShape=a,u.getBatchDim=function(i,e=2){return p(i.slice(0,i.length-e))}},3314:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createTextureLayoutFromShape=u.calculateTextureWidthAndHeight=u.createTextureLayoutFromTextureType=void 0;const m=y(7273),h=y(5639);u.createTextureLayoutFromTextureType=(f,s,l)=>{const p=l===h.TextureType.unpacked||l===h.TextureType.unpackedReversed?1:4,a=l===h.TextureType.packed,i=l===h.TextureType.unpackedReversed||l===h.TextureType.packed,e=l===h.TextureType.packedLastDimension?s.length-1:void 0,t=l===h.TextureType.packedLastDimension?s.map((n,r)=>r===s.length-1?4*n:n):void 0;return(0,u.createTextureLayoutFromShape)(f,s,p,t,{isPacked:a,reverseWH:i,breakAxis:e})},u.calculateTextureWidthAndHeight=(f,s,l)=>{const p=(0,u.createTextureLayoutFromTextureType)(f,s,l);return[p.width,p.height]},u.createTextureLayoutFromShape=(f,s,l=1,p,a)=>{const i=!(!a||!a.isPacked),[e,t]=f.computeTextureWH(i&&p||s,a),n=s.length;let r=s.slice(0);if(n===0&&(r=[1]),l===1)p=s;else if(i){if(l!==4)throw new Error("a packed texture must be 4-channel");p=s,n>0&&(r[n-1]=Math.ceil(r[n-1]/2)),n>1&&(r[n-2]=Math.ceil(r[n-2]/2))}else if(!p)throw new Error("Unpacked shape is needed when using channels > 1");return{width:e,height:t,channels:l,isPacked:i,shape:r,strides:m.ShapeUtil.computeStrides(r),unpackedShape:p,reversedWH:a&&a.reverseWH}}},5243:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.TextureManager=void 0;const m=y(1315);u.TextureManager=class{constructor(h,f,s,l){this.glContext=h,this.layoutStrategy=f,this.profiler=s,this.config=l,this.pendingRead=new Map,l.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(h,f,s,l){const p=this.toEncoderType(h),a=this.glContext.getEncoder(p,f.channels||1,l);if(f.isPacked&&l===1)throw new Error("not implemented");const i=f.width,e=f.height;let t,n;if(this.config.reuseTextures){t=`${i}x${e}_${a.format}_${a.internalFormat}_${a.textureType}`,n=this.inUseTextures.get(t),n||(n=[],this.inUseTextures.set(t,n));const o=this.idleTextures.get(t);if(o&&o.length>0){const c=o.pop();return n.push(c),l===1&&this.glContext.updateTexture(c,i,e,a,this.toTextureData(h,s)),c}}m.Logger.verbose("TextureManager",`Creating new texture of size ${f.width}x${f.height}`);const r=this.glContext.allocateTexture(i,e,a,this.toTextureData(h,s));return this.config.reuseTextures&&(n.push(r),this.textureLookup.set(r,t)),r}readTexture(h,f,s){return s||(s=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const l=h.shape.reduce((a,i)=>a*i)*s,p=this.glContext.readTexture(h.texture,h.width,h.height,l,this.toEncoderType(f),s);return this.toTensorData(f,p)})}async readTextureAsync(h,f,s){const l=h.tensor.dataId;if(s||(s=1),this.pendingRead.has(l)){const p=this.pendingRead.get(l);return new Promise(a=>p==null?void 0:p.push(a))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(l,[]);const p=h.shape.reduce((t,n)=>t*n)*s;await this.glContext.createAndWaitForFence();const a=this.glContext.readTexture(h.texture,h.width,h.height,p,this.toEncoderType(f),s),i=this.toTensorData(f,a),e=this.pendingRead.get(l);return this.pendingRead.delete(l),e==null||e.forEach(t=>t(i)),i})}readUint8TextureAsFloat(h){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const f=h.shape.reduce((l,p)=>l*p),s=this.glContext.readTexture(h.texture,h.width,h.height,4*f,"byte",4);return new Float32Array(s.buffer,s.byteOffset,f)})}releaseTexture(h,f){let s;if(this.config.reuseTextures&&(s=this.textureLookup.get(h.texture),s)){f&&this.textureLookup.delete(s);const l=this.inUseTextures.get(s);if(l){const p=l.indexOf(h.texture);if(p!==-1){l.splice(p,1);let a=this.idleTextures.get(s);a||(a=[],this.idleTextures.set(s,a)),a.push(h.texture)}}}s&&!f||(m.Logger.verbose("TextureManager",`Deleting texture of size ${h.width}x${h.height}`),this.glContext.deleteTexture(h.texture))}toTensorData(h,f){switch(h){case"int16":return f instanceof Int16Array?f:Int16Array.from(f);case"int32":return f instanceof Int32Array?f:Int32Array.from(f);case"int8":return f instanceof Int8Array?f:Int8Array.from(f);case"uint16":return f instanceof Uint16Array?f:Uint16Array.from(f);case"uint32":return f instanceof Uint32Array?f:Uint32Array.from(f);case"uint8":case"bool":return f instanceof Uint8Array?f:Uint8Array.from(f);case"float32":return f instanceof Float32Array?f:Float32Array.from(f);case"float64":return f instanceof Float64Array?f:Float64Array.from(f);default:throw new Error(`TensorData type ${h} is not supported`)}}toTextureData(h,f){if(f)return f instanceof Float32Array?f:new Float32Array(f)}toEncoderType(h){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(R,u)=>{var y;Object.defineProperty(u,"__esModule",{value:!0}),u.TextureType=void 0,(y=u.TextureType||(u.TextureType={}))[y.unpacked=0]="unpacked",y[y.unpackedReversed=1]="unpackedReversed",y[y.packed=2]="packed",y[y.downloadUint8AsFloat=3]="downloadUint8AsFloat",y[y.packedLastDimension=4]="packedLastDimension"},432:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.getGlChannels=u.getCoordsDataType=u.getSqueezedParams=u.squeezeInputShape=u.generateShaderFuncNameFromInputSamplerNameAtOutCoords=u.generateShaderFuncNameFromInputSamplerName=u.repeatedTry=u.getPackedShape=void 0;const m=y(7273);u.getPackedShape=function(h){const f=h.length;return h.slice(0,f-1).concat(h[f-1]/4)},u.repeatedTry=async function(h,f=l=>0,s){return new Promise((l,p)=>{let a=0;const i=()=>{if(h())return void l();a++;const e=f(a);s!=null&&a>=s?p():setTimeout(i,e)};i()})},u.generateShaderFuncNameFromInputSamplerName=function(h){return(0,m.assert)(h!==void 0&&h.length!==0,()=>"empty string found for sampler name"),"get"+h.charAt(0).toUpperCase()+h.slice(1)},u.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(h){return(0,m.assert)(h!==void 0&&h.length!==0,()=>"empty string found for sampler name"),"get"+h.charAt(0).toUpperCase()+h.slice(1)+"AtOutCoords"},u.squeezeInputShape=function(h,f){let s=JSON.parse(JSON.stringify(h));return s=f,s},u.getSqueezedParams=function(h,f){return f.map(s=>h[s]).join(", ")},u.getCoordsDataType=function(h){if(h<=1)return"int";if(h===2)return"ivec2";if(h===3)return"ivec3";if(h===4)return"ivec4";if(h===5)return"ivec5";if(h===6)return"ivec6";throw Error(`GPU for rank ${h} is not yet supported`)},u.getGlChannels=function(h=6){return["x","y","z","w","u","v"].slice(0,h)}},3389:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createNewWebGLContext=u.createWebGLContext=void 0;const m=y(1315),h=y(3524),f={};function s(l){const p=function(){if(typeof document>"u"){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const e=document.createElement("canvas");return e.width=1,e.height=1,e}();let a;const i={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!l||l==="webgl2")&&(a=p.getContext("webgl2",i),a))try{return new h.WebGLContext(a,2)}catch(e){m.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${e}`)}if((!l||l==="webgl")&&(a=p.getContext("webgl",i)||p.getContext("experimental-webgl",i),a))try{return new h.WebGLContext(a,1)}catch(e){m.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e}`)}throw new Error("WebGL is not supported")}u.createWebGLContext=function l(p){let a;p&&p!=="webgl2"||!("webgl2"in f)?p&&p!=="webgl"||!("webgl"in f)||(a=f.webgl):a=f.webgl2,a=a||s(p),p=p||a.version===1?"webgl":"webgl2";const i=a.gl;return f[p]=a,i.isContextLost()?(delete f[p],l(p)):(i.disable(i.DEPTH_TEST),i.disable(i.STENCIL_TEST),i.disable(i.BLEND),i.disable(i.DITHER),i.disable(i.POLYGON_OFFSET_FILL),i.disable(i.SAMPLE_COVERAGE),i.enable(i.SCISSOR_TEST),i.enable(i.CULL_FACE),i.cullFace(i.BACK),a)},u.createNewWebGLContext=s},3524:function(R,u,y){var m=this&&this.__createBinding||(Object.create?function(i,e,t,n){n===void 0&&(n=t);var r=Object.getOwnPropertyDescriptor(e,t);r&&!("get"in r?!e.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return e[t]}}),Object.defineProperty(i,n,r)}:function(i,e,t,n){n===void 0&&(n=t),i[n]=e[t]}),h=this&&this.__setModuleDefault||(Object.create?function(i,e){Object.defineProperty(i,"default",{enumerable:!0,value:e})}:function(i,e){i.default=e}),f=this&&this.__importStar||function(i){if(i&&i.__esModule)return i;var e={};if(i!=null)for(var t in i)t!=="default"&&Object.prototype.hasOwnProperty.call(i,t)&&m(e,i,t);return h(e,i),e};Object.defineProperty(u,"__esModule",{value:!0}),u.WebGLContext=u.linearSearchLastTrue=void 0;const s=y(8453),l=f(y(9622)),p=y(432);function a(i){let e=0;for(;e<i.length&&i[e]();++e);return e-1}u.linearSearchLastTrue=a,u.WebGLContext=class{constructor(i,e){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=i,this.version=e,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(i,e,t,n){const r=this.gl,o=r.createTexture();r.bindTexture(r.TEXTURE_2D,o),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE);const c=n?t.encode(n,i*e):null;return r.texImage2D(r.TEXTURE_2D,0,t.internalFormat,i,e,0,t.format,t.textureType,c),this.checkError(),o}updateTexture(i,e,t,n,r){const o=this.gl;o.bindTexture(o.TEXTURE_2D,i);const c=n.encode(r,e*t);o.texSubImage2D(o.TEXTURE_2D,0,0,0,e,t,n.format,n.textureType,c),this.checkError()}attachFramebuffer(i,e,t){const n=this.gl;n.bindTexture(n.TEXTURE_2D,i),n.bindFramebuffer(n.FRAMEBUFFER,this.framebuffer),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,i,0),this.checkError(),n.viewport(0,0,e,t),n.scissor(0,0,e,t)}readTexture(i,e,t,n,r,o){const c=this.gl;o||(o=1),this.frameBufferBound||this.attachFramebuffer(i,e,t);const d=this.getEncoder(r,o),g=d.allocate(e*t);return c.bindTexture(c.TEXTURE_2D,i),c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,i,0),c.readPixels(0,0,e,t,c.RGBA,d.textureType,g),this.checkError(),d.decode(g,n)}isFramebufferReady(){return!0}getActiveTexture(){const i=this.gl;return"TEXTURE"+(i.getParameter(this.gl.ACTIVE_TEXTURE)-i.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(i,e){const t=this.gl;t.vertexAttribPointer(i,3,t.FLOAT,!1,20,0),t.enableVertexAttribArray(i),e!==-1&&(t.vertexAttribPointer(e,2,t.FLOAT,!1,20,12),t.enableVertexAttribArray(e)),this.checkError()}createProgram(i,e){const t=this.gl,n=t.createProgram();return t.attachShader(n,i),t.attachShader(n,e),t.linkProgram(n),n}compileShader(i,e){const t=this.gl,n=t.createShader(e);if(!n)throw new Error(`createShader() returned null with type ${e}`);if(t.shaderSource(n,i),t.compileShader(n),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${t.getShaderInfoLog(n)}
Shader source:
${i}`);return n}deleteShader(i){this.gl.deleteShader(i)}bindTextureToUniform(i,e,t){const n=this.gl;n.activeTexture(n.TEXTURE0+e),this.checkError(),n.bindTexture(n.TEXTURE_2D,i),this.checkError(),n.uniform1i(t,e),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(s.env.debug){const i=this.gl,e=i.getError();let t="";switch(e){case i.NO_ERROR:return;case i.INVALID_ENUM:t="INVALID_ENUM";break;case i.INVALID_VALUE:t="INVALID_VALUE";break;case i.INVALID_OPERATION:t="INVALID_OPERATION";break;case i.INVALID_FRAMEBUFFER_OPERATION:t="INVALID_FRAMEBUFFER_OPERATION";break;case i.OUT_OF_MEMORY:t="OUT_OF_MEMORY";break;case i.CONTEXT_LOST_WEBGL:t="CONTEXT_LOST_WEBGL";break;default:t=`Unknown WebGL Error: ${e.toString(16)}`}throw new Error(t)}}deleteTexture(i){this.gl.deleteTexture(i)}deleteProgram(i){this.gl.deleteProgram(i)}getEncoder(i,e,t=0){if(this.version===2)return new l.RedFloat32DataEncoder(this.gl,e);switch(i){case"float":return t===1||this.isRenderFloat32Supported?new l.RGBAFloatDataEncoder(this.gl,e):new l.RGBAFloatDataEncoder(this.gl,e,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new l.Uint8DataEncoder(this.gl,e);default:throw new Error(`Invalid dataType: ${i}`)}}clearActiveTextures(){const i=this.gl;for(let e=0;e<this.maxTextureImageUnits;++e)i.activeTexture(i.TEXTURE0+e),i.bindTexture(i.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const i=this.gl;i.bindFramebuffer(i.FRAMEBUFFER,null),i.deleteFramebuffer(this.framebuffer),i.bindBuffer(i.ARRAY_BUFFER,null),i.deleteBuffer(this.vertexbuffer),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,null),i.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const i=this.gl,e=i.createBuffer();if(!e)throw new Error("createBuffer() returned null");const t=this.createDefaultGeometry();return i.bindBuffer(i.ARRAY_BUFFER,e),i.bufferData(i.ARRAY_BUFFER,t,i.STATIC_DRAW),this.checkError(),e}createFramebuffer(){const i=this.gl.createFramebuffer();if(!i)throw new Error("createFramebuffer returned null");return i}queryVitalParameters(){const i=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=i.getParameter(i.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const i=this.gl,e=i.createTexture();i.bindTexture(i.TEXTURE_2D,e);const t=this.version===2?i.RGBA32F:i.RGBA;i.texImage2D(i.TEXTURE_2D,0,t,1,1,0,i.RGBA,i.FLOAT,null);const n=i.createFramebuffer();i.bindFramebuffer(i.FRAMEBUFFER,n),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,e,0);const r=i.checkFramebufferStatus(i.FRAMEBUFFER)===i.FRAMEBUFFER_COMPLETE;return i.bindTexture(i.TEXTURE_2D,null),i.bindFramebuffer(i.FRAMEBUFFER,null),i.deleteTexture(e),i.deleteFramebuffer(n),r}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const i=this.gl;let e,t,n,r,o;try{e=i.createTexture(),t=i.createFramebuffer(),i.bindTexture(i.TEXTURE_2D,e);const c=this.version===2?i.RGBA32F:i.RGBA;return i.texImage2D(i.TEXTURE_2D,0,c,1,1,0,i.RGBA,i.FLOAT,null),i.bindFramebuffer(i.FRAMEBUFFER,t),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,e,0),i.enable(i.BLEND),n=i.createShader(i.VERTEX_SHADER),!!n&&(i.shaderSource(n,"void main(){}"),i.compileShader(n),r=i.createShader(i.FRAGMENT_SHADER),!!r&&(i.shaderSource(r,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),i.compileShader(r),o=i.createProgram(),!!o&&(i.attachShader(o,n),i.attachShader(o,r),i.linkProgram(o),i.useProgram(o),i.drawArrays(i.POINTS,0,1),i.getError()===i.NO_ERROR)))}finally{i.disable(i.BLEND),o&&i.deleteProgram(o),n&&i.deleteShader(n),r&&i.deleteShader(r),t&&(i.bindFramebuffer(i.FRAMEBUFFER,null),i.deleteFramebuffer(t)),e&&(i.bindTexture(i.TEXTURE_2D,null),i.deleteTexture(e))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const i=this.gl,e=this.disjointTimerQueryWebgl2Extension,t=i.createQuery();return i.beginQuery(e.TIME_ELAPSED_EXT,t),t}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const i=this.gl,e=this.disjointTimerQueryWebgl2Extension;i.endQuery(e.TIME_ELAPSED_EXT)}}isTimerResultAvailable(i){let e=!1,t=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const n=this.gl,r=this.disjointTimerQueryWebgl2Extension;e=n.getQueryParameter(i,n.QUERY_RESULT_AVAILABLE),t=n.getParameter(r.GPU_DISJOINT_EXT)}return e&&!t}getTimerResult(i){let e=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const t=this.gl;e=t.getQueryParameter(i,t.QUERY_RESULT),t.deleteQuery(i)}return e/1e6}async waitForQueryAndGetTime(i){return await(0,p.repeatedTry)(()=>this.isTimerResultAvailable(i)),this.getTimerResult(i)}async createAndWaitForFence(){const i=this.createFence(this.gl);return this.pollFence(i)}createFence(i){let e;const t=i,n=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);return i.flush(),e=n===null?()=>!0:()=>{const r=t.clientWaitSync(n,0,0);return r===t.ALREADY_SIGNALED||r===t.CONDITION_SATISFIED},{query:n,isFencePassed:e}}async pollFence(i){return new Promise(e=>{this.addItemToPoll(()=>i.isFencePassed(),()=>e())})}pollItems(){const i=a(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=i;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(i+1)}async addItemToPoll(i,e){this.itemsToPoll.push({isDoneFn:i,resolveFn:e}),this.itemsToPoll.length>1||await(0,p.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},6496:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.ExecutionPlan=void 0;const m=y(1315);class h{constructor(s,l){this.op=s,this.node=l}}u.ExecutionPlan=class{constructor(f,s,l){this.graph=f,this.profiler=l,this.initialize(s)}initialize(f){this.profiler.event("session","ExecutionPlan.initialize",()=>{const s=this.graph.getNodes();if(s.length!==f.length)throw new Error("The size of nodes and OPs do not match.");this._ops=f.map((l,p)=>new h(l,s[p])),this.reset(),this._starter=[],this._ops.forEach((l,p)=>{let a=!0;for(const i of l.node.inputs)if(!this._values[i]&&this.graph.getInputIndices().indexOf(i)===-1){a=!1;break}a&&this._starter.push(p)})})}reset(){this._values=this.graph.getValues().map(f=>f.tensor)}async execute(f,s){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();const l=f.createInferenceHandler(),p=this.graph.getInputIndices();if(s.length!==p.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${s.length} expected: ${p.length}`);s.forEach((r,o)=>{const c=p[o];this._values[c]=r});const a=this._starter.slice(0),i=this.graph.getValues(),e=this.graph.getNodes();let t=0;for(;t<a.length;){const r=a[t++],o=this._ops[r],c=o.node.inputs.map(v=>this._values[v]);if(c.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${o.node}`);const d=c;m.Logger.verbose("ExecPlan",`Runing op:${o.node.name} (${d.map((v,w)=>`'${o.node.inputs[w]}': ${v.type}[${v.dims.join(",")}]`).join(", ")})`);const g=await this.profiler.event("node",o.node.name,async()=>o.op.impl(l,d,o.op.context));if(g.length!==o.node.outputs.length)throw new Error("the size of output does not match model definition.");g.forEach((v,w)=>{const x=o.node.outputs[w];if(this._values[x])throw new Error(`output [${x}] already has value: op:${o.node.name}`);this._values[x]=v});const b=new Set;g.forEach((v,w)=>{const x=o.node.outputs[w];for(const T of i[x].to){const S=e[T];let _=!0;for(const A of S.inputs)if(!this._values[A]){_=!1;break}_&&b.add(T)}}),a.push(...b)}const n=[];for(let r=0;r<this.graph.getOutputIndices().length;r++){const o=this.graph.getOutputIndices()[r],c=this._values[o];if(c===void 0)throw new Error(`required output [${o}] does not have value`);o===0?await c.getData():c.data,n.push(c)}return m.Logger.verbose("ExecPlan","disposing of inferenceHandler"),l.dispose(),n})}}},4662:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.Graph=void 0;const m=y(1446),h=y(6874),f=y(1287),s=y(9240),l=y(7273);var p=f.onnxruntime.experimental.fbs;u.Graph={from:(t,n)=>new e(t,n)};class a{constructor(n){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,n&&(this.type=l.ProtoUtil.tensorValueTypeFromProto(n.type.tensorType))}get from(){return this._from}get to(){return this._to}}class i{constructor(n,r){n instanceof m.onnx.NodeProto?(this.name=n.name,this.opType=n.opType,this.attributes=new h.Attribute(n.attribute)):n instanceof p.Node&&(this.name=r??n.name(),this.opType=n.opType(),this.attributes=new h.Attribute(l.ProtoUtil.tensorAttributesFromORTFormat(n))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class e{constructor(n,r){if(!n)throw new TypeError("graph is empty");this.buildGraph(n),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(n){if(n instanceof m.onnx.GraphProto)this.buildGraphFromOnnxFormat(n);else{if(!(n instanceof p.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(n)}}buildGraphFromOnnxFormat(n){const r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const o=new Map;if(!n.input)throw new Error("missing information in graph: input");const c=[];for(const d of n.input){if(r.has(d.name))throw new Error(`duplicated input name: ${d.name}`);const g=this._allData.push(new a(d))-1;r.set(d.name,g),c.push(d.name)}if(!n.initializer)throw new Error("missing information in graph: initializer");for(const d of n.initializer){let g=r.get(d.name);if(g===void 0){const b=new a;b.type={shape:{dims:l.ProtoUtil.tensorDimsFromProto(d.dims)},tensorType:l.ProtoUtil.tensorDataTypeFromProto(d.dataType)},g=this._allData.push(b)-1,r.set(d.name,g)}this._allData[g]._from=-1,this._allData[g].tensor=s.Tensor.fromProto(d)}for(let d=0;d<this._allData.length;d++)this._allData[d].tensor||(this._allInputIndices.push(d),this._allInputNames.push(c[d]));if(!n.output)throw new Error("missing information in graph: output");for(const d of n.output){if(r.has(d.name))throw new Error(`duplicated output name: ${d.name}`);const g=this._allData.push(new a(d))-1;r.set(d.name,g),this._allOutputIndices.push(g),this._allOutputNames.push(d.name)}if(!n.node)throw new Error("missing information in graph: node");for(const d of n.node){if(!d.name)for(let b=0;;b++){const v=`unnamed_${d.opType}_${b}`;if(!o.has(v)){d.name=v;break}}if(o.has(d.name))throw new Error(`duplicated node name: ${d.name}`);const g=this._nodes.push(new i(d))-1;o.set(d.name,g)}for(let d=0;d<this._nodes.length;d++){const g=this._nodes[d],b=n.node[d];if(!b.output)throw new Error(`missing output for node: ${b.name}`);for(const v of b.output){let w=r.get(v);if(w===void 0&&(w=this._allData.push(new a)-1,r.set(v,w)),g.outputs.push(w),this._allData[w]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${w}`);if(this._allData[w]._from=d,b.opType==="Constant"){if(!b.attribute||b.attribute.length!==1||!b.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!b.output||b.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");g.outputs.pop(),g.executeNode=!1,this._allData[w]._from=-1,this._allData[w].tensor=s.Tensor.fromProto(b.attribute[0].t)}}}for(let d=0;d<this._nodes.length;d++){const g=this._nodes[d],b=n.node[d];if(!b.input)throw new Error(`missing input for node: ${b.name}`);for(const v of b.input){const w=r.get(v);if(w===void 0){if(v===""&&b.input.length===3&&b.opType==="Resize")continue;throw new Error(`unrecognized input '${v}' for node: ${b.name}`)}g.inputs.push(w),this._allData[w]._to.push(d)}}return!0}buildGraphFromOrtFormat(n){var r,o,c;const d=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const g=new Map,b=[];for(let v=0;v<n.inputsLength();v++){const w=n.inputs(v);if(d.has(w))throw new Error(`duplicated input name: ${w}`);for(let x=0;x<n.nodeArgsLength();x++)if(((r=n.nodeArgs(x))===null||r===void 0?void 0:r.name())===w){const T=new a;if(((c=(o=n.nodeArgs(x))===null||o===void 0?void 0:o.type())===null||c===void 0?void 0:c.valueType())!==p.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const S=n.nodeArgs(x).type().value(new p.TensorTypeAndShape),_=l.ProtoUtil.tensorDataTypeFromProto(S.elemType()),A=S.shape(),E=[];for(let D=0;D<A.dimLength();D++)E.push(l.LongUtil.longToNumber(A.dim(D).value().dimValue()));T.type={shape:{dims:E},tensorType:_};const C=this._allData.push(T)-1;d.set(w,C),b.push(w)}}for(let v=0;v<n.initializersLength();v++){const w=n.initializers(v);let x=d.get(w.name());if(x===void 0){const T=new a,S=l.ProtoUtil.tensorDimsFromORTFormat(w),_=l.ProtoUtil.tensorDataTypeFromProto(w.dataType());T.type={shape:{dims:S},tensorType:_},x=this._allData.push(T)-1,d.set(w.name(),x)}this._allData[x]._from=-1,this._allData[x].tensor=s.Tensor.fromOrtTensor(w)}for(let v=0;v<this._allData.length;v++)this._allData[v].tensor||(this._allInputIndices.push(v),this._allInputNames.push(b[v]));for(let v=0;v<n.outputsLength();v++){const w=n.outputs(v);if(d.has(w))throw new Error(`duplicated output name: ${w}`);const x=this._allData.push(new a)-1;d.set(w,x),this._allOutputIndices.push(x),this._allOutputNames.push(w)}if(!n.nodes)throw new Error("missing information in graph: node");for(let v=0;v<n.nodesLength();v++){const w=n.nodes(v);let x=w.name();if(!x)for(let S=0;x=`unnamed_${w.opType()}_${S}`,g.has(x);S++);if(g.has(x))throw new Error(`duplicated node name: ${x}`);const T=this._nodes.push(new i(w,x))-1;g.set(x,T)}for(let v=0;v<this._nodes.length;v++){const w=this._nodes[v],x=n.nodes(v);if(x==null)throw new Error(`No node exists at index ${v}`);if((x==null?void 0:x.outputsLength())===0)throw new Error(`missing output for node: ${x.name}`);for(let T=0;T<(x==null?void 0:x.outputsLength());T++){const S=x==null?void 0:x.outputs(T);let _=d.get(S);if(_===void 0&&(_=this._allData.push(new a)-1,d.set(S,_)),w.outputs.push(_),this._allData[_]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${_}`);if(this._allData[_]._from=v,x.opType()==="Constant"){if(x.attributesLength()!==1||!x.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(x.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");w.outputs.pop(),w.executeNode=!1,this._allData[_]._from=-1,this._allData[_].tensor=s.Tensor.fromOrtTensor(x.attributes(0).t())}}}for(let v=0;v<this._nodes.length;v++){const w=this._nodes[v],x=n.nodes(v);if(x.inputsLength()===0)throw new Error(`missing input for node: ${x.name}`);for(let T=0;T<x.inputsLength();T++){const S=x.inputs(T),_=d.get(S);if(_===void 0)throw new Error(`unrecognized input '${S}' for node: ${x.name()}`);w.inputs.push(_),this._allData[_]._to.push(v)}}}checkIsAcyclic(){const n=new Set;this._allInputIndices.forEach(c=>{this._allData[c]._to.forEach(d=>{n.add(d)})});const r=Array.from(n),o=new Array(this._nodes.length).fill("white");for(;r.length>0;){const c=r.pop();o[c]==="gray"?o[c]="black":(r.push(c),o[c]="gray",this._nodes[c].outputs.forEach(d=>{const g=this._allData[d];if(g.tensor!==void 0)throw new Error("node outputs should not be initialized");if(g._from!==c)throw new Error("from property of the Value object doesn't match index of Node being processed");g._to.forEach(b=>{if(o[b]==="gray")throw new Error("model graph is cyclic");o[b]==="white"&&r.push(b)})}))}}transformGraph(n){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),n&&n.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let n=0;const r=new Array(this._nodes.length,0);let o=0;for(let c=0;c<this._nodes.length;c++)r[c]=o,this._nodes[c].executeNode?(o!==c&&(this._nodes[o]=this._nodes[c]),o++):this._nodes[c].outputs.forEach(d=>{this._allData[d]._from=-2});this._nodes.splice(o,this._nodes.length-o);for(let c=0;c<this._allData.length;c++){const d=this._allData[c];d._from!==void 0&&d._from!==-1&&d._from!==-2&&(d._from=r[d._from]);for(let g=0;g<d._to.length;g++){if(!(d._to[g]>=0))throw new Error("Trying to update a removed node");d._to[g]=r[d._to[g]]}}n=0;for(let c=0;c<this._allData.length;c++)if(this._allData[c].from!==-2||this._allOutputIndices.indexOf(c+n)!==-1){if(n>0){let d=-1;this._allData[c].from!==void 0&&this._allData[c].from!==-1?(d=this._nodes[this._allData[c].from].outputs.indexOf(c+n),d!==-1&&(this._nodes[this._allData[c].from].outputs[d]=c)):(d=this._allInputIndices.indexOf(c+n),d!==-1&&(this._allInputIndices[d]=c)),this._allData[c].to.forEach(g=>{d=this._nodes[g].inputs.indexOf(c+n),d!==-1&&(this._nodes[g].inputs[d]=c)}),this._allData[c].to.length===0&&(d=this._allOutputIndices.indexOf(c+n),d!==-1&&(this._allOutputIndices[d]=c))}}else n++,this._allData.splice(c,1),c--}deleteNode(n){const r=this._nodes[n];if(r.outputs.length>1){for(let b=1;b<r.outputs.length;b++)if(this._allData[r.outputs[b]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;const o=r.inputs[0],c=r.outputs[0],d=this._allData[c].to;for(let b=0;b<r.inputs.length;b++){const v=this._allData[r.inputs[b]].to.indexOf(n);if(v===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[b]].to.splice(v,1)}this._allData[c]._to=[];const g=this._allOutputIndices.indexOf(c);if(g!==-1&&(this._allOutputIndices[g]=o),d&&d.length>0)for(const b of d){const v=this._nodes[b].inputs.indexOf(c);if(v===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[b].inputs[v]=o,this._allData[o].to.push(b)}}removeAllDropoutNodes(){let n=0;for(const r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(n)}n++}}removeAllIdentityNodes(){let n=0;for(const r of this._nodes)r.opType==="Identity"&&this.deleteNode(n),n++}isActivation(n){switch(n.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const n of this._nodes)if(n.opType==="Conv"){const r=this._allData[n.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){const o=this._nodes[r[0]];if(o.opType==="Clip")if(o.inputs.length===1)try{n.attributes.set("activation_params","floats",[o.attributes.getFloat("min"),o.attributes.getFloat("max")])}catch{n.attributes.set("activation_params","floats",[l.MIN_CLIP,l.MAX_CLIP])}else{if(!(o.inputs.length>=3&&this._allData[o.inputs[1]].tensor!==void 0&&this._allData[o.inputs[2]].tensor!==void 0))continue;n.attributes.set("activation_params","floats",[this._allData[o.inputs[1]].tensor.floatData[0],this._allData[o.inputs[2]].tensor.floatData[0]])}n.attributes.set("activation","string",o.opType),this.deleteNode(r[0])}}}}},1315:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.now=u.Profiler=u.Logger=void 0;const y={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},m={none:new class{log(i,e,t){}},console:new class{log(i,e,t){console.log(`${this.color(i)} ${t?"\x1B[35m"+t+"\x1B[0m ":""}${e}`)}color(i){switch(i){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${i}`)}}}},h={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let f={"":h};function s(i,e,t,n){if(e===void 0)return r=i,{verbose:s.verbose.bind(null,r),info:s.info.bind(null,r),warning:s.warning.bind(null,r),error:s.error.bind(null,r),fatal:s.fatal.bind(null,r)};if(t===void 0)l(i,e);else if(typeof t=="number"&&n===void 0)l(i,e);else if(typeof t=="string"&&n===void 0)l(i,t,0,e);else{if(typeof t!="string"||typeof n!="number")throw new TypeError("input is valid");l(i,t,0,e)}var r}function l(i,e,t,n){const r=f[n||""]||f[""];y[i]<y[r.minimalSeverity]||(r.logDateTime&&(e=`${new Date().toISOString()}|${e}`),r.logSourceLocation,m[r.provider].log(i,e,n))}(function(i){function e(n){f={},t("",n||{})}function t(n,r){if(n==="*")e(r);else{const o=f[n]||h;f[n]={provider:r.provider||o.provider,minimalSeverity:r.minimalSeverity||o.minimalSeverity,logDateTime:r.logDateTime===void 0?o.logDateTime:r.logDateTime,logSourceLocation:r.logSourceLocation===void 0?o.logSourceLocation:r.logSourceLocation}}}i.verbose=function(n,r){i("verbose",n,r)},i.info=function(n,r){i("info",n,r)},i.warning=function(n,r){i("warning",n,r)},i.error=function(n,r){i("error",n,r)},i.fatal=function(n,r){i("fatal",n,r)},i.reset=e,i.set=t,i.setWithEnv=function(n){const r={};n.logLevel&&(r.minimalSeverity=n.logLevel),t("",r)}})(s||(s={})),u.Logger=s;class p{constructor(e,t,n,r,o,c){this.category=e,this.name=t,this.startTime=n,this.endCallback=r,this.timer=o,this.ctx=c}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class a{constructor(e,t,n,r){this.category=e,this.name=t,this.startTime=n,this.endTime=r}}u.Profiler=class{static create(i){return i===void 0?new this:new this(i.maxNumberEvents,i.flushBatchSize,i.flushIntervalInMilliseconds)}constructor(i,e,t){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=i===void 0?1e4:i,this._flushBatchSize=e===void 0?10:e,this._flushIntervalInMilliseconds=t===void 0?5e3:t}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,u.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(i,e,t,n){const r=this._started?this.begin(i,e,n):void 0;let o=!1;const c=t();if(c&&typeof c.then=="function")return o=!0,new Promise((d,g)=>{c.then(async b=>{r&&await r.end(),d(b)},async b=>{r&&await r.end(),g(b)})});if(!o&&r){const d=r.end();if(d&&typeof d.then=="function")return new Promise((g,b)=>{d.then(()=>{g(c)},v=>{b(v)})})}return c}begin(i,e,t){if(!this._started)throw new Error("profiler is not started yet");if(t===void 0){const n=(0,u.now)();return this.flush(n),new p(i,e,n,r=>this.endSync(r))}{const n=t.beginTimer();return new p(i,e,0,async r=>this.end(r),n,t)}}async end(i){const e=await i.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new a(i.category,i.name,i.startTime,e)),this.flush(e))}endSync(i){const e=(0,u.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new a(i.category,i.name,i.startTime,e)),this.flush(e))}logOneEvent(i){u.Logger.verbose(`Profiler.${i.category}`,`${(i.endTime-i.startTime).toFixed(2)}ms on event '${i.name}' at ${i.endTime.toFixed(2)}`)}flush(i){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||i-this._flushTime>=this._flushIntervalInMilliseconds){for(const e=this._flushPointer;this._flushPointer<e+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,u.now)()}}get started(){return this._started}},u.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},1745:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.Model=void 0;const m=y(5686),h=y(1446),f=y(4662),s=y(1287),l=y(7273);var p=s.onnxruntime.experimental.fbs;u.Model=class{constructor(){}load(a,i,e){if(!e)try{return void this.loadFromOnnxFormat(a,i)}catch(t){if(e!==void 0)throw t}this.loadFromOrtFormat(a,i)}loadFromOnnxFormat(a,i){const e=h.onnx.ModelProto.decode(a);if(l.LongUtil.longToNumber(e.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=e.opsetImport.map(t=>({domain:t.domain,version:l.LongUtil.longToNumber(t.version)})),this._graph=f.Graph.from(e.graph,i)}loadFromOrtFormat(a,i){const e=new m.flatbuffers.ByteBuffer(a),t=p.InferenceSession.getRootAsInferenceSession(e).model();if(l.LongUtil.longToNumber(t.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let n=0;n<t.opsetImportLength();n++){const r=t.opsetImport(n);this._opsets.push({domain:r==null?void 0:r.domain(),version:l.LongUtil.longToNumber(r.version())})}this._graph=f.Graph.from(t.graph(),i)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.FLOAT_TYPES=u.INT_TYPES=u.NUMBER_TYPES=void 0,u.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],u.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],u.FLOAT_TYPES=["float32","float64"]},5881:(R,u)=>{function y(m,h){if(h.endsWith("+")){const f=Number.parseInt(h.substring(0,h.length-1),10);return!isNaN(f)&&f<=m}if(h.split("-").length===2){const f=h.split("-"),s=Number.parseInt(f[0],10),l=Number.parseInt(f[1],10);return!isNaN(s)&&!isNaN(l)&&s<=m&&m<=l}return Number.parseInt(h,10)===m}Object.defineProperty(u,"__esModule",{value:!0}),u.resolveOperator=void 0,u.resolveOperator=function(m,h,f){for(const s of f){const l=s[0],p=s[1],a=s[2],i=s[3],e=s[4];if(m.opType===l){for(const t of h)if((t.domain===p||t.domain==="ai.onnx"&&p==="")&&y(t.version,a))return{opImpl:i,opInit:e}}}throw new TypeError(`cannot resolve operator '${m.opType}' with opsets: ${h.map(s=>`${s.domain||"ai.onnx"} v${s.version}`).join(", ")}`)}},1287:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.onnxruntime=void 0;const m=y(5686);var h,f;h=u.onnxruntime||(u.onnxruntime={}),function(s){(function(l){l[l.UNDEFINED=0]="UNDEFINED",l[l.FLOAT=1]="FLOAT",l[l.INT=2]="INT",l[l.STRING=3]="STRING",l[l.TENSOR=4]="TENSOR",l[l.GRAPH=5]="GRAPH",l[l.FLOATS=6]="FLOATS",l[l.INTS=7]="INTS",l[l.STRINGS=8]="STRINGS",l[l.TENSORS=9]="TENSORS",l[l.GRAPHS=10]="GRAPHS",l[l.SPARSE_TENSOR=11]="SPARSE_TENSOR",l[l.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(s.AttributeType||(s.AttributeType={}))}((f=h.experimental||(h.experimental={})).fbs||(f.fbs={})),function(s){(function(l){(function(p){(function(a){a[a.UNKNOWN=0]="UNKNOWN",a[a.VALUE=1]="VALUE",a[a.PARAM=2]="PARAM"})(p.DimensionValueType||(p.DimensionValueType={}))})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){(function(a){a[a.UNDEFINED=0]="UNDEFINED",a[a.FLOAT=1]="FLOAT",a[a.UINT8=2]="UINT8",a[a.INT8=3]="INT8",a[a.UINT16=4]="UINT16",a[a.INT16=5]="INT16",a[a.INT32=6]="INT32",a[a.INT64=7]="INT64",a[a.STRING=8]="STRING",a[a.BOOL=9]="BOOL",a[a.FLOAT16=10]="FLOAT16",a[a.DOUBLE=11]="DOUBLE",a[a.UINT32=12]="UINT32",a[a.UINT64=13]="UINT64",a[a.COMPLEX64=14]="COMPLEX64",a[a.COMPLEX128=15]="COMPLEX128",a[a.BFLOAT16=16]="BFLOAT16"})(p.TensorDataType||(p.TensorDataType={}))})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){(function(a){a[a.Primitive=0]="Primitive",a[a.Fused=1]="Fused"})(p.NodeType||(p.NodeType={}))})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){(function(a){a[a.NONE=0]="NONE",a[a.tensor_type=1]="tensor_type",a[a.sequence_type=2]="sequence_type",a[a.map_type=3]="map_type"})(p.TypeInfoValue||(p.TypeInfoValue={}))})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsShape(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsShape(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}dim(e,t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new s.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*e),this.bb):null}dimLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}static startShape(e){e.startObject(1)}static addDim(e,t){e.addFieldOffset(0,t,0)}static createDimVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startDimVector(e,t){e.startVector(4,t,4)}static endShape(e){return e.endObject()}static createShape(e,t){return a.startShape(e),a.addDim(e,t),a.endShape(e)}}p.Shape=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimension(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimension(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}value(e){let t=this.bb.__offset(this.bb_pos,4);return t?(e||new s.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}denotation(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimension(e){e.startObject(2)}static addValue(e,t){e.addFieldOffset(0,t,0)}static addDenotation(e,t){e.addFieldOffset(1,t,0)}static endDimension(e){return e.endObject()}static createDimension(e,t,n){return a.startDimension(e),a.addValue(e,t),a.addDenotation(e,n),a.endDimension(e)}}p.Dimension=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimensionValue(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimensionValue(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}dimType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt8(this.bb_pos+e):s.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}dimParam(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimensionValue(e){e.startObject(3)}static addDimType(e,t){e.addFieldInt8(0,t,s.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static addDimParam(e,t){e.addFieldOffset(2,t,0)}static endDimensionValue(e){return e.endObject()}static createDimensionValue(e,t,n,r){return a.startDimensionValue(e),a.addDimType(e,t),a.addDimValue(e,n),a.addDimParam(e,r),a.endDimensionValue(e)}}p.DimensionValue=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensorTypeAndShape(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensorTypeAndShape(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}elemType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt32(this.bb_pos+e):s.experimental.fbs.TensorDataType.UNDEFINED}shape(e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new s.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startTensorTypeAndShape(e){e.startObject(2)}static addElemType(e,t){e.addFieldInt32(0,t,s.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(e,t){e.addFieldOffset(1,t,0)}static endTensorTypeAndShape(e){return e.endObject()}static createTensorTypeAndShape(e,t,n){return a.startTensorTypeAndShape(e),a.addElemType(e,t),a.addShape(e,n),a.endTensorTypeAndShape(e)}}p.TensorTypeAndShape=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsMapType(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsMapType(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}keyType(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt32(this.bb_pos+e):s.experimental.fbs.TensorDataType.UNDEFINED}valueType(e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new s.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startMapType(e){e.startObject(2)}static addKeyType(e,t){e.addFieldInt32(0,t,s.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(e,t){e.addFieldOffset(1,t,0)}static endMapType(e){return e.endObject()}static createMapType(e,t,n){return a.startMapType(e),a.addKeyType(e,t),a.addValueType(e,n),a.endMapType(e)}}p.MapType=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSequenceType(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSequenceType(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}elemType(e){let t=this.bb.__offset(this.bb_pos,4);return t?(e||new s.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startSequenceType(e){e.startObject(1)}static addElemType(e,t){e.addFieldOffset(0,t,0)}static endSequenceType(e){return e.endObject()}static createSequenceType(e,t){return a.startSequenceType(e),a.addElemType(e,t),a.endSequenceType(e)}}p.SequenceType=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(l.fbs||(l.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(p,a){return this.bb_pos=p,this.bb=a,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(p,a,i,e){return p.prep(4,12),p.writeInt32(e),p.writeInt32(i),p.writeInt32(a),p.offset()}}})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNodeEdge(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNodeEdge(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}nodeIndex(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb_pos+e):0}inputEdges(e,t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new s.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+n)+12*e,this.bb):null}inputEdgesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}outputEdges(e,t){let n=this.bb.__offset(this.bb_pos,8);return n?(t||new s.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+n)+12*e,this.bb):null}outputEdgesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNodeEdge(e){e.startObject(3)}static addNodeIndex(e,t){e.addFieldInt32(0,t,0)}static addInputEdges(e,t){e.addFieldOffset(1,t,0)}static startInputEdgesVector(e,t){e.startVector(12,t,4)}static addOutputEdges(e,t){e.addFieldOffset(2,t,0)}static startOutputEdgesVector(e,t){e.startVector(12,t,4)}static endNodeEdge(e){return e.endObject()}static createNodeEdge(e,t,n,r){return a.startNodeEdge(e),a.addNodeIndex(e,t),a.addInputEdges(e,n),a.addOutputEdges(e,r),a.endNodeEdge(e)}}p.NodeEdge=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNode(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNode(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}sinceVersion(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readInt32(this.bb_pos+e):0}index(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb_pos+e):0}opType(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readInt32(this.bb_pos+e):s.experimental.fbs.NodeType.Primitive}executionProviderType(e){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__string(this.bb_pos+t,e):null}inputs(e,t){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}attributes(e,t){let n=this.bb.__offset(this.bb_pos,24);return n?(t||new s.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*e),this.bb):null}attributesLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCounts(e){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readInt32(this.bb.__vector(this.bb_pos+t)+4*e):0}inputArgCountsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCountsArray(){let e=this.bb.__offset(this.bb_pos,26);return e?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}implicitInputs(e,t){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}implicitInputsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNode(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDomain(e,t){e.addFieldOffset(2,t,0)}static addSinceVersion(e,t){e.addFieldInt32(3,t,0)}static addIndex(e,t){e.addFieldInt32(4,t,0)}static addOpType(e,t){e.addFieldOffset(5,t,0)}static addType(e,t){e.addFieldInt32(6,t,s.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(e,t){e.addFieldOffset(7,t,0)}static addInputs(e,t){e.addFieldOffset(8,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(9,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addAttributes(e,t){e.addFieldOffset(10,t,0)}static createAttributesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startAttributesVector(e,t){e.startVector(4,t,4)}static addInputArgCounts(e,t){e.addFieldOffset(11,t,0)}static createInputArgCountsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addInt32(t[n]);return e.endVector()}static startInputArgCountsVector(e,t){e.startVector(4,t,4)}static addImplicitInputs(e,t){e.addFieldOffset(12,t,0)}static createImplicitInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startImplicitInputsVector(e,t){e.startVector(4,t,4)}static endNode(e){return e.endObject()}static createNode(e,t,n,r,o,c,d,g,b,v,w,x,T,S){return a.startNode(e),a.addName(e,t),a.addDocString(e,n),a.addDomain(e,r),a.addSinceVersion(e,o),a.addIndex(e,c),a.addOpType(e,d),a.addType(e,g),a.addExecutionProviderType(e,b),a.addInputs(e,v),a.addOutputs(e,w),a.addAttributes(e,x),a.addInputArgCounts(e,T),a.addImplicitInputs(e,S),a.endNode(e)}}p.Node=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsValueInfo(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsValueInfo(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(e){let t=this.bb.__offset(this.bb_pos,8);return t?(e||new s.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startValueInfo(e){e.startObject(3)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(e,t){e.addFieldOffset(2,t,0)}static endValueInfo(e){return e.endObject()}static createValueInfo(e,t,n,r){return a.startValueInfo(e),a.addName(e,t),a.addDocString(e,n),a.addType(e,r),a.endValueInfo(e)}}p.ValueInfo=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTypeInfo(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTypeInfo(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}denotation(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}valueType(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint8(this.bb_pos+e):s.experimental.fbs.TypeInfoValue.NONE}value(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__union(e,this.bb_pos+t):null}static startTypeInfo(e){e.startObject(3)}static addDenotation(e,t){e.addFieldOffset(0,t,0)}static addValueType(e,t){e.addFieldInt8(1,t,s.experimental.fbs.TypeInfoValue.NONE)}static addValue(e,t){e.addFieldOffset(2,t,0)}static endTypeInfo(e){return e.endObject()}static createTypeInfo(e,t,n,r){return a.startTypeInfo(e),a.addDenotation(e,t),a.addValueType(e,n),a.addValue(e,r),a.endTypeInfo(e)}}p.TypeInfo=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsOperatorSetId(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsOperatorSetId(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}domain(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}version(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}static startOperatorSetId(e){e.startObject(2)}static addDomain(e,t){e.addFieldOffset(0,t,0)}static addVersion(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static endOperatorSetId(e){return e.endObject()}static createOperatorSetId(e,t,n){return a.startOperatorSetId(e),a.addDomain(e,t),a.addVersion(e,n),a.endOperatorSetId(e)}}p.OperatorSetId=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensor(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensor(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}dataType(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readInt32(this.bb_pos+e):s.experimental.fbs.TensorDataType.UNDEFINED}rawData(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint8(this.bb.__vector(this.bb_pos+t)+e):0}rawDataLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}rawDataArray(){let e=this.bb.__offset(this.bb_pos,12);return e?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}stringData(e,t){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}stringDataLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}static startTensor(e){e.startObject(6)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static addDataType(e,t){e.addFieldInt32(3,t,s.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(e,t){e.addFieldOffset(4,t,0)}static createRawDataVector(e,t){e.startVector(1,t.length,1);for(let n=t.length-1;n>=0;n--)e.addInt8(t[n]);return e.endVector()}static startRawDataVector(e,t){e.startVector(1,t,1)}static addStringData(e,t){e.addFieldOffset(5,t,0)}static createStringDataVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startStringDataVector(e,t){e.startVector(4,t,4)}static endTensor(e){return e.endObject()}static createTensor(e,t,n,r,o,c,d){return a.startTensor(e),a.addName(e,t),a.addDocString(e,n),a.addDims(e,r),a.addDataType(e,o),a.addRawData(e,c),a.addStringData(e,d),a.endTensor(e)}}p.Tensor=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSparseTensor(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSparseTensor(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}values(e){let t=this.bb.__offset(this.bb_pos,4);return t?(e||new s.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}indices(e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new s.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSparseTensor(e){e.startObject(3)}static addValues(e,t){e.addFieldOffset(0,t,0)}static addIndices(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static endSparseTensor(e){return e.endObject()}static createSparseTensor(e,t,n,r){return a.startSparseTensor(e),a.addValues(e,t),a.addIndices(e,n),a.addDims(e,r),a.endSparseTensor(e)}}p.SparseTensor=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsAttribute(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAttribute(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt32(this.bb_pos+e):s.experimental.fbs.AttributeType.UNDEFINED}f(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb_pos+e):0}i(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}s(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}t(e){let t=this.bb.__offset(this.bb_pos,16);return t?(e||new s.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}g(e){let t=this.bb.__offset(this.bb_pos,18);return t?(e||new s.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}floats(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.readFloat32(this.bb.__vector(this.bb_pos+t)+4*e):0}floatsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}floatsArray(){let e=this.bb.__offset(this.bb_pos,20);return e?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}ints(e){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}intsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}strings(e,t){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}stringsLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}tensors(e,t){let n=this.bb.__offset(this.bb_pos,26);return n?(t||new s.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*e),this.bb):null}tensorsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}graphs(e,t){let n=this.bb.__offset(this.bb_pos,28);return n?(t||new s.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*e),this.bb):null}graphsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startAttribute(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(e,t){e.addFieldInt32(2,t,s.experimental.fbs.AttributeType.UNDEFINED)}static addF(e,t){e.addFieldFloat32(3,t,0)}static addI(e,t){e.addFieldInt64(4,t,e.createLong(0,0))}static addS(e,t){e.addFieldOffset(5,t,0)}static addT(e,t){e.addFieldOffset(6,t,0)}static addG(e,t){e.addFieldOffset(7,t,0)}static addFloats(e,t){e.addFieldOffset(8,t,0)}static createFloatsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addFloat32(t[n]);return e.endVector()}static startFloatsVector(e,t){e.startVector(4,t,4)}static addInts(e,t){e.addFieldOffset(9,t,0)}static createIntsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startIntsVector(e,t){e.startVector(8,t,8)}static addStrings(e,t){e.addFieldOffset(10,t,0)}static createStringsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startStringsVector(e,t){e.startVector(4,t,4)}static addTensors(e,t){e.addFieldOffset(11,t,0)}static createTensorsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startTensorsVector(e,t){e.startVector(4,t,4)}static addGraphs(e,t){e.addFieldOffset(12,t,0)}static createGraphsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startGraphsVector(e,t){e.startVector(4,t,4)}static endAttribute(e){return e.endObject()}static createAttribute(e,t,n,r,o,c,d,g,b,v,w,x,T,S){return a.startAttribute(e),a.addName(e,t),a.addDocString(e,n),a.addType(e,r),a.addF(e,o),a.addI(e,c),a.addS(e,d),a.addT(e,g),a.addG(e,b),a.addFloats(e,v),a.addInts(e,w),a.addStrings(e,x),a.addTensors(e,T),a.addGraphs(e,S),a.endAttribute(e)}}p.Attribute=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsGraph(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsGraph(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}initializers(e,t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new s.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*e),this.bb):null}initializersLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeArgs(e,t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new s.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*e),this.bb):null}nodeArgsLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}nodes(e,t){let n=this.bb.__offset(this.bb_pos,8);return n?(t||new s.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*e),this.bb):null}nodesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}maxNodeIndex(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb_pos+e):0}nodeEdges(e,t){let n=this.bb.__offset(this.bb_pos,12);return n?(t||new s.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*e),this.bb):null}nodeEdgesLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}inputs(e,t){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__vector_len(this.bb_pos+e):0}sparseInitializers(e,t){let n=this.bb.__offset(this.bb_pos,18);return n?(t||new s.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*e),this.bb):null}sparseInitializersLength(){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__vector_len(this.bb_pos+e):0}static startGraph(e){e.startObject(8)}static addInitializers(e,t){e.addFieldOffset(0,t,0)}static createInitializersVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInitializersVector(e,t){e.startVector(4,t,4)}static addNodeArgs(e,t){e.addFieldOffset(1,t,0)}static createNodeArgsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodeArgsVector(e,t){e.startVector(4,t,4)}static addNodes(e,t){e.addFieldOffset(2,t,0)}static createNodesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodesVector(e,t){e.startVector(4,t,4)}static addMaxNodeIndex(e,t){e.addFieldInt32(3,t,0)}static addNodeEdges(e,t){e.addFieldOffset(4,t,0)}static createNodeEdgesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodeEdgesVector(e,t){e.startVector(4,t,4)}static addInputs(e,t){e.addFieldOffset(5,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(6,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addSparseInitializers(e,t){e.addFieldOffset(7,t,0)}static createSparseInitializersVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startSparseInitializersVector(e,t){e.startVector(4,t,4)}static endGraph(e){return e.endObject()}static createGraph(e,t,n,r,o,c,d,g,b){return a.startGraph(e),a.addInitializers(e,t),a.addNodeArgs(e,n),a.addNodes(e,r),a.addMaxNodeIndex(e,o),a.addNodeEdges(e,c),a.addInputs(e,d),a.addOutputs(e,g),a.addSparseInitializers(e,b),a.endGraph(e)}}p.Graph=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsModel(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsModel(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}irVersion(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}opsetImport(e,t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new s.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*e),this.bb):null}opsetImportLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}producerName(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}producerVersion(e){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__string(this.bb_pos+t,e):null}modelVersion(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}docString(e){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__string(this.bb_pos+t,e):null}graph(e){let t=this.bb.__offset(this.bb_pos,18);return t?(e||new s.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}graphDocString(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__string(this.bb_pos+t,e):null}static startModel(e){e.startObject(9)}static addIrVersion(e,t){e.addFieldInt64(0,t,e.createLong(0,0))}static addOpsetImport(e,t){e.addFieldOffset(1,t,0)}static createOpsetImportVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOpsetImportVector(e,t){e.startVector(4,t,4)}static addProducerName(e,t){e.addFieldOffset(2,t,0)}static addProducerVersion(e,t){e.addFieldOffset(3,t,0)}static addDomain(e,t){e.addFieldOffset(4,t,0)}static addModelVersion(e,t){e.addFieldInt64(5,t,e.createLong(0,0))}static addDocString(e,t){e.addFieldOffset(6,t,0)}static addGraph(e,t){e.addFieldOffset(7,t,0)}static addGraphDocString(e,t){e.addFieldOffset(8,t,0)}static endModel(e){return e.endObject()}static createModel(e,t,n,r,o,c,d,g,b,v){return a.startModel(e),a.addIrVersion(e,t),a.addOpsetImport(e,n),a.addProducerName(e,r),a.addProducerVersion(e,o),a.addDomain(e,c),a.addModelVersion(e,d),a.addDocString(e,g),a.addGraph(e,b),a.addGraphDocString(e,v),a.endModel(e)}}p.Model=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsKernelCreateInfos(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsKernelCreateInfos(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}nodeIndices(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb.__vector(this.bb_pos+t)+4*e):0}nodeIndicesLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeIndicesArray(){let e=this.bb.__offset(this.bb_pos,4);return e?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}kernelDefHashes(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}kernelDefHashesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startKernelCreateInfos(e){e.startObject(2)}static addNodeIndices(e,t){e.addFieldOffset(0,t,0)}static createNodeIndicesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addInt32(t[n]);return e.endVector()}static startNodeIndicesVector(e,t){e.startVector(4,t,4)}static addKernelDefHashes(e,t){e.addFieldOffset(1,t,0)}static createKernelDefHashesVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startKernelDefHashesVector(e,t){e.startVector(8,t,8)}static endKernelCreateInfos(e){return e.endObject()}static createKernelCreateInfos(e,t,n){return a.startKernelCreateInfos(e),a.addNodeIndices(e,t),a.addKernelDefHashes(e,n),a.endKernelCreateInfos(e)}}p.KernelCreateInfos=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSubGraphSessionState(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSubGraphSessionState(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}graphId(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}sessionState(e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new s.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startSubGraphSessionState(e){e.startObject(2)}static addGraphId(e,t){e.addFieldOffset(0,t,0)}static addSessionState(e,t){e.addFieldOffset(1,t,0)}static endSubGraphSessionState(e){let t=e.endObject();return e.requiredField(t,4),t}static createSubGraphSessionState(e,t,n){return a.startSubGraphSessionState(e),a.addGraphId(e,t),a.addSessionState(e,n),a.endSubGraphSessionState(e)}}p.SubGraphSessionState=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSessionState(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSessionState(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}kernels(e){let t=this.bb.__offset(this.bb_pos,4);return t?(e||new s.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}subGraphSessionStates(e,t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new s.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*e),this.bb):null}subGraphSessionStatesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSessionState(e){e.startObject(2)}static addKernels(e,t){e.addFieldOffset(0,t,0)}static addSubGraphSessionStates(e,t){e.addFieldOffset(1,t,0)}static createSubGraphSessionStatesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startSubGraphSessionStatesVector(e,t){e.startVector(4,t,4)}static endSessionState(e){return e.endObject()}static createSessionState(e,t,n){return a.startSessionState(e),a.addKernels(e,t),a.addSubGraphSessionStates(e,n),a.endSessionState(e)}}p.SessionState=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(p){class a{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsInferenceSession(e,t){return(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsInferenceSession(e,t){return e.setPosition(e.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(t||new a).__init(e.readInt32(e.position())+e.position(),e)}static bufferHasIdentifier(e){return e.__has_identifier("ORTM")}ortVersion(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}model(e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new s.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}sessionState(e){let t=this.bb.__offset(this.bb_pos,8);return t?(e||new s.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+t),this.bb):null}static startInferenceSession(e){e.startObject(3)}static addOrtVersion(e,t){e.addFieldOffset(0,t,0)}static addModel(e,t){e.addFieldOffset(1,t,0)}static addSessionState(e,t){e.addFieldOffset(2,t,0)}static endInferenceSession(e){return e.endObject()}static finishInferenceSessionBuffer(e,t){e.finish(t,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(e,t){e.finish(t,"ORTM",!0)}static createInferenceSession(e,t,n,r){return a.startInferenceSession(e),a.addOrtVersion(e,t),a.addModel(e,n),a.addSessionState(e,r),a.endInferenceSession(e)}}p.InferenceSession=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={}))},1723:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.OnnxjsSessionHandler=void 0;const m=y(8453),h=y(9240);u.OnnxjsSessionHandler=class{constructor(f){this.session=f,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(f,s,l){const p=new Map;for(const e in f)if(Object.hasOwnProperty.call(f,e)){const t=f[e];p.set(e,new h.Tensor(t.dims,t.type,void 0,void 0,t.data))}const a=await this.session.run(p),i={};return a.forEach((e,t)=>{i[t]=new m.Tensor(e.type,e.data,e.dims)}),i}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.Session=void 0;const m=y(7067),h=y(1296),f=y(1975),s=y(6496),l=y(1315),p=y(1745);u.Session=class{constructor(a={}){this._initialized=!1,this.backendHint=a.backendHint,this.profiler=l.Profiler.create(a.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(a,i,e){await this.profiler.event("session","Session.loadModel",async()=>{const t=await(0,f.resolveBackend)(this.backendHint);if(this.sessionHandler=t.createSessionHandler(this.context),this._model=new p.Model,typeof a=="string"){const n=a.endsWith(".ort");if(typeof fetch>"u"){const r=await(0,h.promisify)(m.readFile)(a);this.initialize(r,n)}else{const r=await fetch(a),o=await r.arrayBuffer();this.initialize(new Uint8Array(o),n)}}else if(ArrayBuffer.isView(a))this.initialize(a);else{const n=new Uint8Array(a,i||0,e||a.byteLength);this.initialize(n)}})}initialize(a,i){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{const e=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(a,e,i),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new s.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(a){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{const i=this.normalizeAndValidateInputs(a),e=await this._executionPlan.execute(this.sessionHandler,i);return this.createOutput(e)})}normalizeAndValidateInputs(a){const i=this._model.graph.getInputNames();if(Array.isArray(a)){if(a.length!==i.length)throw new Error(`incorrect input array length: expected ${i.length} but got ${a.length}`)}else{if(a.size!==i.length)throw new Error(`incorrect input map size: expected ${i.length} but got ${a.size}`);const e=new Array(a.size);let t=0;for(let n=0;n<i.length;++n){const r=a.get(i[n]);if(!r)throw new Error(`missing input tensor for: '${name}'`);e[t++]=r}a=e}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,a,!1);else{const e=this._model.graph.getInputIndices(),t=this._model.graph.getValues(),n=new Array(e.length);for(let r=0;r<e.length;++r){const o=t[e[r]];n[r]=o.type.shape.dims,this.context.graphInputTypes.push(o.type.tensorType),this.context.graphInputDims.push(a[r].dims)}this.validateInputTensorDims(n,a,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,a),a}validateInputTensorTypes(a,i){for(let e=0;e<i.length;e++){const t=a[e],n=i[e].type;if(t!==n)throw new Error(`input tensor[${e}] check failed: expected type '${t}' but got ${n}`)}}validateInputTensorDims(a,i,e){for(let t=0;t<i.length;t++){const n=a[t],r=i[t].dims;if(!this.compareTensorDims(n,r,e))throw new Error(`input tensor[${t}] check failed: expected shape '[${n.join(",")}]' but got [${r.join(",")}]`)}}compareTensorDims(a,i,e){if(a.length!==i.length)return!1;for(let t=0;t<a.length;++t)if(a[t]!==i[t]&&(!e||a[t]!==0))return!1;return!0}createOutput(a){const i=this._model.graph.getOutputNames();if(a.length!==i.length)throw new Error("expected number of outputs do not match number of generated outputs");const e=new Map;for(let t=0;t<i.length;++t)e.set(i[t],a[t]);return e}initializeOps(a){const i=a.getNodes();this._ops=new Array(i.length);for(let e=0;e<i.length;e++)this._ops[e]=this.sessionHandler.resolve(i[e],this._model.opsets,a)}}},9240:function(R,u,y){var m=this&&this.__importDefault||function(o){return o&&o.__esModule?o:{default:o}};Object.defineProperty(u,"__esModule",{value:!0}),u.Tensor=void 0;const h=y(3442),f=m(y(3720)),s=y(1446),l=y(1287),p=y(7273);var a=l.onnxruntime.experimental.fbs;class i{get data(){if(this.cache===void 0){const c=this.dataProvider(this.dataId);if(c.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=c}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(c){return this.data[p.ShapeUtil.indicesToOffset(c,this.strides)]}set(c,d){this.data[p.ShapeUtil.indicesToOffset(c,this.strides)]=d}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=p.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(c,d,g,b,v,w=h.Guid.create()){this.dims=c,this.type=d,this.dataProvider=g,this.asyncDataProvider=b,this.cache=v,this.dataId=w,this.size=p.ShapeUtil.validateDimsAndCalcSize(c);const x=this.size,T=g===void 0&&b===void 0&&v===void 0;if(v!==void 0&&v.length!==x)throw new RangeError("Input dims doesn't match data length.");if(d==="string"){if(!(v===void 0||Array.isArray(v)&&v.every(S=>typeof S=="string")))throw new TypeError("cache should be a string array");T&&(this.cache=new Array(x))}else{if(v!==void 0){const S=t(d);if(!(v instanceof S))throw new TypeError(`cache should be type ${S.name}`)}if(T){const S=new ArrayBuffer(x*function(_){switch(_){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${_}`)}}(d));this.cache=function(_,A){return new(t(A))(_)}(S,d)}}}static fromProto(c){if(!c)throw new Error("cannot construct Value from an empty tensor");const d=p.ProtoUtil.tensorDataTypeFromProto(c.dataType),g=p.ProtoUtil.tensorDimsFromProto(c.dims),b=new i(g,d);if(d==="string")c.stringData.forEach((v,w)=>{b.data[w]=(0,p.decodeUtf8String)(v)});else if(c.rawData&&typeof c.rawData.byteLength=="number"&&c.rawData.byteLength>0){const v=b.data,w=new DataView(c.rawData.buffer,c.rawData.byteOffset,c.rawData.byteLength),x=e(c.dataType),T=c.rawData.byteLength/x;if(c.rawData.byteLength%x!=0)throw new Error("invalid buffer length");if(v.length!==T)throw new Error("buffer length mismatch");for(let S=0;S<T;S++){const _=r(w,c.dataType,S*x);v[S]=_}}else{let v;switch(c.dataType){case s.onnx.TensorProto.DataType.FLOAT:v=c.floatData;break;case s.onnx.TensorProto.DataType.INT32:case s.onnx.TensorProto.DataType.INT16:case s.onnx.TensorProto.DataType.UINT16:case s.onnx.TensorProto.DataType.INT8:case s.onnx.TensorProto.DataType.UINT8:case s.onnx.TensorProto.DataType.BOOL:v=c.int32Data;break;case s.onnx.TensorProto.DataType.INT64:v=c.int64Data;break;case s.onnx.TensorProto.DataType.DOUBLE:v=c.doubleData;break;case s.onnx.TensorProto.DataType.UINT32:case s.onnx.TensorProto.DataType.UINT64:v=c.uint64Data;break;default:throw new Error("unspecific error")}if(v==null)throw new Error("failed to populate data from a tensorproto value");const w=b.data;if(w.length!==v.length)throw new Error("array length mismatch");for(let x=0;x<v.length;x++){const T=v[x];f.default.isLong(T)?w[x]=n(T,c.dataType):w[x]=T}}return b}static fromData(c,d,g){return new i(d,g,void 0,void 0,c)}static fromOrtTensor(c){if(!c)throw new Error("cannot construct Value from an empty tensor");const d=p.ProtoUtil.tensorDimsFromORTFormat(c),g=p.ProtoUtil.tensorDataTypeFromProto(c.dataType()),b=new i(d,g);if(g==="string")for(let v=0;v<c.stringDataLength();v++)b.data[v]=c.stringData(v);else if(c.rawDataArray()&&typeof c.rawDataLength()=="number"&&c.rawDataLength()>0){const v=b.data,w=new DataView(c.rawDataArray().buffer,c.rawDataArray().byteOffset,c.rawDataLength()),x=e(c.dataType()),T=c.rawDataLength()/x;if(c.rawDataLength()%x!=0)throw new Error("invalid buffer length");if(v.length!==T)throw new Error("buffer length mismatch");for(let S=0;S<T;S++){const _=r(w,c.dataType(),S*x);v[S]=_}}return b}}function e(o){switch(o){case s.onnx.TensorProto.DataType.UINT8:case s.onnx.TensorProto.DataType.INT8:case s.onnx.TensorProto.DataType.BOOL:return 1;case s.onnx.TensorProto.DataType.UINT16:case s.onnx.TensorProto.DataType.INT16:return 2;case s.onnx.TensorProto.DataType.FLOAT:case s.onnx.TensorProto.DataType.INT32:case s.onnx.TensorProto.DataType.UINT32:return 4;case s.onnx.TensorProto.DataType.INT64:case s.onnx.TensorProto.DataType.DOUBLE:case s.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${s.onnx.TensorProto.DataType[o]}`)}}function t(o){switch(o){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function n(o,c){if(c===s.onnx.TensorProto.DataType.INT64||c===a.TensorDataType.INT64){if(o.greaterThanOrEqual(2147483648)||o.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(c!==s.onnx.TensorProto.DataType.UINT32&&c!==a.TensorDataType.UINT32&&c!==s.onnx.TensorProto.DataType.UINT64&&c!==a.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${s.onnx.TensorProto.DataType[c]}`);if(o.greaterThanOrEqual(4294967296)||o.lessThan(0))throw new TypeError("uint64 is not supported")}return o.toNumber()}function r(o,c,d){switch(c){case s.onnx.TensorProto.DataType.BOOL:case s.onnx.TensorProto.DataType.UINT8:return o.getUint8(d);case s.onnx.TensorProto.DataType.INT8:return o.getInt8(d);case s.onnx.TensorProto.DataType.UINT16:return o.getUint16(d,!0);case s.onnx.TensorProto.DataType.INT16:return o.getInt16(d,!0);case s.onnx.TensorProto.DataType.FLOAT:return o.getFloat32(d,!0);case s.onnx.TensorProto.DataType.INT32:return o.getInt32(d,!0);case s.onnx.TensorProto.DataType.UINT32:return o.getUint32(d,!0);case s.onnx.TensorProto.DataType.INT64:return n(f.default.fromBits(o.getUint32(d,!0),o.getUint32(d+4,!0),!1),c);case s.onnx.TensorProto.DataType.DOUBLE:return o.getFloat64(d,!0);case s.onnx.TensorProto.DataType.UINT64:return n(f.default.fromBits(o.getUint32(d,!0),o.getUint32(d+4,!0),!0),c);default:throw new Error(`cannot read from DataView for type ${s.onnx.TensorProto.DataType[c]}`)}}u.Tensor=i},7273:function(R,u,y){var m=this&&this.__importDefault||function(c){return c&&c.__esModule?c:{default:c}};Object.defineProperty(u,"__esModule",{value:!0}),u.decodeUtf8String=u.MAX_CLIP=u.MIN_CLIP=u.PoolConvUtil=u.ReduceUtil=u.SplitUtil=u.MathUtil=u.ShapeUtil=u.LongUtil=u.ProtoUtil=u.GemmUtil=u.arrayCopyHelper=u.BroadcastUtil=u.MatMulUtil=u.ArrayUtil=u.assert=u.checkInputsShape=void 0;const h=y(5686),f=m(y(3720)),s=y(1446),l=y(9240);u.checkInputsShape=function(c,...d){if(!c||c.length!==d.length)return!1;for(let g=0;g<c.length;g++)if(!c[g].dims||c[g].dims.length!==d[g])return!1;return!0},u.assert=function(c,d){if(!c)throw new Error(typeof d=="string"?d:d())},u.ArrayUtil=class{static arraysEqual(c,d){if(c.length!==d.length)return!1;for(let g=0;g<c.length;g++)if(c[g]!==d[g])return!1;return!0}};class p{static preprocessInputShapes(d,g){return[d.length===1?[1,d[0]]:d,g.length===1?[g[0],1]:g]}static postprocessOutputShape(d,g,b){g===1&&d.splice(d.length-2,1),b===1&&d.pop()}static calcMatMulShape(d,g){return d[1]!==g[0]?void 0:[d[0],g[1]]}}u.MatMulUtil=p;class a{static calcShape(d,g,b=!1){const v=d.length,w=g.length;if(v===0)return g;if(w===0)return d;const x=Math.max(d.length,g.length),T=new Array(x);if(b){if(v<2||w<2)return;const S=p.calcMatMulShape([d[v-2],d[v-1]],[g[w-2],g[w-1]]);if(S===void 0)return;[T[x-2],T[x-1]]=S}for(let S=b?3:1;S<=x;S++){const _=v-S<0?1:d[v-S],A=w-S<0?1:g[w-S];if(_!==A&&_>1&&A>1)return;T[x-S]=Math.max(_,A)}return T}static index(d,g){const b=new Array(g.length);return a.fillIndex(d,g,b),b}static fillIndex(d,g,b){const v=d.length-g.length;for(let w=0;w<g.length;w++)b[w]=d[v+w]%g[w]}static calc(d,g,b,v,w){const x=a.calcShape(d.dims,g.dims);if(x){if(v&&!t.areEqual(x,d.dims))return;const T=t.size(x),S=v?d:new l.Tensor(x,w||d.type);if(x.length===0)S.set([],b(d.get([]),g.get([])));else{const _=new Array(x.length),A=new Array(d.dims.length),E=new Array(g.dims.length);let C,D=0,$=0,L=!1,P=!1;d.dims.length===0&&(D=d.get([]),L=!0),g.dims.length===0&&($=g.get([]),P=!0);for(let k=0;k<T;k++){C=k;for(let V=x.length-1;V>=0;V--)_[V]=C%x[V],C=Math.floor(C/x[V]);L||(a.fillIndex(_,d.dims,A),D=d.get(A)),P||(a.fillIndex(_,g.dims,E),$=g.get(E)),S.set(_,b(D,$))}}return S}}static isValidBroadcast(d,g){const b=d.length,v=g.length;if(b>v)return!1;for(let w=1;w<=b;w++)if(d[b-w]!==1&&d[b-w]!==g[v-w])return!1;return!0}static getBroadcastDims(d,g){const b=d.length,v=[];for(let w=0;w<b;w++){const x=b-1-w,T=d[x]||1;(g[g.length-1-w]||1)>1&&T===1&&v.unshift(x)}return v}}u.BroadcastUtil=a,u.arrayCopyHelper=function(c,d,g,b,v){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=c.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>c.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)c[g+w]=d[b+w]},u.GemmUtil=class{static getShapeOfGemmResult(c,d,g,b,v){if(c.length!==2||g.length!==2)throw new Error("shape need to be of size 2");let w,x,T;d?(w=c[1],x=c[0]):(w=c[0],x=c[1]);let S=-1;if(b?(T=g[0],S=1):(T=g[1],S=0),g[S]!==x)throw new Error("dimension mismatch");if(w<=0||T<=0||x<=0)throw new Error("invalid shape specified");if(v&&!a.isValidBroadcast(v,[w,T]))throw new Error("gemm: invalid bias shape for broadcast");return[w,T,x]}};class i{static tensorDataTypeFromProto(d){switch(d){case s.onnx.TensorProto.DataType.INT8:return"int8";case s.onnx.TensorProto.DataType.UINT8:return"uint8";case s.onnx.TensorProto.DataType.BOOL:return"bool";case s.onnx.TensorProto.DataType.INT16:return"int16";case s.onnx.TensorProto.DataType.UINT16:return"uint16";case s.onnx.TensorProto.DataType.INT32:return"int32";case s.onnx.TensorProto.DataType.UINT32:return"uint32";case s.onnx.TensorProto.DataType.FLOAT:return"float32";case s.onnx.TensorProto.DataType.DOUBLE:return"float64";case s.onnx.TensorProto.DataType.STRING:return"string";case s.onnx.TensorProto.DataType.INT64:return"int32";case s.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${s.onnx.TensorProto.DataType[d]}`)}}static tensorDataTypeStringToEnum(d){switch(d){case"int8":return s.onnx.TensorProto.DataType.INT8;case"uint8":return s.onnx.TensorProto.DataType.UINT8;case"bool":return s.onnx.TensorProto.DataType.BOOL;case"int16":return s.onnx.TensorProto.DataType.INT16;case"uint16":return s.onnx.TensorProto.DataType.UINT16;case"int32":return s.onnx.TensorProto.DataType.INT32;case"uint32":return s.onnx.TensorProto.DataType.UINT32;case"float32":return s.onnx.TensorProto.DataType.FLOAT;case"float64":return s.onnx.TensorProto.DataType.DOUBLE;case"string":return s.onnx.TensorProto.DataType.STRING;case"int64":return s.onnx.TensorProto.DataType.INT64;case"uint64":return s.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${d}`)}}static tensorDimsFromProto(d){return d.map(g=>f.default.isLong(g)?g.toNumber():g)}static tensorValueTypeFromProto(d){return{tensorType:i.tensorDataTypeFromProto(d.elemType),shape:{dims:i.tensorDimsFromProto(d.shape.dim.map(g=>g.dimValue))}}}static tensorDimsFromORTFormat(d){const g=[];for(let b=0;b<d.dimsLength();b++)g.push(e.longToNumber(d.dims(b)));return g}static tensorAttributesFromORTFormat(d){const g=[];for(let b=0;b<d.attributesLength();b++)g.push(d.attributes(b));return g}}u.ProtoUtil=i;class e{static longToNumber(d,g){return f.default.isLong(d)?d.toNumber():d instanceof h.flatbuffers.Long?f.default.fromValue({low:d.low,high:d.high,unsigned:g!=null&&g}).toNumber():d}static isLong(d){return f.default.isLong(d)||d instanceof h.flatbuffers.Long}}u.LongUtil=e;class t{static size(d){return t.getSizeFromDimensionRange(d,0,d.length)}static sizeFromDimension(d,g){if(g<0||g>d.length)throw new Error(`invalid dimension of ${g} for sizeFromDimension as Tensor has ${d.length} dimensions.`);return t.getSizeFromDimensionRange(d,g,d.length)}static sizeToDimension(d,g){if(g<0||g>d.length)throw new Error(`invalid dimension of ${g} for sizeToDimension as Tensor has ${d.length} dimensions.`);return t.getSizeFromDimensionRange(d,0,g)}static getSizeFromDimensionRange(d,g,b){let v=1;for(let w=g;w<b;w++){if(d[w]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");v*=d[w]}return v}static computeStrides(d){const g=d.length;if(g===0)return[];if(g===1)return[1];const b=new Array(g);b[g-1]=1,b[g-2]=d[g-1];for(let v=g-3;v>=0;--v)b[v]=b[v+1]*d[v+1];return b}static transpose(d){return d.slice().reverse()}static indicesToOffset(d,g,b){b===void 0&&(b=d.length);let v=0;for(let w=0;w<b;++w)v+=g[w]*d[w];return v}static offsetToIndices(d,g){const b=g.length;if(b===0)return[];if(b===1)return[d*g[0]];const v=new Array(g.length);for(let w=0;w<v.length-1;++w)v[w]=Math.floor(d/g[w]),d-=v[w]*g[w];return v[v.length-1]=d,v}static normalizeAxis(d,g){if(d<-g&&d>=g)throw new Error("unsupported axis for this operation.");return d<0?d+g:d}static normalizeAxes(d,g){return d.map(b=>this.normalizeAxis(b,g))}static incrementIndex(d,g,b){if(g.length===0||d.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(b===void 0)b=g.length;else if(b<=0||b>g.length)throw new Error("Incorrect axis to increment on");for(let v=b-1;v>=0&&(d[v]++,!(d[v]<g[v]));--v)d[v]=0}static calculateReshapedDims(d,g){if(g.length===0){if(d.length===0||t.size(d)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const b=g.length,v=new Array(b);let w=-1,x=1;for(let S=0;S<b;S++){if(g[S]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(g[S]===-1){if(w!==-1)throw new Error("at most one dimension in shape hints can be -1");w=S}else{if(g[S]===0){if(S>=d.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");v[S]=d[S]}else v[S]=g[S];x*=v[S]}}const T=t.size(d);if(w!==-1){if(T%x!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${d}] Output shape: [${g}]`);v[w]=T/x}else if(x!==T)throw new Error("reshapedDims and originalDims don't have matching sizes");return v}static sortBasedOnPerm(d,g){return g?g.map(b=>d[b]):d.slice().reverse()}static padShape(d,g){const b=d.length;return d.map((v,w)=>v+g[w]+g[w+b])}static areEqual(d,g){return d.length===g.length&&d.every((b,v)=>b===g[v])}static validateDimsAndCalcSize(d){if(d.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let g=1;for(const b of d){if(!Number.isInteger(b))throw new TypeError(`Invalid shape: ${b} is not an integer`);if(b<0||b>2147483647)throw new TypeError(`Invalid shape: length ${b} is not allowed`);g*=b}return g}static flattenShape(d,g){g<0&&(g+=d.length);const b=d.reduce((w,x)=>w*x,1),v=d.slice(g).reduce((w,x)=>w*x,1);return[b/v,v]}static squeezeShape(d,g){const b=new Array;g=t.normalizeAxes(g,d.length);for(let v=0;v<d.length;v++){const w=g.indexOf(v)>=0;if(w&&d[v]!==1)throw new Error("squeeze an axis of size different than 1");(g.length===0&&d[v]>1||g.length>0&&!w)&&b.push(d[v])}return b}static unsqueezeShape(d,g){const b=new Array(d.length+g.length);b.fill(0);for(let w=0;w<g.length;w++){const x=t.normalizeAxis(g[w],b.length);if(x>=b.length)throw new Error("'axes' has an out of range axis");if(b[x]!==0)throw new Error("'axes' has a duplicate axis");b[x]=1}let v=0;for(let w=0;w<b.length;w++)b[w]===0&&(b[w]=d[v++]);if(v!==d.length)throw new Error("the unsqueezed dimension could not be established");return b}}u.ShapeUtil=t,u.MathUtil=class{static sqr(c,d,g,b,v){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=c.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>c.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)c[g+w]+=Math.pow(d[b+w],2)}static axpy(c,d,g,b,v,w){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=c.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>c.length)throw new Error("target array is too small to hold result");for(let x=0;x<v;x++)c[g+x]+=w*d[b+x]}static powx(c,d,g,b,v,w){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=c.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>c.length)throw new Error("target array is too small to hold result");for(let x=0;x<v;x++)c[g+x]=Math.pow(d[b+x],w)}static mul(c,d,g,b,v){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=c.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>c.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)c[g+w]=d[b+w]*c[g+w]}};class n{static splitShape(d,g,b,v){if(b.length===0){if(!v)throw new Error("need to know number of outputs when the 'split' attribute is not specified");n.determineSplit(d[g],v,b)}const w=[],x=[0];for(let T=0;T<b.length;++T){T!==0&&x.push(x[T-1]+b[T-1]);const S=d.slice();S[g]=b[T],w.push(S)}return[w,x]}static determineSplit(d,g,b){if(d%g!=0)throw new Error("cannot split tensor to equal sized parts");for(let v=0;v<g;++v)b.push(d/g)}}u.SplitUtil=n;class r{static calcReduce(d,g,b,v,w){const x=d.dims.slice(0);g.length===0&&x.forEach((D,$)=>g.push($));const T=r.calcReduceShape(x,g,!0),S=t.size(T),_=new l.Tensor(T,d.type),A=t.computeStrides(T),E=t.computeStrides(x),C=new Array(x.length);for(let D=0;D<S;D++){const $=t.offsetToIndices(D,A);a.fillIndex($,x,C),_.set($,r.calcReduceByAxis(d.numberData,g,x,0,t.indicesToOffset(C,E),v,w))}return b?_:new l.Tensor(r.calcReduceShape(x,g,b),_.type,void 0,void 0,_.data,_.dataId)}static calcReduceByAxis(d,g,b,v,w,x,T){let S=0;if(v>=g.length)return x(d[w]);const _=g[v],A=_>=b.length?1:t.size(b.slice(_+1));for(let E=0;E<b[_];E++)S=E===0?r.calcReduceByAxis(d,g,b,v+1,w,x,T):T(S,r.calcReduceByAxis(d,g,b,v+1,w,x,T)),w+=A;return S}static calcReduceShape(d,g,b){const v=d.slice();for(let w=0;w<g.length;w++)v[g[w]]=b?1:0;return v.filter(w=>w!==0)}}u.ReduceUtil=r;class o{static adjustPoolAttributes(d,g,b,v,w,x){if(!d&&b.length!==g.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(d)for(let T=0;T<g.length-2;T++)T>=b.length?b.push(g[T+2]):b[T]=g[T+2];for(let T=0;T<b.length;T++)if(T<v.length){if(v[T]<0)throw new Error("strides should be greater than or equal to 1")}else v.push(1);for(let T=0;T<b.length;T++)if(T<w.length){if(w[T]<0)throw new Error("dilations should be greater than or equal to 1")}else w.push(1);for(let T=0;T<2*b.length;T++)if(T<x.length){if(x[T]<0)throw new Error("pad should be greater than or equal to 1")}else x.push(0);for(let T=0;T<b.length;T++){if(b[T]<=0)throw new Error("kernel shapes need to be greater than 0");if(x[T]>=b[T]||x[T+b.length]>=b[T])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(d,g,b,v,w,x){if(x){if(w.length!==2*(d.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(g.length!==d.length-2)throw new Error("length of strides should be the length of data dimensions");if(v.length!==d.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let T=0;T<d.length-2;T++)o.adjustPadAndReturnShape(d[T+2],g[T],b[T],v[T],w,T,T+d.length-2,x)}}static computePoolOutputShape(d,g,b,v,w,x,T){if(g.length<=0)throw new Error("input shape must be of size greater than 0");const S=[g[0],g[1]];return o.computeShapeHelper(d,g,S,b,v,w,x,T),S}static computeConvOutputShape(d,g,b,v,w,x,T){if(d.length<=0||g.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const S=[d[0],g[0]];return o.computeShapeHelper(!1,d,S,b,v,w,x,T),S}static computeShapeHelper(d,g,b,v,w,x,T,S){if(d)for(let _=0;_<g.length-2;_++)b.push(1);else for(let _=0;_<g.length-2;_++)b.push(o.adjustPadAndReturnShape(g[_+2],v[_],w[_],x[_],T,_,_+g.length-2,S))}static adjustPadAndReturnShape(d,g,b,v,w,x,T,S){const _=b*(v-1)+1;if(!S||S==="NOTSET")return Math.floor((d+w[x]+w[T]-_)/g+1);switch(S){case"VALID":return w[x]=0,w[T]=0,Math.floor((d-_)/g+1);case"SAME_LOWER":case"SAME_UPPER":if(b!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const A=((d+g-1)/g-1)*g+v-d;return w[x]=Math.floor(S==="SAME_LOWER"?(A+1)/2:A/2),w[T]=A-w[x],Math.floor((d+A-v)/g+1)}default:throw new Error("Unsupported AutoPad type")}}}u.PoolConvUtil=o,u.MIN_CLIP=-34028234663852886e22,u.MAX_CLIP=34028234663852886e22,u.decodeUtf8String=function(c){return new TextDecoder().decode(c)}},3838:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.WebGpuBackend=void 0;const m=y(8453),h=y(4955),f=y(7771),s=y(8510),l=y(8305);u.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.profilingEnabled=!1}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let p=this.kernelCustomData.get(this.currentKernelId);return p||(p={},this.kernelCustomData.set(this.currentKernelId,p)),p}async initialize(){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");const p=await navigator.gpu.requestAdapter();if(!p)throw new Error("WebGpuBackend: Failed to get GPU adapter.");const a={requiredLimits:{maxComputeWorkgroupStorageSize:p.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:p.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:p.limits.maxStorageBufferBindingSize}};p.features.has("timestamp-query-inside-passes")&&m.env.webgpu.profilingMode==="default"&&(this.profilingEnabled=!0,a.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await p.requestDevice(a),this.gpuDataManager=(0,f.createGpuDataManager)(this),this.programManager=new l.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,this.device.onuncapturederror=i=>{i.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${i.error.message}`)},this.profilingEnabled&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(p,a,i,e,t){if(a.length!==p.inputTypes.length)throw new Error(`Input size must be equal to ${p.inputTypes.length}.`);const n=[];for(let w=0;w<a.length;++w){const x=this.gpuDataManager.get(a[w].data);if(!x)throw new Error(`no GPU data for input: ${a[w].data}`);n[w]=x}const r=((w,x,T)=>{const S=x.map(E=>`${E.join(",")}`).join("_"),_=T.join("_");let A=w.name;return w.cacheHint&&(A+="["+w.cacheHint+"]"),A+=":"+S+";"+_,A})(p,a.map(w=>w.dims),n.map(w=>w.type));let o=this.programManager.getArtifact(r);const c=o?o.programInfo:typeof p.get=="function"?p.get():p,d=i.length===0?c.outputs.map((w,x)=>x):i;if(d.length!==c.outputs.length)throw new Error(`Output size ${d.length} must be equal to ${c.outputs.length}.`);const g=[],b=[];for(let w=0;w<c.outputs.length;++w){if(!Number.isInteger(d[w])||d[w]<-2||d[w]>=c.outputs.length)throw new Error(`Invalid output index: ${d[w]}`);const x=d[w]===-1,T=d[w]===-2,S=x||T?t(c.outputs[w].dataType,c.outputs[w].dims):e(d[w],c.outputs[w].dataType,c.outputs[w].dims),_=this.gpuDataManager.get(S.data);if(!_)throw new Error(`no GPU data for output: ${S.data}`);if(x&&this.temporaryData.push(_),T){let A=this.kernelPersistentData.get(this.currentKernelId);A||(A=[],this.kernelPersistentData.set(this.currentKernelId,A)),A.push(_)}g.push(S),b.push(_)}const v=this.programManager.normalizeDispatchGroupSize(c.dispatchGroup(a));return o||(o=this.programManager.build(c,v),this.programManager.setArtifact(r,o)),(0,h.LOG_DEBUG)("info",()=>`[ProgramManager] run "${c.name}" (key=${r}) with ${v[0]}x${v[1]}x${v[2]}`),this.programManager.run(o,n,b,v),g}upload(p,a){this.gpuDataManager.upload(p,a)}memcpy(p,a){this.gpuDataManager.memcpy(p,a)}async download(p,a){const i=await this.gpuDataManager.download(p);a().set(new Uint8Array(i))}alloc(p){return this.gpuDataManager.create(p).id}free(p){return this.gpuDataManager.release(p)}createKernel(p,a,i){const e=s.WEBGPU_OP_RESOLVE_RULES.get(p);if(!e)throw new Error(`kernel not implemented: ${p}`);this.kernels.set(a,[p,e[0],[e[1],i]])}releaseKernel(p){const a=this.kernelPersistentData.get(p);if(a){for(const i of a)this.gpuDataManager.release(i.id);this.kernelPersistentData.delete(p)}this.kernelCustomData.delete(p),this.kernels.delete(p)}computeKernel(p,a){const i=this.kernels.get(p);if(!i)throw new Error(`kernel not created: ${p}`);const[e,t,n]=i;if(this.currentKernelId!==null)throw new Error(`kernel "${e}" is not allowed to be called recursively`);this.currentKernelId=p,n[0]&&(n[1]=n[0](n[1]),n[0]=void 0),(0,h.LOG_DEBUG)("info",()=>`[WebGPU] Start to run kernel "${e}"...`),this.temporaryData=[];try{return t(a,n[1]),0}catch(r){return(0,h.LOG_DEBUG)("warning",`[WebGPU] Kernel "${e}" failed. Error: ${r}`),1}finally{for(const r of this.temporaryData)this.gpuDataManager.release(r.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.init=void 0;const m=y(7917),h=y(3838),f=y(4955),s=y(6952);class l{constructor(i,e,t,n){this.module=i,this.dataType=e,this.data=t,this.dims=n}getFloat32Array(){return new Float32Array(this.module.HEAP8.buffer,this.data,s.ShapeUtil.size(this.dims))}reshape(i){if(s.ShapeUtil.size(i)!==s.ShapeUtil.size(this.dims))throw new Error("Invalid new shape");return new l(this.module,this.dataType,this.data,i)}}class p{get customData(){return this.backend.currentKernelCustomData}constructor(i,e,t){this.module=i,this.backend=e;const n=i.HEAPU32;let r=t>>2;this.opKernelContext=n[r++];const o=n[r++],c=[];for(let d=0;d<o;d++){const g=n[r++],b=n[r++],v=n[r++],w=[];for(let x=0;x<v;x++)w.push(n[r++]);c.push(new l(i,g,b,w))}this.inputs=c}compute(i,e){var t,n,r;const o=(n=(t=e==null?void 0:e.inputs)===null||t===void 0?void 0:t.map(d=>typeof d=="number"?this.inputs[d]:d))!==null&&n!==void 0?n:this.inputs,c=(r=e==null?void 0:e.outputs)!==null&&r!==void 0?r:[];return this.backend.run(i,o,c,(d,g,b)=>new l(this.module,g,this.output(d,b),b),(d,g)=>{const b=(0,m.getTensorElementSize)(d);if(!b)throw new Error(`Unsupported data type: ${d}`);const v=b*s.ShapeUtil.size(g);return new l(this.module,d,this.backend.gpuDataManager.create(v).id,g)})}output(i,e){const t=this.module.stackSave();try{const n=this.module.stackAlloc(4*(1+e.length));let r=n>>2;this.module.HEAPU32[r++]=e.length;for(let o=0;o<e.length;o++)this.module.HEAPU32[r++]=e[o];return this.module._JsepOutput(this.opKernelContext,i,n)}finally{this.module.stackRestore(t)}}}u.init=async a=>{const i=a.jsepInit;if(i&&navigator.gpu){const e=new h.WebGpuBackend;await e.initialize(),i({backend:e},t=>e.alloc(t),t=>e.free(t),(t,n,r,o=!1)=>{if(o)(0,f.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${t}, dst=${n}, size=${r}`),e.memcpy(t,n);else{(0,f.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${t}, gpuDataId=${n}, size=${r}`);const c=a.HEAPU8.subarray(t,t+r);e.upload(n,c)}},async(t,n,r)=>{(0,f.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t}, dataOffset=${n}, size=${r}`),await e.download(t,()=>a.HEAPU8.subarray(n,n+r))},(t,n,r)=>e.createKernel(t,n,r),t=>e.releaseKernel(t),(t,n)=>{(0,f.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepRun: kernel=${t}, contextDataOffset=${n}`);const r=new p(a,e,n);return e.computeKernel(t,r)})}}},4955:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.LOG_DEBUG=u.LOG=void 0;const m=y(8453),h=y(7917),f=["V","I","W","E","F"];u.LOG=(s,l)=>{const p=(0,h.logLevelStringToEnum)(s);var a,i;p>=(0,h.logLevelStringToEnum)(m.env.logLevel)&&(a=p,i=typeof l=="function"?l():l,console.log(`[${f[a]},${new Date().toISOString()}]${i}`))},u.LOG_DEBUG=(...s)=>{m.env.debug&&(0,u.LOG)(...s)}},6952:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.MAX_CLIP=u.MIN_CLIP=u.GemmUtil=u.PoolConvUtil=u.ShapeUtil=u.BroadcastUtil=u.MatMulUtil=void 0;class y{static calcMatMulShape(l,p){return l[1]!==p[0]?void 0:[l[0],p[1]]}}u.MatMulUtil=y;class m{static calcShape(l,p,a=!1){const i=l.length,e=p.length;if(i===0)return p;if(e===0)return l;const t=Math.max(l.length,p.length),n=new Array(t);if(a){if(i<2||e<2)return;const r=y.calcMatMulShape([l[i-2],l[i-1]],[p[e-2],p[e-1]]);if(r===void 0)return;[n[t-2],n[t-1]]=r}for(let r=a?3:1;r<=t;r++){const o=i-r<0?1:l[i-r],c=e-r<0?1:p[e-r];if(o!==c&&o>1&&c>1)return;n[t-r]=Math.max(o,c)}return n}static isValidBroadcast(l,p){const a=l.length,i=p.length;if(a>i)return!1;for(let e=1;e<=a;e++)if(l[a-e]!==1&&l[a-e]!==p[i-e])return!1;return!0}}u.BroadcastUtil=m;class h{static size(l){return h.getSizeFromDimensionRange(l,0,l.length)}static sizeFromDimension(l,p){if(p<0||p>l.length)throw new Error(`invalid dimension of ${p} for sizeFromDimension as Tensor has ${l.length} dimensions.`);return h.getSizeFromDimensionRange(l,p,l.length)}static sizeToDimension(l,p){if(p<0||p>l.length)throw new Error(`invalid dimension of ${p} for sizeToDimension as Tensor has ${l.length} dimensions.`);return h.getSizeFromDimensionRange(l,0,p)}static getSizeFromDimensionRange(l,p,a){let i=1;for(let e=p;e<a;e++){if(l[e]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");i*=l[e]}return i}static computeStrides(l){const p=l.length;if(p===0)return[];if(p===1)return[1];const a=new Array(p);a[p-1]=1,a[p-2]=l[p-1];for(let i=p-3;i>=0;--i)a[i]=a[i+1]*l[i+1];return a}static normalizeAxis(l,p){if(l<-p&&l>=p)throw new Error("unsupported axis for this operation.");return l<0?l+p:l}static normalizeAxes(l,p){return l.map(a=>this.normalizeAxis(a,p??l.length))}static sortBasedOnPerm(l,p){return p?p.map(a=>l[a]):l.slice().reverse()}static padShape(l,p){const a=l.length;return l.map((i,e)=>i+p[e]+p[e+a])}static areEqual(l,p){return l.length===p.length&&l.every((a,i)=>a===p[i])}}u.ShapeUtil=h;class f{static adjustPoolAttributes(l,p,a,i,e,t){if(!l&&a.length!==p.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(l)for(let n=0;n<p.length-2;n++)n>=a.length?a.push(p[n+2]):a[n]=p[n+2];for(let n=0;n<a.length;n++)if(n<i.length){if(i[n]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let n=0;n<a.length;n++)if(n<e.length){if(e[n]<0)throw new Error("dilations should be greater than or equal to 1")}else e.push(1);for(let n=0;n<2*a.length;n++)if(n<t.length){if(t[n]<0)throw new Error("pad should be greater than or equal to 1")}else t.push(0);for(let n=0;n<a.length;n++){if(a[n]<=0)throw new Error("kernel shapes need to be greater than 0");if(t[n]>=a[n]||t[n+a.length]>=a[n])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(l,p,a,i,e,t,n){if(n){if(e.length!==2*(l.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(p.length!==l.length-2)throw new Error("length of strides should be the length of data dimensions");if(i.length!==l.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let r=0;r<l.length-2;r++)f.adjustPadAndReturnShape(l[r+(t?1:2)],p[r],a[r],i[r],e,r,r+l.length-2,n)}}static computePoolOutputShape(l,p,a,i,e,t,n){if(p.length<=0)throw new Error("input shape must be of size greater than 0");const r=[p[0],p[1]];return f.computeShapeHelper(l,p,r,a,i,e,t,n),r}static computeConvOutputShape(l,p,a,i,e,t,n){if(l.length<=0||p.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const r=[l[0],p[0]];return f.computeShapeHelper(!1,l,r,a,i,e,t,n),r}static computeShapeHelper(l,p,a,i,e,t,n,r){if(l)for(let o=0;o<p.length-2;o++)a.push(1);else for(let o=0;o<p.length-2;o++)a.push(f.adjustPadAndReturnShape(p[o+2],i[o],e[o],t[o],n,o,o+p.length-2,r))}static adjustPadAndReturnShape(l,p,a,i,e,t,n,r){const o=a*(i-1)+1;if(!r||r==="NOTSET")return Math.floor((l+e[t]+e[n]-o)/p+1);switch(r){case"VALID":return e[t]=0,e[n]=0,Math.floor((l-o)/p+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const c=((l+p-1)/p-1)*p+i-l;return e[t]=Math.floor(r==="SAME_LOWER"?(c+1)/2:c/2),e[n]=c-e[t],Math.floor((l+c-i)/p+1)}default:throw new Error("Unsupported AutoPad type")}}}u.PoolConvUtil=f,u.GemmUtil=class{static getShapeOfGemmResult(s,l,p,a,i){if(s.length!==2||p.length!==2)throw new Error("shape need to be of size 2");let e,t,n;l?(e=s[1],t=s[0]):(e=s[0],t=s[1]);let r=-1;if(a?(n=p[0],r=1):(n=p[1],r=0),p[r]!==t)throw new Error("dimension mismatch");if(e<=0||n<=0||t<=0)throw new Error("invalid shape specified");if(i&&!m.isValidBroadcast(i,[e,n]))throw new Error("gemm: invalid bias shape for broadcast");return[e,n,t]}},u.MIN_CLIP=-34028234663852886e22,u.MAX_CLIP=34028234663852886e22},387:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createAttributeWithCacheKey=void 0;class y{constructor(h){Object.assign(this,h)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(h=>`${this[h]}`).join(";")),this._cacheKey}}u.createAttributeWithCacheKey=m=>new y(m)},7771:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createGpuDataManager=void 0;const m=y(4955),h=y(1163),f=p=>16*Math.ceil(p/16);let s=0;class l{constructor(a){this.backend=a,this.storageCache=new Map,this.downloadCache=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(a,i){const e=i.buffer,t=i.byteOffset,n=i.byteLength,r=f(n),o=this.storageCache.get(a);if(!o)throw new Error("gpu data for uploading does not exist");if(o.originalSize!==n)throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${n}`);const c=this.backend.device.createBuffer({mappedAtCreation:!0,size:r,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),d=c.getMappedRange();new Uint8Array(d).set(new Uint8Array(e,t,n)),c.unmap();const g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(c,0,o.gpuData.buffer,0,r),(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${a})`),this.buffersForUploadingPending.push(c)}memcpy(a,i){const e=this.storageCache.get(a);if(!e)throw new Error("source gpu data for memcpy does not exist");const t=this.storageCache.get(i);if(!t)throw new Error("destination gpu data for memcpy does not exist");if(e.originalSize!==t.originalSize)throw new Error("inconsistent source and destination gpu data size");const n=f(e.originalSize);this.backend.getCommandEncoder().copyBufferToBuffer(e.gpuData.buffer,0,t.gpuData.buffer,0,n)}create(a,i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const e=f(a),t=this.backend.device.createBuffer({size:e,usage:i}),n={id:s++,type:h.GpuDataType.default,buffer:t};return this.storageCache.set(n.id,{gpuData:n,originalSize:a}),(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.create(size=${a}) => id=${n.id}`),n}get(a){var i;return(i=this.storageCache.get(a))===null||i===void 0?void 0:i.gpuData}release(a){const i=this.storageCache.get(a);if(!i)throw new Error("releasing data does not exist");return(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.release(id=${a}), gpuDataId=${i.gpuData.id}`),this.storageCache.delete(a),this.buffersPending.push(i.gpuData.buffer),this.downloadCache.get(a)&&this.downloadCache.delete(a),i.originalSize}async download(a){const i=this.downloadCache.get(a);if(i)return i.data;const e=this.storageCache.get(a);if(!e)throw new Error("data does not exist");const t=this.backend.getCommandEncoder();this.backend.endComputePass();const n=this.backend.device.createBuffer({size:e.originalSize,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});t.copyBufferToBuffer(e.gpuData.buffer,0,n,0,e.originalSize),this.backend.flush();const r=new Promise(o=>{n.mapAsync(GPUMapMode.READ).then(()=>{const c=n.getMappedRange().slice(0);n.destroy(),o(c)})});return this.downloadCache.set(a,{data:r}),r}refreshPendingBuffers(){for(const a of this.buffersForUploadingPending)a.destroy();for(const a of this.buffersPending)a.destroy()}}u.createGpuDataManager=(...p)=>new l(...p)},8510:function(R,u,y){var m=this&&this.__createBinding||(Object.create?function(n,r,o,c){c===void 0&&(c=o);var d=Object.getOwnPropertyDescriptor(r,o);d&&!("get"in d?!r.__esModule:d.writable||d.configurable)||(d={enumerable:!0,get:function(){return r[o]}}),Object.defineProperty(n,c,d)}:function(n,r,o,c){c===void 0&&(c=o),n[c]=r[o]}),h=this&&this.__setModuleDefault||(Object.create?function(n,r){Object.defineProperty(n,"default",{enumerable:!0,value:r})}:function(n,r){n.default=r}),f=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var r={};if(n!=null)for(var o in n)o!=="default"&&Object.prototype.hasOwnProperty.call(n,o)&&m(r,n,o);return h(r,n),r};Object.defineProperty(u,"__esModule",{value:!0}),u.WEBGPU_OP_RESOLVE_RULES=void 0;const s=f(y(504)),l=y(9770),p=y(4271),a=y(1522),i=f(y(5262)),e=y(2625),t=f(y(9302));u.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[t.abs]],["Acos",[t.acos]],["Acosh",[t.acosh]],["Add",[s.add]],["Asin",[t.asin]],["Asinh",[t.asinh]],["Atan",[t.atan]],["Atanh",[t.atanh]],["AveragePool",[i.averagePool,i.parseAveragePoolAttributes]],["Ceil",[t.ceil]],["ClipV10",[t.clipV10]],["Clip",[t.clip]],["Conv",[l.conv,l.parseConvAttributes]],["Cos",[t.cos]],["Cosh",[t.cosh]],["Div",[s.div]],["Elu",[t.elu,t.parseAlphaAttributes]],["Erf",[t.erf]],["Exp",[t.exp]],["Floor",[t.floor]],["Gemm",[p.gemm,p.parseGemmAttributes]],["GlobalAveragePool",[i.globalAveragePool,i.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[i.globalMaxPool,i.parseGlobalMaxPoolAttributes]],["LeakyRelu",[t.leakyRelu,t.parseAlphaAttributes]],["MatMul",[a.matMul]],["MaxPool",[i.maxPool,i.parseMaxPoolAttributes]],["Mul",[s.mul]],["Neg",[t.neg]],["Pow",[s.pow]],["Reciprocal",[t.reciprocal]],["Relu",[t.relu]],["Sigmoid",[t.sigmoid]],["Sin",[t.sin]],["Sinh",[t.sinh]],["Sqrt",[t.sqrt]],["Sub",[s.sub]],["Tan",[t.tan]],["Tanh",[t.tanh]],["ThresholdedRelu",[t.thresholdedRelu,t.parseAlphaAttributes]],["Transpose",[e.transpose,e.parseTransposeAttributes]]])},1427:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.biasActivationSnippet=u.activationFnSnippet=u.typeSnippet=void 0,u.typeSnippet=y=>{switch(y){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${y}-component is not supported.`)}},u.activationFnSnippet=(y,m=!1,h=!1,f=3)=>"",u.biasActivationSnippet=(y,m)=>`
      ${y?"value = value + getBiasByOutputCoords(coords);":""}
      ${m?"value = activation(value, coords);":""}
      `},9456:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createConv2DMatMulProgramInfo=void 0;const m=y(4955),h=y(6952),f=y(1163),s=y(1427),l=y(4085),p=y(158);u.createConv2DMatMulProgramInfo=(a,i,e,t,n,r,o,c,d)=>{const g=e.format==="NHWC",b=g?a[0].dims[3]:a[0].dims[1],v=t[0],w=g?t[2]:t[3],x=g?t[1]:t[2],T=g?t[3]:t[1],S=((b%4==0||b%3==0)&&g||w%4==0&&!g)&&T%4==0,_=g?T:w*x,A=g?w*x:T,E=S?[8,8,1]:[_<=4?4:16,_>4&&A<=4?4:16,1],C=S?[4,4,1]:[_<=4?1:2,_>4&&A<=4?1:2,1],D=[Math.ceil(_/E[0]/C[0]),Math.ceil(A/E[1]/C[1]),Math.ceil(v/E[2]/C[1])];(0,m.LOG_DEBUG)("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${D}`);const $=S?g&&b%4!=0?3:4:C[0],L=E[1]*C[1],P=E[0]*C[0],k=Math.max(E[0]*$,E[1]),V=n%L==0,z=r%P==0,J=o%k==0,q=S?[$,4,4]:[1,1,1],tt=[`@group(0) @binding(0) var<storage, read> x: array<${S&&$===4?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${S?"vec4<f32>":"f32"}>;`];let rt=`
      fn setOutputAtIndex(flatIndex : i32, value : ${S?"vec4<f32>":"f32"}) {
        result[flatIndex] = ${S?"vec4<f32>":"f32"}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${S?"vec4<f32>":"f32"}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${S?"/ 4":""}, value);
      }`;return c&&(tt.push(`@group(0) @binding(2) var<storage, read> bias: array<${S?"vec4<f32>":"f32"}>;`),rt+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${S?"vec4<f32>":"f32"} {
          return bias[coords.${g?"w":"y"}${S?"/ 4":""}];
        }`),Object.assign(Object.assign({},i),{outputs:[{dims:t,dataType:a[0].dataType,gpuDataType:f.GpuDataType.default}],dispatchGroup:()=>({x:D[0],y:D[1],z:D[2]}),getShaderSource:()=>`
        ${l.utilFunctions}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${tt.join("")}
        @group(0) @binding(${tt.length}) var<storage, read_write> result: array<${S?"vec4<f32>":"f32"}>;
        //@group(0) @binding(${tt.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${a[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${a[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${t.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${h.ShapeUtil.computeStrides(t).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[0]}, ${e.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${e.pads[0]}, ${e.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});
        const dimAOuter : i32 = ${n};
        const dimBOuter : i32 = ${r};
        const dimInner : i32 = ${o};
        ${rt}
        ${((Z,at,st,et,dt=!1,nt,gt=!1,ct=4,mt=4,ut=4)=>{const wt=Z?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,Et=Z?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,kt=Z?"xShape[1]":"xShape[2]",Ct=Z?"xShape[2]":"xShape[3]",Rt=Z?"row":"col",Mt=Z?"col":"row",bt=`
    let inChannels = wShape[2];
    let outWidth = ${Z?"outShape[2]":"outShape[3]"};
    let outRow = ${Rt} / outWidth;
    let outCol = ${Rt} % outWidth;

    let WRow = ${Mt} / (filterDims[1] * inChannels);
    let WCol = ${Mt} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${Mt} % inChannels;
    var resData = ${(0,s.typeSnippet)(ct)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${kt} && xCol >= 0 && xCol < ${Ct}) {
      ${wt}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${(Lt=>{switch(Lt){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Lt} is not supported.`)}})(ct)}
    }
    return resData;`,It=Z?at&&et?`
    let col = colIn * ${ct};
    ${bt}`:`
    let col = colIn * ${ct};
    if (row < dimAOuter && col < dimInner) {
      ${bt}
    }
    return ${(0,s.typeSnippet)(ct)}(0.0);`:et&&st?`
    let col = colIn * ${ct};
    ${bt}`:`
    let col = colIn * ${ct};
    if (row < dimInner && col < dimBOuter) {
      ${bt}
    }
    return ${(0,s.typeSnippet)(ct)}(0.0);`,_t=`${(Lt=>{switch(Lt){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${Lt} is not supported.`)}})(mt)}`,xt=(0,s.typeSnippet)(ut),zt=Z?(0,s.typeSnippet)(ct):(0,s.typeSnippet)(mt),Gt=Z?(0,s.typeSnippet)(mt):(0,s.typeSnippet)(ct);return`
    ${(0,s.activationFnSnippet)(nt,gt,ut===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${zt} {
      ${Z?It:_t}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Gt} {
      ${Z?_t:It}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${xt}) {
      let col = colIn * ${ut};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${Z?"outShape[2]":"outShape[3]"};
      ${Et}
      ${(0,s.biasActivationSnippet)(dt,nt)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`})(g,V,z,J,c,void 0,!1,q[0],q[1],q[2])}
            ${S?(0,p.makeMatMulPackedVec4Source)(C,E,!g,k):(0,p.makeMatMulPackedSource)(C,E,!g,k,!1,void 0,d)}`})}},4085:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.utilFunctions=void 0,u.utilFunctions=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`},158:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.makeMatMulPackedSource=u.makeMatMulPackedVec4Source=void 0,u.makeMatMulPackedVec4Source=(m,h,f=!1,s=32,l=!1,p=32,a=!1)=>{const i=h[1]*m[1],e=h[0]*m[0],t=f?i:s,n=f?s:i,r=t/h[0],o=s/h[1];if((!f||r!==4||m[1]!==4)&&(f||r!==3&&r!==4)||t%h[0]!=0||s%h[1]!=0||m[0]!==4)throw new Error(`If transposeA ${f} is true, innerElementSize ${r} and workPerThread[1] ${m[1]} must be 4.
      Otherwise, innerElementSize ${r} must be 3 or 4.
  tileAWidth ${t} must be divisible by workgroupSize[0]${h[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${h[1]}. colPerThread ${m[0]} must be 4.`);return`
var<workgroup> mm_Asub : array<array<vec${r}<f32>, ${t/r}>, ${n}>;
var<workgroup> mm_Bsub : array<array<vec4<f32>, ${e/m[0]}>, ${s}>;

const rowPerThread = ${m[1]};
const colPerThread = ${m[0]};
const innerElementSize = ${r};
const tileInner = ${s};

@compute @workgroup_size(${h[0]}, ${h[1]}, ${h[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = ${a?"0":"localRow * rowPerThread"};
  let tileCol = i32(localId.x);

  let globalRow = ${a?"0":"i32(globalId.y) * rowPerThread"};
  let globalCol = i32(globalId.x);
  let batch = ${l?"0":"i32(globalId.z)"};
  let globalRowStart = i32(workgroupId.y) * ${i};

  let numTiles = ${l?`${Math.ceil(p/s)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${l?`i32(globalId.z) * ${p}`:"0"};

  var acc: array<vec4<f32>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${o};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${c=f,c?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol);
        `}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${o}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${r===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${((d,g)=>d?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${g===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${g===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${g===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`)(f,r)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;var c};const y=m=>m?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol);
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol);
            `;u.makeMatMulPackedSource=(m,h,f=!1,s=32,l=!1,p=32,a=!1)=>{const i=m[1]*h[1],e=m[0]*h[0],t=f?i:s,n=f?s:i;if(n%h[1]!=0||t%h[0]!=0||s%h[1]!=0)throw new Error(`tileAHight ${n} must be divisible by workgroupSize[1]${h[1]}, tileAWidth ${t} must be divisible by workgroupSize[0]${h[0]}, tileInner ${s} must be divisible by workgroupSize[1]${h[1]}`);const r=n/h[1],o=t/h[0],c=s/h[1],d=a?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${i};
    let globalColStart = i32(workgroupId.x) * ${e};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${h[1]}) {
        for (var inputCol = localCol; inputCol < ${t}; inputCol = inputCol + ${h[0]}) {
          ${y(f)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${h[1]}) {
            for (var inputCol = localCol; inputCol < ${e}; inputCol = inputCol + ${h[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol);
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<f32, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${h[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${f?`mm_Asub[k][localRow + innerRow * ${h[1]}];`:`mm_Asub[localRow + innerRow * ${h[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${h[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${h[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${i};

let tileRowA = i32(localId.y) * ${r};
let tileColA = i32(localId.x) * ${o};
let tileRowB = i32(localId.y) * ${c};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${r}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${o}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${y(f)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol);
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<f32, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${(g=>g?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(f)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<f32, ${t}>, ${n}>;
  var<workgroup> mm_Bsub : array<array<f32, ${e}>, ${s}>;
  const rowPerThread = ${m[1]};
  const colPerThread = ${m[0]};
  const tileInner = ${s};

@compute @workgroup_size(${h[0]}, ${h[1]}, ${h[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${l?"0":"i32(globalId.z)"};
    let numTiles = ${l?`${Math.ceil(p/s)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${l?`i32(globalId.z) * ${p}`:"0"};

    var acc : array<array<f32, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${d}
  }
`}},504:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.sub=u.pow=u.mul=u.div=u.add=void 0;const m=y(6952),h=y(1163),f=y(2075),s=(l,p,a,i,e)=>{const t={name:p,inputTypes:[h.GpuDataType.default,h.GpuDataType.default],cacheHint:e};return Object.assign(Object.assign({},t),{get:()=>((n,r,o,c,d,g=r.dataType)=>{var b,v;const w=!m.ShapeUtil.areEqual(r.dims,o.dims);let x=r.dims,T=m.ShapeUtil.size(r.dims),S=!1;if(w){const _=m.BroadcastUtil.calcShape(r.dims,o.dims,!1);if(!_)throw new Error("Can't perform binary op on the given tensors");x=_,T=m.ShapeUtil.size(x);let A=1;for(let E=0;E<x.length;E++){const C=(b=r.dims[r.dims.length-E])!==null&&b!==void 0?b:1;if(C!==((v=o.dims[o.dims.length-E])!==null&&v!==void 0?v:1))break;A*=C}A%4==0&&(S=!0)}else S=!0;return Object.assign(Object.assign({},n),{getShaderSource:_=>((A,E,C,D,$,L,P,k,V="f32",z="f32",J="f32")=>{const q=m.ShapeUtil.size(D),tt=Math.ceil(q/4);let rt,Z;typeof P=="string"?rt=Z=(dt,nt)=>`${P}((${dt}),(${nt}))`:typeof P=="function"?rt=Z=P:(rt=P.scalar,Z=P.vector);let at="";const st=(0,f.createIndicesHelper)("output",D);if(L){const dt=nt=>{const gt=m.ShapeUtil.computeStrides(nt),ct=[];for(let mt=nt.length-1;mt>=0;mt--){const ut=D.length===0?"0u":D.length===1?"(*outputIndices)":`(*outputIndices)[${mt+D.length-nt.length}]`;ct.push(`${gt[mt]}u * (${ut} % ${nt[mt]}u)`)}return ct.length>0?ct.join("+"):"0u"};at=`
  ${st.o2iImpl}

  fn calcOffsetA(outputIndices: ptr<function, ${st.iType}>) -> u32 {
    return ${dt(E)};
  }

  fn calcOffsetB(outputIndices: ptr<function, ${st.iType}>) -> u32 {
    return ${dt(C)};
  }
  `}let et;if($)et=L?`
      ${st.indicesVariableDeclaration("outputIndices")}
      ${st.o2iCall("global_idx * 4u","outputIndices")}
      let offsetA = calcOffsetA(&outputIndices);
      let offsetB = calcOffsetB(&outputIndices);
      outputData[global_idx] = ${Z("aData[offsetA / 4u]","bData[offsetB / 4u]")};`:`outputData[global_idx] = ${Z("aData[global_idx]","bData[global_idx]")};`;else{if(!L)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");const dt=nt=>{const gt=`aData[indexA${nt}][componentA${nt}]`,ct=`bData[indexB${nt}][componentB${nt}]`;return`
      ${st.o2iCall(`global_idx * 4u + ${nt}u`,"outputIndices")}
      let offsetA${nt} = calcOffsetA(&outputIndices);
      let offsetB${nt} = calcOffsetB(&outputIndices);
      let indexA${nt} = offsetA${nt} / 4u;
      let indexB${nt} = offsetB${nt} / 4u;
      let componentA${nt} = offsetA${nt} % 4u;
      let componentB${nt} = offsetB${nt} % 4u;
      outputData[global_idx][${nt}] = ${rt(gt,ct)};`};et=`
      ${st.indicesVariableDeclaration("outputIndices")}
      ${dt(0)}
      ${dt(1)}
      ${dt(2)}
      ${dt(3)}`}return`
  @group(0) @binding(0) var<storage, read> aData : array<vec4<${V}>>;
  @group(0) @binding(1) var<storage, read> bData : array<vec4<${z}>>;
  @group(0) @binding(2) var<storage, read_write> outputData : array<vec4<${J}>>;

  ${k??""}
  ${at}

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes(tt)}
    ${et}
  }`})(_,r.dims,o.dims,x,S,w,c,d),outputs:[{dims:x,dataType:g,gpuDataType:h.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(T/64/(S?4:1))})})})(t,l[0],l[1],a,i)})};u.add=l=>{l.compute(s(l.inputs,"Add",(p,a)=>`${p}+${a}`))},u.div=l=>{l.compute(s(l.inputs,"Div",(p,a)=>`${p}/${a}`))},u.mul=l=>{l.compute(s(l.inputs,"Mul",(p,a)=>`${p}*${a}`))},u.pow=l=>{l.compute(s(l.inputs,"Pow",{scalar:(p,a)=>`pow_f32(${p},${a})`,vector:(p,a)=>`pow_vf32(${p},${a})`},`
    fn pow_f32(a : f32, b : f32) -> f32 {
      if (b == 0.0) {
        return 1.0;
      } else if (a < 0.0 && b != floor(b)) {
        return pow(a, b); // NaN
      }
      return select(sign(a), 1.0, round(abs(b) % 2.0) != 1.0) * pow(abs(a), b);
    }
    fn pow_vf32(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {
      // TODO: implement vectorized pow
      return vec4<f32>(pow_f32(a.x, b.x), pow_f32(a.y, b.y), pow_f32(a.z, b.z), pow_f32(a.w, b.w));
    }
      `))},u.sub=l=>{l.compute(s(l.inputs,"Sub",(p,a)=>`${p}-${a}`))}},2075:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createShaderHelper=u.createIndicesHelper=u.WORKGROUP_SIZE=void 0;const m=y(6952);u.WORKGROUP_SIZE=64,u.createIndicesHelper=(f,s)=>{const l=s.length<2?"u32":`array<u32, ${s.length}>`,p=m.ShapeUtil.computeStrides(s);let a="";for(let t=0;t<s.length-1;t++)a+=`
    let dim${t} = current / ${p[t]}u;
    let rest${t} = current % ${p[t]}u;
    (*indices)[${t}] = dim${t};
    current = rest${t};
    `;a+=`(*indices)[${s.length-1}] = current;`;const i=s.length<2?"":`
  fn ih_o2i_${f}(offset: u32, indices: ptr<function, ${l}>) {
    var current = offset;
    ${a}
  }`,e=[];if(s.length===0)e.push("0u");else if(s.length<2)e.push("(*indices)");else for(let t=s.length-1;t>=0;t--)e.push(`${p[t]}u * ((*indices)[${t}])`);return{o2iImpl:i,o2iCall:(t,n)=>s.length<2?`${n}=${t};`:`ih_o2i_${f}(${t}, &${n});`,i2oImpl:s.length<2?"":`
  fn ih_i2o_${f}(indices: ptr<function, ${l}>) -> u32 {
    return ${e.join("+")};
  }`,i2oExpression:(t,n)=>s.length<2?`(${n?"*":""}${t})`:`ih_i2o_${f}(${n?"":"&"}${t})`,indicesVariableDeclaration:(t,n)=>`var ${t}:${l}${n?`=${l}(${n.join(",")})`:""};`,iType:l}};class h{constructor(s){this.normalizedDispatchGroup=s}guardAgainstOutOfBoundsWorkgroupSizes(s){return`if (global_idx >= ${typeof s=="number"?`${s}u`:s}) { return; }`}mainStart(s=u.WORKGROUP_SIZE){const l=typeof s=="number"?s:s[0],p=typeof s=="number"?1:s[1],a=typeof s=="number"?1:s[2],i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1;return`@compute @workgroup_size(${l}, ${p}, ${a})
  fn main(${i?"@builtin(global_invocation_id) global_id : vec3<u32>":`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`}) {
    ${i?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${l*p*a}u + local_index;`}
  `}}u.createShaderHelper=f=>new h(f)},9192:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createGroupedConvProgramInfoLoader=void 0;const m=y(6952),h=y(1163),f=y(2075),s=y(9770),l=y(3997);u.createGroupedConvProgramInfoLoader=(p,a,i)=>{const e=(t=p.length>2,n=a.cacheKey,{name:"GroupedConv",inputTypes:t?[h.GpuDataType.default,h.GpuDataType.default,h.GpuDataType.default]:[h.GpuDataType.default,h.GpuDataType.default],cacheHint:n});var t,n;return Object.assign(Object.assign({},e),{get:()=>((r,o,c,d)=>{const g=r.length>2,b=g?"value += b[output_channel];":"",v=r[0].dims,w=r[1].dims,x=w[0]/c.group,T="f32",{activationFunction:S,applyActivation:_}=(0,l.getActicationSnippet)(c),A=[`@group(0) @binding(0) var<storage, read> x : array<${T}>;`,`@group(0) @binding(1) var<storage, read> w : array<${T}>;`];g&&A.push(`@group(0) @binding(2) var<storage, read> b : array<${T}>;`);const E=c.format==="NHWC",C=(0,s.calculateOutputShape)(v,w,c.dilations,c.pads,c.strides,E),D=m.ShapeUtil.size(C),$=(0,f.createIndicesHelper)("output",C),L=(0,f.createIndicesHelper)("x",v),P=(0,f.createIndicesHelper)("w",w);return Object.assign(Object.assign({},o),{outputs:[{dims:d?d(C):C,dataType:r[0].dataType,gpuDataType:h.GpuDataType.default}],getShaderSource:k=>`
  const strides: vec2<u32> = vec2(${c.strides[0]}u, ${c.strides[1]}u);
  const pads: vec2<u32> = vec2(${c.pads[0]}u, ${c.pads[1]}u);

  ${A.join(`
`)}
  @group(0) @binding(${A.length}) var<storage, read_write> output : array<${T}>;

  ${S}
  ${$.o2iImpl}
  ${L.i2oImpl}
  ${P.i2oImpl}

  ${k.mainStart()}
    ${k.guardAgainstOutOfBoundsWorkgroupSizes(D)}

    ${$.indicesVariableDeclaration("outputIndices")}
    ${$.o2iCall("global_idx","outputIndices")}
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${E?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${E?1:2}], outputIndices[${E?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${x}u;

    var value: ${T} = ${T}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${w[1]}u; wInChannel++) {
      let input_channel = group_id * ${w[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${w[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${c.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${v[E?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${w[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${c.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${v[E?2:3]}u) {
            continue;
          }

          ${L.indicesVariableDeclaration("xIndices",E?["batch","xHeight","xWidth","input_channel"]:["batch","input_channel","xHeight","xWidth"])}
          let xVal = x[${L.i2oExpression("xIndices")}];
          ${P.indicesVariableDeclaration("wIndices",["output_channel","wInChannel","wHeight","wWidth"])}
          let wVal = w[${P.i2oExpression("wIndices")}];
          value += xVal*wVal;
        }
      }
    }
    ${b}
    ${_}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(D/64)})})})(p,e,a,i)})}},9770:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.conv=u.parseConvAttributes=u.calculateOutputShape=void 0;const m=y(6952),h=y(387),f=y(9192),s=y(3822),l=y(3997),p=y(2625);u.calculateOutputShape=(e,t,n,r,o,c)=>{const d=e[0],g=e.slice(c?1:2,c?3:4),b=g.length,v=t[0],w=t.slice(2).map((T,S)=>T+(T-1)*(n[S]-1)),x=g.map((T,S)=>T+r[S]+r[S+b]).map((T,S)=>Math.floor((T-w[S]+o[S])/o[S]));return x.splice(0,0,d),x.splice(c?3:1,0,v),x};const a=(0,h.createAttributeWithCacheKey)({perm:[2,3,1,0]}),i=(e,t)=>{const n=e.kernelShape.slice();for(let c=2;c<t[1].dims.length;++c)n[c-2]===0&&(n[c-2]=t[1].dims[c]);const r=e.pads.slice();m.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,e.format==="NHWC",e.autoPad);const o=Object.assign({},e);return Object.assign(o,{kernelShape:n,pads:r,cacheKey:e.cacheKey}),o};u.parseConvAttributes=e=>{const t=(0,l.parseInternalActivationAttributes)(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],o=e.dilations,c=e.group,d=e.kernel_shape,g=e.pads,b=e.strides,v=e.w_is_const();return(0,h.createAttributeWithCacheKey)(Object.assign({autoPad:r,format:n,dilations:o,group:c,kernelShape:d,pads:g,strides:b,wIsConst:v},t))},u.conv=(e,t)=>{((n,r)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4&&n[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");if(n[0].dims[r.format==="NHWC"?n[0].dims.length-1:1]!==n[1].dims[1]*r.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(n.length===3&&(n[2].dims.length!==1||n[1].dims[0]!==n[2].dims[0]))throw new Error("invalid bias");const o=n[0].dims.length-2;if(r.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(r.strides.length!==o)throw new Error(`strides should be ${o}D`);if(r.pads.length!==2*o)throw new Error(`pads should be ${2*o}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(n[0].dataType!==1||n[1].dataType!==1)throw new Error("Conv input(X,W) should be float tensor");if(n.length===3&&n[2].dataType!==1)throw new Error("Conv input(bias) should be float tensor")})(e.inputs,t),e.inputs[0].dims.length===3?((n,r)=>{const o=r.format==="NHWC",c=[n.inputs[0].reshape(o?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];n.inputs.length===3&&c.push(n.inputs[2]);const d=[0,r.pads[0],0,r.pads[1]],g=[1].concat(r.strides),b=[1].concat(r.dilations),v=[1].concat(r.kernelShape),w=i(Object.assign(Object.assign({},r),{pads:d,strides:g,dilations:b,kernelShape:v}),c);n.compute((0,f.createGroupedConvProgramInfoLoader)(c,w,x=>o?[x[0],x[2],x[3]]:[]))})(e,t):((n,r,o)=>{var c;const d=i(o,r),g=r.length===3,b=o.format==="NHWC",v=r[0].dims[b?1:2],w=r[0].dims[b?2:3],x=r[0].dims[b?3:1],T=r[1].dims[2],S=r[1].dims[3],_=(0,u.calculateOutputShape)(r[0].dims,r[1].dims,o.dilations,d.pads,o.strides,b),A=_[b?1:2],E=_[b?2:3],C=_[b?3:1];if(b&&T===v&&S===w&&o.autoPad==="VALID"||T===1&&S===1&&o.dilations[0]===1&&o.dilations[1]===1&&o.strides[0]===1&&o.strides[1]===1&&(o.autoPad==="SAME_UPPER"||o.autoPad==="SAME_LOWER"||o.autoPad==="VALID")||!b||o.group!==1)return void n.compute((0,f.createGroupedConvProgramInfoLoader)(r,d));const D=b?A*E:C,$=b?C:A*E,L=T*S*x,P=(c=n.customData.wT)!==null&&c!==void 0?c:n.compute(Object.assign(Object.assign({},p.transposeProgramMetadata),{cacheHint:a.cacheKey,get:()=>(0,p.createTransposeProgramInfo)(r[1],a.perm)}),{inputs:[1],outputs:[o.wIsConst?-2:-1]})[0];o.wIsConst&&!n.customData.wT&&(n.customData.wT=P);const k=[r[0],P];g&&(b||r[2].dims.length!==1?k.push(r[2]):k.push(r[2].reshape([r[2].dims[0],1,1]))),n.compute((0,s.createConv2DMatMulProgramInfoLoader)(k,d,_,D,$,L,g,!0),{inputs:k})})(e,e.inputs,t)}},3822:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createConv2DMatMulProgramInfoLoader=void 0;const m=y(1163),h=y(9456);u.createConv2DMatMulProgramInfoLoader=(f,s,l,p,a,i,e,t)=>{const n=((r,o)=>({name:"Conv2DMatMul",inputTypes:r?[m.GpuDataType.default,m.GpuDataType.default,m.GpuDataType.default]:[m.GpuDataType.default,m.GpuDataType.default],cacheHint:o}))(e,s.cacheKey);return Object.assign(Object.assign({},n),{get:()=>(0,h.createConv2DMatMulProgramInfo)(f,n,s,l,p,a,i,e,t)})}},3997:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseInternalActivationAttributes=u.getActicationSnippet=void 0;const m=y(6952);u.getActicationSnippet=h=>{switch(h.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${h.clipMin});const clip_max_=f32(${h.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},u.parseInternalActivationAttributes=h=>{const f=(h==null?void 0:h.activation)||"";if(f==="Clip"){const[s,l]=(h==null?void 0:h.activation_params)||[m.MIN_CLIP,m.MAX_CLIP];return{activation:f,clipMax:l,clipMin:s,activationCacheKey:`${f}:${s},${l}`}}return{activation:f,activationCacheKey:f}}},4271:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseGemmAttributes=u.gemm=void 0;const m=y(6952),h=y(387),f=y(1163);u.gemm=(s,l)=>{(p=>{if(!p)throw new Error("Input is missing");if(p.length<2||p.length>3)throw new Error("Invaid input number.");if(p.length===3&&p[2].dims.length>2)throw new Error("Invalid input shape of C");if(p[0].dataType!==1||p[1].dataType!==1||p.length===3&&p[2].dataType!==1)throw new Error("Invalid input type.");if(p[0].dataType!==p[1].dataType||p.length===3&&p[0].dataType!==p[2].dataType)throw new Error("Input types are mismatched")})(s.inputs),s.compute(((p,a)=>{const i={name:"Gemm",inputTypes:p.length===3?[f.GpuDataType.default,f.GpuDataType.default,f.GpuDataType.default]:[f.GpuDataType.default,f.GpuDataType.default],cacheHint:a.cacheKey};return Object.assign(Object.assign({},i),{get:()=>((e,t,n)=>{const r=t[0].dims.slice(),o=t[1].dims.slice(),[c,d,g]=m.GemmUtil.getShapeOfGemmResult(r,n.transA,o,n.transB,t.length===3?t[2].dims:void 0),b=[c,d];if(!b)throw new Error("Can't use gemm on the given tensors");const v=m.ShapeUtil.size(b);let w="";n.transA&&n.transB?w="value += a[k * M + m] * b[n * K + k];":n.transA&&!n.transB?w="value += a[k * M + m] * b[k * N + n];":!n.transA&&n.transB?w="value += a[m * K + k] * b[n * K + k];":n.transA||n.transB||(w="value += a[m * K + k] * b[k * N + n];");const x="f32",T=n.alpha===1?"":"value *= alpha;",S=t.length===3?`value += beta * c[${((A,E,C)=>{if(C.length===0)return"0u";const D=C.length===1&&A!==1||C.length===2&&C[0]!==A,$=C[C.length-1]!==E;let L="0u";return D||(L+=`+ m * ${C[C.length-1]}u`),$||(L+="+n"),L})(c,d,t[2].dims)}];`:"",_=[`@group(0) @binding(0) var<storage, read> a : array<${x}>;`,`@group(0) @binding(1) var<storage, read> b : array<${x}>;`];return t.length===3&&_.push(`@group(0) @binding(2) var<storage, read> c : array<${x}>;`),Object.assign(Object.assign({},e),{outputs:[{dims:b,dataType:t[0].dataType,gpuDataType:f.GpuDataType.default}],getShaderSource:A=>`
  const M: u32 = ${c}u;
  const N: u32 = ${d}u;
  const K: u32 = ${g}u;
  const alpha = ${x}(${n.alpha});
  const beta = ${x}(${n.beta});

  ${_.join(`
`)}
  @group(0) @binding(${t.length}) var<storage, read_write> output : array<${x}>;

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes(v)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${x}(0);
    for (var k: u32 = 0u; k<${g}u; k++) {
      ${w}
    }

    ${T}
    ${S}
    output[global_id.x] = value;

  }`,dispatchGroup:()=>({x:Math.ceil(v/64)})})})(i,p,a)})})(s.inputs,l))},u.parseGemmAttributes=s=>(0,h.createAttributeWithCacheKey)(s)},1522:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.matMul=u.createMatmulProgramInfoLoader=void 0;const m=y(6952),h=y(1163),f=y(3997);u.createMatmulProgramInfoLoader=(s,l)=>{const p=(a=s.length>2,i=l.activationCacheKey,{name:"MatMul",inputTypes:a?[h.GpuDataType.default,h.GpuDataType.default,h.GpuDataType.default]:[h.GpuDataType.default,h.GpuDataType.default],cacheHint:i});var a,i;return Object.assign(Object.assign({},p),{get:()=>((e,t,n)=>{const r=t[0].dims,o=t[1].dims,c=m.BroadcastUtil.calcShape(r,o,!0);if(!c)throw new Error("Can't use matmul on the given tensors");const d=m.ShapeUtil.size(c),g="f32",{activationFunction:b,applyActivation:v}=(0,f.getActicationSnippet)(n),w=c[c.length-2],x=r[r.length-1],T=c[c.length-1];return Object.assign(Object.assign({},e),{outputs:[{dims:c,dataType:t[0].dataType,gpuDataType:h.GpuDataType.default}],getShaderSource:S=>`
  const M: u32 = ${w}u;
  const N: u32 = ${T}u;
  const K: u32 = ${x}u;

  @group(0) @binding(0) var<storage, read> a : array<${g}>;
  @group(0) @binding(1) var<storage, read> b : array<${g}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${g}>;

  ${b}

  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes(d)}

    let stack = global_idx / (M * N);
    let mn = global_idx % (M * N);
    let n = global_idx % N;
    let m = mn / N;

    let offsetA = stack * (M * K);
    let offsetB = stack * (K * N);

    var value = ${g}(0);
    for (var k: u32 = 0u; k<${x}u; k++) {
      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];
    }
    ${v}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(d/64)})})})(p,s,l)})},u.matMul=s=>{(l=>{if(!l||l.length!==2)throw new Error("MatMul requires 2 inputs.");if(l[0].dims[l[0].dims.length-1]!==l[1].dims[l[1].dims.length-2])throw new Error("shared dimension does not match.");if(l[0].dataType!==1||l[1].dataType!==1)throw new Error("inputs should be float type")})(s.inputs),s.compute((0,u.createMatmulProgramInfoLoader)(s.inputs,{activation:"",activationCacheKey:""}))}},5262:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.globalMaxPool=u.parseGlobalMaxPoolAttributes=u.parseMaxPoolAttributes=u.maxPool=u.globalAveragePool=u.parseGlobalAveragePoolAttributes=u.averagePool=u.parseAveragePoolAttributes=void 0;const m=y(6952),h=y(387),f=y(1163),s=y(2075),l=r=>{if(!r||r.length!==1)throw new Error("Pool ops requires 1 input.");if(r[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.");if(r[0].dataType!==1)throw new Error("Invalid input type.")},p=(r,o,c)=>{const d=o.format==="NHWC",g=d?[r[0].dims[0],r[0].dims[3],r[0].dims[1],r[0].dims[2]]:r[0].dims.slice(),b=Object.hasOwnProperty.call(o,"dilations"),v=o.kernelShape.slice(),w=o.strides.slice(),x=b?o.dilations.slice():[],T=o.pads.slice();m.PoolConvUtil.adjustPoolAttributes(c,g,v,w,x,T);const S=m.PoolConvUtil.computePoolOutputShape(c,g,w,x,v,T,o.autoPad),_=Object.assign({},o);return b?Object.assign(_,{kernelShape:v,strides:w,pads:T,dilations:x,cacheKey:o.cacheKey}):Object.assign(_,{kernelShape:v,strides:w,pads:T,cacheKey:o.cacheKey}),[_,d?[S[0],S[2],S[3],S[1]]:S]},a=(r,o,c,d,g,b,v,w)=>{const x=d.format==="NHWC",T=o.length,S=m.ShapeUtil.size(c),_=(0,s.createIndicesHelper)("output",c),A=(0,s.createIndicesHelper)("x",o);if(d.kernelShape.length<=2){const E=d.kernelShape[d.kernelShape.length-1],C=d.strides[d.strides.length-1],D=d.pads[d.pads.length/2-1],$=T-(x?2:1);let L="",P="",k="";if(L=D+d.pads[d.pads.length-1]!==0?`
              for (var i: u32 = 0u; i < ${E}u; i++) {
                xIndices[${$}] = indices[${$}] * ${C} - ${D} + i;
                if (xIndices[${$}] < 0 || xIndices[${$}] >= ${o[$]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${A.i2oExpression("xIndices")}];
                ${g}
              }`:`
              for (var i: u32 = 0u; i < ${E}u; i++) {
                xIndices[${$}] = indices[${$}] * ${C} - ${D} + i;
                let x_val = x[${A.i2oExpression("xIndices")}];
                ${g}
              }`,d.kernelShape.length===2){const V=d.kernelShape[d.kernelShape.length-2],z=d.strides[d.strides.length-2],J=d.pads[d.pads.length/2-2],q=d.pads[d.pads.length-2],tt=T-(x?3:2),rt=o[tt];P=J+q!==0?`
                for (var j: u32 = 0u; j < ${V}u; j++) {
                  xIndices[${tt}] = indices[${tt}] * ${z} - ${J} + j;
                  if (xIndices[${tt}] < 0 || xIndices[${tt}] >= ${rt}) {
                    pad+= ${E};
                    continue;
                  }
              `:`
                for (var j: u32 = 0u; j < ${V}u; j++) {
                  xIndices[${tt}] = indices[${tt}] * ${z} - ${J} + j;
                `,k=`
              }
            `}return`
            @group(0) @binding(0) var<storage, read> x : array<${v}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${v}>;

            ${_.o2iImpl}
            ${A.i2oImpl}

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes(S)}

              ${_.indicesVariableDeclaration("indices")}
              ${_.o2iCall("global_idx","indices")}
              ${_.indicesVariableDeclaration("xIndices")}
              ${_.o2iCall("global_idx","xIndices")}

              var value: ${v} = ${v}(${w});
              var pad = 0;
              ${P}
              ${L}
              ${k}
              ${b}

              output[global_idx] = value;
            }`}{if(x)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const E=m.ShapeUtil.size(d.kernelShape),C=m.ShapeUtil.computeStrides(d.kernelShape),D=C.length,$=d.pads.length;let L="";return L=d.pads.reduce((P,k)=>P+k)?`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${A.i2oExpression("xIndices")}];
                ${g}
              }`:`
              }
              let x_val = x[${A.i2oExpression("xIndices")}];
              ${g}
            `,`
            @group(0) @binding(0) var<storage, read> x : array<${v}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${v}>;

            ${_.o2iImpl}
            ${A.i2oImpl}

            const pads = array<u32, ${$}>(${d.pads.map(P=>`${P}u`).join(",")});
            const inputDims = array<u32, ${T}>(${o.map(P=>`${P}u`).join(",")});
            const kernelStrides = array<u32, ${D}>(${C.map(P=>`${P}u`).join(",")});
            const strides = array<u32, ${D}>(${d.strides.map(P=>`${P}u`).join(",")});

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes(S)}

              ${_.indicesVariableDeclaration("indices")}
              ${_.o2iCall("global_idx","indices")}
              ${_.indicesVariableDeclaration("xIndices")}
              ${_.o2iCall("global_idx","xIndices")}

              var offsets: array<u32, ${D}>;

              var value = ${v}(${w});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${E}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${D-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${D-1}] = offset;

                isPad = false;
                for (var j = ${T-D}u; j < ${T}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${T-D}u]
                    + offsets[j - ${T-D}u] - pads[j - 2u];
                  ${L}
              }
              ${b}

              output[global_idx] = value;
            }`}},i=r=>({format:r.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][r.auto_pad],ceilMode:r.ceil_mode,kernelShape:r.kernel_shape,strides:r.strides,pads:r.pads}),e=(r,o,c,d)=>{const[g,b]=p(r,d,c),v=m.ShapeUtil.size(g.kernelShape),w="f32";let x="";return g.countIncludePad?x+=`value /= ${w}(${v});`:x+=`value /= ${w}(${v} - pad);`,Object.assign(Object.assign({},o),{outputs:[{dims:b,dataType:r[0].dataType,gpuDataType:f.GpuDataType.default}],getShaderSource:T=>a(T,r[0].dims,b,g,"value += x_val;",x,w,"0.0"),dispatchGroup:()=>({x:Math.ceil(m.ShapeUtil.size(b)/64)})})};u.parseAveragePoolAttributes=r=>{const o=r.count_include_pad!==0,c=i(r);if(c.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,h.createAttributeWithCacheKey)(Object.assign({countIncludePad:o},c))},u.averagePool=(r,o)=>{l(r.inputs);const c={name:"AveragePool",inputTypes:[f.GpuDataType.default],cacheHint:o.cacheKey};r.compute(Object.assign(Object.assign({},c),{get:()=>e(r.inputs,c,!1,o)}))};const t={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};u.parseGlobalAveragePoolAttributes=r=>{const o=r.format;return Object.assign(Object.assign({format:o},t),{cacheKey:o})},u.globalAveragePool=(r,o)=>{l(r.inputs);const c={name:"GlobalAveragePool",inputTypes:[f.GpuDataType.default],cacheHint:o.cacheKey};r.compute(Object.assign(Object.assign({},c),{get:()=>e(r.inputs,c,!0,o)}))};const n=(r,o,c,d)=>{const[g,b]=p(r,d,c);return Object.assign(Object.assign({},o),{outputs:[{dims:b,dataType:r[0].dataType,gpuDataType:f.GpuDataType.default}],getShaderSource:v=>a(v,r[0].dims,b,g,`
      value = max(x_val, value);
    `,"","f32","-1e5"),dispatchGroup:()=>({x:Math.ceil(m.ShapeUtil.size(b)/64)})})};u.maxPool=(r,o)=>{l(r.inputs);const c={name:"MaxPool",inputTypes:[f.GpuDataType.default],cacheHint:o.cacheKey};r.compute(Object.assign(Object.assign({},c),{get:()=>n(r.inputs,c,!1,o)}))},u.parseMaxPoolAttributes=r=>{const o=r.storage_order,c=r.dilations,d=i(r);if(o!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(d.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,h.createAttributeWithCacheKey)(Object.assign({storageOrder:o,dilations:c},d))},u.parseGlobalMaxPoolAttributes=r=>{const o=r.format;return Object.assign(Object.assign({format:o},t),{cacheKey:o})},u.globalMaxPool=(r,o)=>{l(r.inputs);const c={name:"GlobalMaxPool",inputTypes:[f.GpuDataType.default],cacheHint:o.cacheKey};r.compute(Object.assign(Object.assign({},c),{get:()=>n(r.inputs,c,!0,o)}))}},2625:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseTransposeAttributes=u.transpose=u.createTransposeProgramInfo=u.transposeProgramMetadata=void 0;const m=y(6952),h=y(387),f=y(1163),s=y(2075);u.transposeProgramMetadata={name:"Transpose",inputTypes:[f.GpuDataType.default]};const l=(p,a)=>a&&a.length!==p.length?[...p.keys()].reverse():a;u.createTransposeProgramInfo=(p,a)=>{const i=p.dims,e=l(i,a),t=((d,g)=>m.ShapeUtil.sortBasedOnPerm(d,l(d,g)))(i,e),n=i.length,r=m.ShapeUtil.size(t),o=(0,s.createIndicesHelper)("output",t),c=(0,s.createIndicesHelper)("a",i);return Object.assign(Object.assign({},u.transposeProgramMetadata),{outputs:[{dims:t,dataType:p.dataType,gpuDataType:f.GpuDataType.default}],getShaderSource:d=>`
  @group(0) @binding(0) var<storage, read> a : array<f32>;
  @group(0) @binding(1) var<storage, read_write> output : array<f32>;

  ${((g,b)=>{const v=[];v.push(`fn perm(a: ptr<function, array<u32, ${b}>>, i: ptr<function, array<u32, ${b}>>) {`);for(let w=0;w<b;++w)v.push(`	(*a)[${g[w]}]=(*i)[${w}];`);return v.push("	}"),v.join(`
`)})(e,n)}
  ${o.o2iImpl}
  ${c.i2oImpl}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes(r)}

    ${o.indicesVariableDeclaration("indices")}
    ${o.o2iCall("global_idx","indices")}
    ${c.indicesVariableDeclaration("aIndices")}
    perm(&aIndices, &indices);

    output[global_idx] = a[${c.i2oExpression("aIndices")}];
  }`,dispatchGroup:()=>({x:Math.ceil(r/64)})})},u.transpose=(p,a)=>{(i=>{if(!i||i.length!==1)throw new Error("Transpose requires 1 input.");if(i[0].dataType!==1)throw new Error("input should be float tensor")})(p.inputs),p.compute(Object.assign(Object.assign({},u.transposeProgramMetadata),{cacheHint:a.cacheKey,get:()=>(0,u.createTransposeProgramInfo)(p.inputs[0],a.perm)}))},u.parseTransposeAttributes=p=>(0,h.createAttributeWithCacheKey)({perm:p.perm})},9302:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.thresholdedRelu=u.tanh=u.tan=u.sqrt=u.sinh=u.sin=u.sigmoid=u.relu=u.reciprocal=u.neg=u.leakyRelu=u.floor=u.exp=u.erf=u.elu=u.parseAlphaAttributes=u.cosh=u.cos=u.ceil=u.clip=u.clipV10=u.atanh=u.atan=u.asinh=u.asin=u.acosh=u.acos=u.abs=void 0;const m=y(6952),h=y(387),f=y(1163),s=(l,p,a,i,e)=>{const t={name:p,inputTypes:[f.GpuDataType.default],cacheHint:e};return Object.assign(Object.assign({},t),{get:()=>((n,r,o,c)=>Object.assign(Object.assign({},n),{getShaderSource:d=>((g,b,v,w)=>{const x=Math.ceil(b/4);let T="";return T=typeof v=="string"?`${v}(a)`:v("a"),`
  @group(0) @binding(0) var<storage, read> inputData : array<vec4<f32>>;
  @group(0) @binding(1) var<storage, read_write> outputData : array<vec4<f32>>;

  ${w??""}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes(x)}

    let a = inputData[global_idx];
    outputData[global_idx] = ${T};
  }`})(d,m.ShapeUtil.size(r.dims),o,c),outputs:[{dims:r.dims,dataType:r.dataType,gpuDataType:f.GpuDataType.default}],dispatchGroup:d=>({x:Math.ceil(m.ShapeUtil.size(d[0].dims)/64/4)})}))(t,l,a,i)})};u.abs=l=>{l.compute(s(l.inputs[0],"Abs","abs"))},u.acos=l=>{l.compute(s(l.inputs[0],"Acos","acos"))},u.acosh=l=>{l.compute(s(l.inputs[0],"Acosh","acosh"))},u.asin=l=>{l.compute(s(l.inputs[0],"Asin","asin"))},u.asinh=l=>{l.compute(s(l.inputs[0],"Asinh","asinh"))},u.atan=l=>{l.compute(s(l.inputs[0],"Atan","atan"))},u.atanh=l=>{l.compute(s(l.inputs[0],"Atanh","atanh"))},u.clipV10=(l,p)=>{l.compute(s(l.inputs[0],"Clip",a=>`clamp(${a}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<f32> = vec4(f32(${p.min}));
    const clip_max_: vec4<f32> = vec4(f32(${p.max}));
`,p.cacheKey),{inputs:[0]})},u.clip=l=>{const p=(a=>{const i=a.length>=2?a[1].getFloat32Array()[0]:m.MIN_CLIP,e=a.length>=3?a[2].getFloat32Array()[0]:m.MAX_CLIP;return(0,h.createAttributeWithCacheKey)({min:i,max:e})})(l.inputs);(0,u.clipV10)(l,p)},u.ceil=l=>{l.compute(s(l.inputs[0],"Ceil","ceil"))},u.cos=l=>{l.compute(s(l.inputs[0],"Cos","cos"))},u.cosh=l=>{l.compute(s(l.inputs[0],"Cosh","cosh"))},u.parseAlphaAttributes=l=>(0,h.createAttributeWithCacheKey)(l),u.elu=(l,p)=>{l.compute(s(l.inputs[0],"Elu",a=>`elu_vf32(${a})`,`
  const elu_alpha_: f32 = f32(${p.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,p.cacheKey))},u.erf=l=>{l.compute(s(l.inputs[0],"Erf",p=>`erf_vf32(${p})`,`
  const r0: f32 = 0.3275911;
  const r1: f32 = 0.254829592;
  const r2: f32 = -0.284496736;
  const r3: f32 = 1.421413741;
  const r4: f32 = -1.453152027;
  const r5: f32 = 1.061405429;

  fn erf_vf32(v: vec4<f32>) -> vec4<f32> {
    let absv = abs(v);
    let x = 1.0 / (1.0 + r0 * absv);
    return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
  }`))},u.exp=l=>{l.compute(s(l.inputs[0],"Exp","exp"))},u.floor=l=>{l.compute(s(l.inputs[0],"Floor","floor"))},u.leakyRelu=(l,p)=>{l.compute(s(l.inputs[0],"LeakyRelu",a=>`select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${p.alpha});`,p.cacheKey))},u.neg=l=>{l.compute(s(l.inputs[0],"Neg",p=>`-${p}`))},u.reciprocal=l=>{l.compute(s(l.inputs[0],"Reciprocal",p=>`1.0/${p}`))},u.relu=l=>{l.compute(s(l.inputs[0],"Relu",p=>`select(vec4<f32>(0.0), ${p}, ${p} > vec4<f32>(0.0))`))},u.sigmoid=l=>{l.compute(s(l.inputs[0],"Sigmoid",p=>`(1.0 / (1.0 + exp(-${p})))`))},u.sin=l=>{l.compute(s(l.inputs[0],"Sin","sin"))},u.sinh=l=>{l.compute(s(l.inputs[0],"Sinh","sinh"))},u.sqrt=l=>{l.compute(s(l.inputs[0],"Sqrt","sqrt"))},u.tan=l=>{l.compute(s(l.inputs[0],"Tan","tan"))},u.tanh=l=>{l.compute(s(l.inputs[0],"Tanh","tanh"))},u.thresholdedRelu=(l,p)=>(l.compute(s(l.inputs[0],"ThresholdedRelu",a=>`select(vec4<f32>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${p.alpha});`,p.cacheKey)),0)},8305:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.ProgramManager=void 0;const m=y(4955),h=y(2075);u.ProgramManager=class{constructor(f){this.backend=f,this.repo=new Map,this.attributesBound=!1}getArtifact(f){return this.repo.get(f)}setArtifact(f,s){this.repo.set(f,s)}run(f,s,l,p){const a=this.backend.device,i=this.backend.getComputePassEncoder();this.backend.profilingEnabled&&i.writeTimestamp(this.backend.profilingQuerySet,0),i.setPipeline(f.computePipeline);const e=[];for(const n of s)e.push({binding:e.length,resource:{buffer:n.buffer}});for(const n of l)e.push({binding:e.length,resource:{buffer:n.buffer}});const t=a.createBindGroup({layout:f.computePipeline.getBindGroupLayout(0),entries:e});if(i.setBindGroup(0,t),i.dispatchWorkgroups(...p),this.backend.pendingDispatchNumber++,this.backend.profilingEnabled){i.writeTimestamp(this.backend.profilingQuerySet,1);const n=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),r=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,n.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(n.buffer,0,r.buffer,0,16),this.backend.flush();const o=this.backend.currentKernelId,c=this.backend.kernels.get(o)[0];r.buffer.mapAsync(GPUMapMode.READ).then(()=>{const d=new BigUint64Array(r.buffer.getMappedRange()),g=d[0],b=d[1];r.buffer.unmap(),this.backend.profilingTimeBase===void 0&&(this.backend.profilingTimeBase=g);const v=Number(g-this.backend.profilingTimeBase),w=Number(b-this.backend.profilingTimeBase);if(!Number.isSafeInteger(v)||!Number.isSafeInteger(w))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(n.id),this.backend.gpuDataManager.release(r.id),console.log(`[profiling] kernel "${o}|${c}" execution time: ${w-v} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(f,s){const l=this.backend.device,p=f.getShaderSource((0,h.createShaderHelper)(s)),a=l.createShaderModule({code:p});return(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] shader code: ${p}`),{programInfo:f,computePipeline:l.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(f){const s=typeof f=="number"?f:f.x,l=typeof f=="number"?1:f.y||1,p=typeof f=="number"?1:f.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(s<=a&&l<=a&&p<=a)return[s,l,p];const i=s*l*p;let e=Math.ceil(Math.sqrt(i));if(e>a){if(e=Math.ceil(Math.cbrt(i)),e>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[e,e,e]}return[e,e,1]}}},1163:(R,u)=>{var y;Object.defineProperty(u,"__esModule",{value:!0}),u.GpuDataType=void 0,(y=u.GpuDataType||(u.GpuDataType={}))[y.default=0]="default",y[y.upload=1]="upload",y[y.profile=2]="profile"},3899:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.iterateExtraOptions=void 0,u.iterateExtraOptions=(y,m,h,f)=>{if(typeof y=="object"&&y!==null){if(h.has(y))throw new Error("Circular reference in options");h.add(y)}Object.entries(y).forEach(([s,l])=>{const p=m?m+s:s;if(typeof l=="object")(0,u.iterateExtraOptions)(l,p+".",h,f);else if(typeof l=="string"||typeof l=="number")f(p,l.toString());else{if(typeof l!="boolean")throw new Error("Can't handle extra config type: "+typeof l);f(p,l?"1":"0")}})}},9544:function(R,u,y){var m,h=this&&this.__createBinding||(Object.create?function(E,C,D,$){$===void 0&&($=D);var L=Object.getOwnPropertyDescriptor(C,D);L&&!("get"in L?!C.__esModule:L.writable||L.configurable)||(L={enumerable:!0,get:function(){return C[D]}}),Object.defineProperty(E,$,L)}:function(E,C,D,$){$===void 0&&($=D),E[$]=C[D]}),f=this&&this.__setModuleDefault||(Object.create?function(E,C){Object.defineProperty(E,"default",{enumerable:!0,value:C})}:function(E,C){E.default=C}),s=this&&this.__importStar||function(E){if(E&&E.__esModule)return E;var C={};if(E!=null)for(var D in E)D!=="default"&&Object.prototype.hasOwnProperty.call(E,D)&&h(C,E,D);return f(C,E),C};Object.defineProperty(u,"__esModule",{value:!0}),u.endProfiling=u.run=u.releaseSession=u.createSession=u.createSessionFinalize=u.createSessionAllocate=u.initOrt=u.initWasm=void 0;const l=y(8453),p=y(7675),a=s(y(1259)),i=y(263),e=()=>!!l.env.wasm.proxy&&typeof document<"u";let t,n,r,o=!1,c=!1,d=!1;const g=[],b=[],v=[],w=[],x=[],T=[],S=()=>{if(o||!c||d||!t)throw new Error("worker not ready")},_=E=>{switch(E.data.type){case"init-wasm":o=!1,E.data.err?(d=!0,n[1](E.data.err)):(c=!0,n[0]());break;case"init-ort":E.data.err?r[1](E.data.err):r[0]();break;case"create_allocate":E.data.err?g.shift()[1](E.data.err):g.shift()[0](E.data.out);break;case"create_finalize":E.data.err?b.shift()[1](E.data.err):b.shift()[0](E.data.out);break;case"create":E.data.err?v.shift()[1](E.data.err):v.shift()[0](E.data.out);break;case"release":E.data.err?w.shift()[1](E.data.err):w.shift()[0]();break;case"run":E.data.err?x.shift()[1](E.data.err):x.shift()[0](E.data.out);break;case"end-profiling":E.data.err?T.shift()[1](E.data.err):T.shift()[0]()}},A=typeof document<"u"?(m=document==null?void 0:document.currentScript)===null||m===void 0?void 0:m.src:void 0;u.initWasm=async()=>{if(e()){if(c)return;if(o)throw new Error("multiple calls to 'initWasm()' detected.");if(d)throw new Error("previous call to 'initWasm()' failed.");return o=!0,l.env.wasm.wasmPaths===void 0&&A&&A.indexOf("blob:")!==0&&(l.env.wasm.wasmPaths=A.substr(0,+A.lastIndexOf("/")+1)),new Promise((E,C)=>{t==null||t.terminate(),t=y(8050).Z(),t.onmessage=_,n=[E,C];const D={type:"init-wasm",in:l.env.wasm};t.postMessage(D)})}return(0,i.initializeWebAssembly)(l.env.wasm)},u.initOrt=async(E,C)=>{if(e())return S(),new Promise((D,$)=>{r=[D,$];const L={type:"init-ort",in:{numThreads:E,loggingLevel:C}};t.postMessage(L)});a.initOrt(E,C),await(0,p.init)((0,i.getInstance)())},u.createSessionAllocate=async E=>e()?(S(),new Promise((C,D)=>{g.push([C,D]);const $={type:"create_allocate",in:{model:E}};t.postMessage($,[E.buffer])})):a.createSessionAllocate(E),u.createSessionFinalize=async(E,C)=>e()?(S(),new Promise((D,$)=>{b.push([D,$]);const L={type:"create_finalize",in:{modeldata:E,options:C}};t.postMessage(L)})):a.createSessionFinalize(E,C),u.createSession=async(E,C)=>e()?(S(),new Promise((D,$)=>{v.push([D,$]);const L={type:"create",in:{model:E,options:C}};t.postMessage(L,[E.buffer])})):a.createSession(E,C),u.releaseSession=async E=>{if(e())return S(),new Promise((C,D)=>{w.push([C,D]);const $={type:"release",in:E};t.postMessage($)});a.releaseSession(E)},u.run=async(E,C,D,$,L)=>e()?(S(),new Promise((P,k)=>{x.push([P,k]);const V={type:"run",in:{sessionId:E,inputIndices:C,inputs:D,outputIndices:$,options:L}};t.postMessage(V,a.extractTransferableBuffers(D))})):a.run(E,C,D,$,L),u.endProfiling=async E=>{if(e())return S(),new Promise((C,D)=>{T.push([C,D]);const $={type:"end-profiling",in:E};t.postMessage($)});a.endProfiling(E)}},7918:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.setRunOptions=void 0;const m=y(3899),h=y(9444),f=y(263);u.setRunOptions=s=>{const l=(0,f.getInstance)();let p=0;const a=[],i=s||{};try{if((s==null?void 0:s.logSeverityLevel)===void 0)i.logSeverityLevel=2;else if(typeof s.logSeverityLevel!="number"||!Number.isInteger(s.logSeverityLevel)||s.logSeverityLevel<0||s.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${s.logSeverityLevel}`);if((s==null?void 0:s.logVerbosityLevel)===void 0)i.logVerbosityLevel=0;else if(typeof s.logVerbosityLevel!="number"||!Number.isInteger(s.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${s.logVerbosityLevel}`);(s==null?void 0:s.terminate)===void 0&&(i.terminate=!1);let e=0;if((s==null?void 0:s.tag)!==void 0&&(e=(0,h.allocWasmString)(s.tag,a)),p=l._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,e),p===0)throw new Error("Can't create run options");return(s==null?void 0:s.extra)!==void 0&&(0,m.iterateExtraOptions)(s.extra,"",new WeakSet,(t,n)=>{const r=(0,h.allocWasmString)(t,a),o=(0,h.allocWasmString)(n,a);if(l._OrtAddRunConfigEntry(p,r,o)!==0)throw new Error(`Can't set a run config entry: ${t} - ${n}`)}),[p,a]}catch(e){throw p!==0&&l._OrtReleaseRunOptions(p),a.forEach(l._free),e}}},6640:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.OnnxruntimeWebAssemblySessionHandler=void 0;const m=y(2806),h=y(8453),f=y(2850),s=y(9544),l=y(7917);let p;u.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(a){const i=await fetch(a),e=await i.arrayBuffer();return(0,s.createSessionAllocate)(new Uint8Array(e))}async loadModel(a,i){if(p||(await(0,s.initOrt)(h.env.wasm.numThreads,(0,l.logLevelStringToEnum)(h.env.logLevel)),p=!0),typeof a=="string")if(typeof fetch>"u"){const e=await(0,f.promisify)(m.readFile)(a);[this.sessionId,this.inputNames,this.outputNames]=await(0,s.createSession)(e,i)}else{const e=await this.createSessionAllocate(a);[this.sessionId,this.inputNames,this.outputNames]=await(0,s.createSessionFinalize)(e,i)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,s.createSession)(a,i)}async dispose(){return(0,s.releaseSession)(this.sessionId)}async run(a,i,e){const t=[],n=[];Object.entries(a).forEach(d=>{const g=d[0],b=d[1],v=this.inputNames.indexOf(g);if(v===-1)throw new Error(`invalid input '${g}'`);t.push(b),n.push(v)});const r=[];Object.entries(i).forEach(d=>{const g=d[0],b=this.outputNames.indexOf(g);if(b===-1)throw new Error(`invalid output '${g}'`);r.push(b)});const o=await(0,s.run)(this.sessionId,n,t.map(d=>[d.type,d.dims,d.data]),r,e),c={};for(let d=0;d<o.length;d++)c[this.outputNames[r[d]]]=new h.Tensor(o[d][0],o[d][2],o[d][1]);return c}startProfiling(){}endProfiling(){(0,s.endProfiling)(this.sessionId)}}},7622:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.setSessionOptions=void 0;const m=y(3899),h=y(9444),f=y(263);u.setSessionOptions=s=>{var l,p,a,i;const e=(0,f.getInstance)();let t=0;const n=[],r=s||{};(o=>{o.extra||(o.extra={}),o.extra.session||(o.extra.session={});const c=o.extra.session;c.use_ort_model_bytes_directly||(c.use_ort_model_bytes_directly="1"),o.executionProviders&&o.executionProviders.some(d=>(typeof d=="string"?d:d.name)==="webgpu")&&(o.enableMemPattern=!1)})(r);try{const o=(w=>{switch(w){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${w}`)}})((l=r.graphOptimizationLevel)!==null&&l!==void 0?l:"all"),c=(w=>{switch(w){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${w}`)}})((p=r.executionMode)!==null&&p!==void 0?p:"sequential"),d=typeof r.logId=="string"?(0,h.allocWasmString)(r.logId,n):0,g=(a=r.logSeverityLevel)!==null&&a!==void 0?a:2;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log serverity level is not valid: ${g}`);const b=(i=r.logVerbosityLevel)!==null&&i!==void 0?i:0;if(!Number.isInteger(b)||b<0||b>4)throw new Error(`log verbosity level is not valid: ${b}`);const v=typeof r.optimizedModelFilePath=="string"?(0,h.allocWasmString)(r.optimizedModelFilePath,n):0;if(t=e._OrtCreateSessionOptions(o,!!r.enableCpuMemArena,!!r.enableMemPattern,c,!!r.enableProfiling,0,d,g,b,v),t===0)throw new Error("Can't create session options");return r.executionProviders&&((w,x,T)=>{for(const S of x){let _=typeof S=="string"?S:S.name;switch(_){case"xnnpack":_="XNNPACK";break;case"webgpu":_="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${_}`)}const A=(0,h.allocWasmString)(_,T);if((0,f.getInstance)()._OrtAppendExecutionProvider(w,A)!==0)throw new Error(`Can't append execution provider: ${_}`)}})(t,r.executionProviders,n),r.extra!==void 0&&(0,m.iterateExtraOptions)(r.extra,"",new WeakSet,(w,x)=>{const T=(0,h.allocWasmString)(w,n),S=(0,h.allocWasmString)(x,n);if(e._OrtAddSessionConfigEntry(t,T,S)!==0)throw new Error(`Can't set a session config entry: ${w} - ${x}`)}),[t,n]}catch(o){throw t!==0&&e._OrtReleaseSessionOptions(t),n.forEach(e._free),o}}},9444:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.allocWasmString=void 0;const m=y(263);u.allocWasmString=(h,f)=>{const s=(0,m.getInstance)(),l=s.lengthBytesUTF8(h)+1,p=s._malloc(l);return s.stringToUTF8(h,p,l),f.push(p),p}},7917:(R,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.logLevelStringToEnum=u.tensorTypeToTypedArrayConstructor=u.getTensorElementSize=u.tensorDataTypeEnumToString=u.tensorDataTypeStringToEnum=void 0,u.tensorDataTypeStringToEnum=y=>{switch(y){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${y}`)}},u.tensorDataTypeEnumToString=y=>{switch(y){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${y}`)}},u.getTensorElementSize=y=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][y],u.tensorTypeToTypedArrayConstructor=y=>{switch(y){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${y}`)}},u.logLevelStringToEnum=y=>{switch(y){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${y}`)}}},1259:(R,u,y)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.extractTransferableBuffers=u.endProfiling=u.run=u.releaseSession=u.createSession=u.createSessionFinalize=u.createSessionAllocate=u.initOrt=void 0;const m=y(7918),h=y(7622),f=y(9444),s=y(7917),l=y(263);u.initOrt=(a,i)=>{const e=(0,l.getInstance)()._OrtInit(a,i);if(e!==0)throw new Error(`Can't initialize onnxruntime. error code = ${e}`)};const p=new Map;u.createSessionAllocate=a=>{const i=(0,l.getInstance)(),e=i._malloc(a.byteLength);return i.HEAPU8.set(a,e),[e,a.byteLength]},u.createSessionFinalize=(a,i)=>{const e=(0,l.getInstance)();let t=0,n=0,r=[];try{if([n,r]=(0,h.setSessionOptions)(i),t=e._OrtCreateSession(a[0],a[1],n),t===0)throw new Error("Can't create a session")}finally{e._free(a[0]),n!==0&&e._OrtReleaseSessionOptions(n),r.forEach(e._free)}const o=e._OrtGetInputCount(t),c=e._OrtGetOutputCount(t),d=[],g=[],b=[],v=[];for(let w=0;w<o;w++){const x=e._OrtGetInputName(t,w);if(x===0)throw new Error("Can't get an input name");g.push(x),d.push(e.UTF8ToString(x))}for(let w=0;w<c;w++){const x=e._OrtGetOutputName(t,w);if(x===0)throw new Error("Can't get an output name");v.push(x),b.push(e.UTF8ToString(x))}return p.set(t,[t,g,v]),[t,d,b]},u.createSession=(a,i)=>{const e=(0,u.createSessionAllocate)(a);return(0,u.createSessionFinalize)(e,i)},u.releaseSession=a=>{const i=(0,l.getInstance)(),e=p.get(a);if(!e)throw new Error("invalid session id");const t=e[0],n=e[1],r=e[2];n.forEach(i._OrtFree),r.forEach(i._OrtFree),i._OrtReleaseSession(t),p.delete(a)},u.run=async(a,i,e,t,n)=>{const r=(0,l.getInstance)(),o=p.get(a);if(!o)throw new Error("invalid session id");const c=o[0],d=o[1],g=o[2],b=i.length,v=t.length;let w=0,x=[];const T=[],S=[];try{[w,x]=(0,m.setRunOptions)(n);for(let $=0;$<b;$++){const L=e[$][0],P=e[$][1],k=e[$][2];let V,z;if(Array.isArray(k)){z=4*k.length,V=r._malloc(z),S.push(V);let tt=V/4;for(let rt=0;rt<k.length;rt++){if(typeof k[rt]!="string")throw new TypeError(`tensor data at index ${rt} is not a string`);r.HEAPU32[tt++]=(0,f.allocWasmString)(k[rt],S)}}else z=k.byteLength,V=r._malloc(z),S.push(V),r.HEAPU8.set(new Uint8Array(k.buffer,k.byteOffset,z),V);const J=r.stackSave(),q=r.stackAlloc(4*P.length);try{let tt=q/4;P.forEach(Z=>r.HEAP32[tt++]=Z);const rt=r._OrtCreateTensor((0,s.tensorDataTypeStringToEnum)(L),V,z,q,P.length);if(rt===0)throw new Error("Can't create a tensor");T.push(rt)}finally{r.stackRestore(J)}}const _=r.stackSave(),A=r.stackAlloc(4*b),E=r.stackAlloc(4*b),C=r.stackAlloc(4*v),D=r.stackAlloc(4*v);try{let $=A/4,L=E/4,P=C/4,k=D/4;for(let q=0;q<b;q++)r.HEAPU32[$++]=T[q],r.HEAPU32[L++]=d[i[q]];for(let q=0;q<v;q++)r.HEAPU32[P++]=0,r.HEAPU32[k++]=g[t[q]];let V=r._OrtRun(c,E,A,b,D,v,C,w);const z=r.jsepRunPromise;z&&z.then!==void 0&&(V=await z);const J=[];if(V===0)for(let q=0;q<v;q++){const tt=r.HEAPU32[C/4+q],rt=r.stackSave(),Z=r.stackAlloc(16);let at,st=0;try{if(V=r._OrtGetTensorData(tt,Z,Z+4,Z+8,Z+12),V!==0)throw new Error(`Can't access output tensor data. error code = ${V}`);let et=Z/4;const dt=r.HEAPU32[et++];st=r.HEAPU32[et++];const nt=r.HEAPU32[et++],gt=r.HEAPU32[et++],ct=[];for(let ut=0;ut<gt;ut++)ct.push(r.HEAPU32[nt/4+ut]);r._OrtFree(nt);const mt=ct.length===0?1:ct.reduce((ut,wt)=>ut*wt);if(at=(0,s.tensorDataTypeEnumToString)(dt),at==="string"){const ut=[];let wt=st/4;for(let Et=0;Et<mt;Et++){const kt=r.HEAPU32[wt++],Ct=Et===mt-1?void 0:r.HEAPU32[wt]-kt;ut.push(r.UTF8ToString(kt,Ct))}J.push([at,ct,ut])}else{const ut=new((0,s.tensorTypeToTypedArrayConstructor)(at))(mt);new Uint8Array(ut.buffer,ut.byteOffset,ut.byteLength).set(r.HEAPU8.subarray(st,st+ut.byteLength)),J.push([at,ct,ut])}}finally{r.stackRestore(rt),at==="string"&&st&&r._free(st),r._OrtReleaseTensor(tt)}}if(V===0)return J;throw new Error(`failed to call OrtRun(). error code = ${V}.`)}finally{r.stackRestore(_)}}finally{T.forEach(r._OrtReleaseTensor),S.forEach(r._free),r._OrtReleaseRunOptions(w),x.forEach(r._free)}},u.endProfiling=a=>{const i=(0,l.getInstance)(),e=p.get(a);if(!e)throw new Error("invalid session id");const t=e[0],n=i._OrtEndProfiling(t);if(n===0)throw new Error("Can't get an profile file name");i._OrtFree(n)},u.extractTransferableBuffers=a=>{const i=[];for(const e of a){const t=e[2];!Array.isArray(t)&&t.buffer&&i.push(t.buffer)}return i}},263:function(R,u,y){var m=this&&this.__createBinding||(Object.create?function(n,r,o,c){c===void 0&&(c=o);var d=Object.getOwnPropertyDescriptor(r,o);d&&!("get"in d?!r.__esModule:d.writable||d.configurable)||(d={enumerable:!0,get:function(){return r[o]}}),Object.defineProperty(n,c,d)}:function(n,r,o,c){c===void 0&&(c=o),n[c]=r[o]}),h=this&&this.__setModuleDefault||(Object.create?function(n,r){Object.defineProperty(n,"default",{enumerable:!0,value:r})}:function(n,r){n.default=r}),f=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var r={};if(n!=null)for(var o in n)o!=="default"&&Object.prototype.hasOwnProperty.call(n,o)&&m(r,n,o);return h(r,n),r};Object.defineProperty(u,"__esModule",{value:!0}),u.dispose=u.getInstance=u.initializeWebAssembly=void 0;const s=f(y(6449)),l=y(932),p=y(3474);let a,i=!1,e=!1,t=!1;u.initializeWebAssembly=async n=>{if(i)return Promise.resolve();if(e)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(t)throw new Error("previous call to 'initializeWebAssembly()' failed.");e=!0;const r=n.initTimeout,o=n.numThreads,c=n.simd,d=o>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),g=c&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),b=n.wasmPaths,v=typeof b=="string"?b:void 0,w=((_,A)=>A?_?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":_?"ort-wasm-simd.wasm":"ort-wasm.wasm")(g,d),x=typeof b=="object"?b[w]:void 0;let T=!1;const S=[];if(r>0&&S.push(new Promise(_=>{setTimeout(()=>{T=!0,_()},r)})),S.push(new Promise((_,A)=>{const E=d?p:l,C={locateFile:(D,$)=>d&&D.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([y(4154)],{type:"text/javascript"})):D.endsWith(".wasm")?x||(v??$)+w:$+D};if(d)if(typeof Blob>"u")C.mainScriptUrlOrBlob=s.join("/","ort-wasm-threaded.js");else{const D=`var ortWasmThreaded=(function(){var _scriptDir;return ${E.toString()}})();`;C.mainScriptUrlOrBlob=new Blob([D],{type:"text/javascript"})}E(C).then(D=>{e=!1,i=!0,a=D,_()},D=>{e=!1,t=!0,A(D)})})),await Promise.race(S),T)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},u.getInstance=()=>{if(i&&a)return a;throw new Error("WebAssembly is not initialized yet.")},u.dispose=()=>{var n;!i||e||t||(e=!0,(n=a.PThread)===null||n===void 0||n.terminateAllThreads(),a=void 0,e=!1,i=!1,t=!0)}},8050:(R,u,y)=>{y.d(u,{Z:()=>f});var m=y(6614),h=y.n(m);function f(){return h()('/*!\n* ONNX Runtime Web v1.15.1\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={899:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const i=n?n+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",r,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))}},918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setRunOptions=e=>{const t=(0,o.getInstance)();let n=0;const i=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==e?void 0:e.tag)&&(o=(0,a.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can\'t create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(r,i);if(0!==t._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can\'t set a run config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setSessionOptions=e=>{var t,n,i,s;const u=(0,o.getInstance)();let c=0;const l=[],f=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(f);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=f.graphOptimizationLevel)&&void 0!==t?t:"all"),p=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=f.executionMode)&&void 0!==n?n:"sequential"),d="string"==typeof f.logId?(0,a.allocWasmString)(f.logId,l):0,m=null!==(i=f.logSeverityLevel)&&void 0!==i?i:2;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log serverity level is not valid: ${m}`);const g=null!==(s=f.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof f.optimizedModelFilePath?(0,a.allocWasmString)(f.optimizedModelFilePath,l):0;if(c=u._OrtCreateSessionOptions(e,!!f.enableCpuMemArena,!!f.enableMemPattern,p,!!f.enableProfiling,0,d,m,g,h),0===c)throw new Error("Can\'t create session options");return f.executionProviders&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,a.allocWasmString)(t,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can\'t append execution provider: ${t}`)}})(c,f.executionProviders,l),void 0!==f.extra&&(0,r.iterateExtraOptions)(f.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);if(0!==u._OrtAddSessionConfigEntry(c,n,r))throw new Error(`Can\'t set a session config entry: ${e} - ${t}`)})),[c,l]}catch(e){throw 0!==c&&u._OrtReleaseSessionOptions(c),l.forEach(u._free),e}}},444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,o=n._malloc(a);return n.stringToUTF8(e,o,a),t.push(o),o}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(918),a=n(622),o=n(444),i=n(917),s=n(263);t.initOrt=(e,t)=>{const n=(0,s.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,o=0,i=[];try{if([o,i]=(0,a.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],o),0===r)throw new Error("Can\'t create a session")}finally{n._free(e[0]),0!==o&&n._OrtReleaseSessionOptions(o),i.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],d=[],m=[];for(let e=0;e<c;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can\'t get an input name");p.push(t),f.push(n.UTF8ToString(t))}for(let e=0;e<l;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can\'t get an output name");m.push(t),d.push(n.UTF8ToString(t))}return u.set(r,[r,p,m]),[r,f,d]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],o=n[2];a.forEach(t._OrtFree),o.forEach(t._OrtFree),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,a,c)=>{const l=(0,s.getInstance)(),f=u.get(e);if(!f)throw new Error("invalid session id");const p=f[0],d=f[1],m=f[2],g=t.length,h=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,r.setRunOptions)(c);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let s,u;if(Array.isArray(a)){u=4*a.length,s=l._malloc(u),w.push(s);let e=s/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,o.allocWasmString)(a[t],w)}}else u=a.byteLength,s=l._malloc(u),w.push(s),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),s);const c=l.stackSave(),f=l.stackAlloc(4*r.length);try{let e=f/4;r.forEach((t=>l.HEAP32[e++]=t));const n=l._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),s,u,f,r.length);if(0===n)throw new Error("Can\'t create a tensor");b.push(n)}finally{l.stackRestore(c)}}const e=l.stackSave(),s=l.stackAlloc(4*g),u=l.stackAlloc(4*g),f=l.stackAlloc(4*h),_=l.stackAlloc(4*h);try{let e=s/4,n=u/4,r=f/4,o=_/4;for(let r=0;r<g;r++)l.HEAPU32[e++]=b[r],l.HEAPU32[n++]=d[t[r]];for(let e=0;e<h;e++)l.HEAPU32[r++]=0,l.HEAPU32[o++]=m[a[e]];let c=l._OrtRun(p,u,s,g,_,h,f,y);const v=l.jsepRunPromise;v&&void 0!==v.then&&(c=await v);const w=[];if(0===c)for(let e=0;e<h;e++){const t=l.HEAPU32[f/4+e],n=l.stackSave(),r=l.stackAlloc(16);let a,o=0;try{if(c=l._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==c)throw new Error(`Can\'t access output tensor data. error code = ${c}`);let e=r/4;const n=l.HEAPU32[e++];o=l.HEAPU32[e++];const s=l.HEAPU32[e++],u=l.HEAPU32[e++],f=[];for(let e=0;e<u;e++)f.push(l.HEAPU32[s/4+e]);l._OrtFree(s);const p=0===f.length?1:f.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(n),"string"===a){const e=[];let t=o/4;for(let n=0;n<p;n++){const r=l.HEAPU32[t++],a=n===p-1?void 0:l.HEAPU32[t]-r;e.push(l.UTF8ToString(r,a))}w.push([a,f,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(o,o+e.byteLength)),w.push([a,f,e])}}finally{l.stackRestore(n),"string"===a&&o&&l._free(o),l._OrtReleaseTensor(t)}}if(0===c)return w;throw new Error(`failed to call OrtRun(). error code = ${c}.`)}finally{l.stackRestore(e)}}finally{b.forEach(l._OrtReleaseTensor),w.forEach(l._free),l._OrtReleaseRunOptions(y),v.forEach(l._free)}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(n(449)),s=n(932),u=n(474);let c,l=!1,f=!1,p=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(p)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),d=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),m=e.wasmPaths,g="string"==typeof m?m:void 0,h=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(d,o),y="object"==typeof m?m[h]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const r=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=g?g:t)+h:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,p=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||p||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,p=!0)}},474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return P.buffer!=D&&G(P.buffer),F}function r(){return P.buffer!=D&&G(P.buffer),U}function a(){return P.buffer!=D&&G(P.buffer),I}function o(){return P.buffer!=D&&G(P.buffer),W}function i(){return P.buffer!=D&&G(P.buffer),j}var s,u,c;e=e||{},s||(s=void 0!==e?e:{}),s.ready=new Promise((function(e,t){u=e,c=t}));var l,f,p,d,m,g,h=Object.assign({},s),y="./this.program",v=(e,t)=>{throw t},b="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=s.ENVIRONMENT_IS_PTHREAD||!1,S="";function T(e){return s.locateFile?s.locateFile(e,S):S+e}if(_){let t;S=w?n(908).dirname(S)+"/":"//",g=()=>{m||(d=n(384),m=n(908))},l=function(e,t){return g(),e=m.normalize(e),d.readFileSync(e,t?void 0:"utf8")},p=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n)=>{g(),e=m.normalize(e),d.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ie))throw e})),process.on("unhandledRejection",(function(e){throw e})),v=(e,t)=>{if(C)throw process.exitCode=e,t;t instanceof ie||x("exiting due to exception: "+t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"};try{t=n(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}n.g.Worker=t.Worker}else(b||w)&&(w?S=self.location.href:"undefined"!=typeof document&&document.currentScript&&(S=document.currentScript.src),_scriptDir&&(S=_scriptDir),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},w&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var A=console.log.bind(console),E=console.warn.bind(console);_&&(g(),A=e=>d.writeSync(1,e+"\\n"),E=e=>d.writeSync(2,e+"\\n"));var M,R=s.print||A,x=s.printErr||E;Object.assign(s,h),h=null,s.thisProgram&&(y=s.thisProgram),s.quit&&(v=s.quit),s.wasmBinary&&(M=s.wasmBinary);var C=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var P,k,D,F,U,I,W,j,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function Y(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&L)return L.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function z(e,t){return(e>>>=0)?Y(r(),e,t):""}function B(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function N(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function G(e){D=e,s.HEAP8=F=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=I=new Int32Array(e),s.HEAPU8=U=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=W=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=j=new Float64Array(e)}O&&(D=s.buffer);var q=s.INITIAL_MEMORY||16777216;if(O)P=s.wasmMemory,D=s.buffer;else if(s.wasmMemory)P=s.wasmMemory;else if(!((P=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");P&&(D=P.buffer),q=D.byteLength,G(D);var $,V=[],J=[],Q=[];function X(){var e=s.preRun.shift();V.unshift(e)}var K,Z=0,ee=null,te=null;function ne(e){throw O?postMessage({cmd:"onAbort",arg:e}):s.onAbort&&s.onAbort(e),x(e="Aborted("+e+")"),H=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}function re(){return K.startsWith("data:application/octet-stream;base64,")}function ae(){var e=K;try{if(e==K&&M)return new Uint8Array(M);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}K="ort-wasm-threaded.wasm",re()||(K=T(K));var oe={};function ie(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){(e=fe.La[e])||ne(),fe.Xa(e)}function ue(e){var t=fe.lb();if(!t)return 6;fe.Ra.push(t),fe.La[e.Ka]=t,t.Ka=e.Ka;var n={cmd:"run",start_routine:e.pb,arg:e.ib,pthread_ptr:e.Ka};return t.Qa=()=>{n.time=performance.now(),t.postMessage(n,e.vb)},t.loaded&&(t.Qa(),delete t.Qa),0}function ce(e){if(O)return He(1,1,e);C||(fe.qb(),s.onExit&&s.onExit(e),H=!0),v(e,new ie(e))}function le(e,t){if(!t&&O)throw de(e),"unwind";ce(e)}var fe={Oa:[],Ra:[],$a:[],La:{},Ua:function(){O&&fe.mb()},xb:function(){},mb:function(){fe.receiveObjectTransfer=fe.ob,fe.threadInitTLS=fe.Za,fe.setExitStatus=fe.Ya,C=!1},Ya:function(){},qb:function(){for(var e of Object.values(fe.La))fe.Xa(e);for(e of fe.Oa)e.terminate();fe.Oa=[]},Xa:function(e){var t=e.Ka;delete fe.La[t],fe.Oa.push(e),fe.Ra.splice(fe.Ra.indexOf(e),1),e.Ka=0,ct(t)},ob:function(){},Za:function(){fe.$a.forEach((e=>e()))},nb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ka&&(fe.kb=e.Ka),n.targetThread&&n.targetThread!=rt()){var a=fe.La[n.yb];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?De(n.queue):"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=fe.La[n],delete fe.La[n],r.terminate(),ct(n),fe.Ra.splice(fe.Ra.indexOf(r),1),r.Ka=0):"cancelThread"===r?fe.La[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Qa&&(e.Qa(),delete e.Qa)):"print"===r?R("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&x("worker sent an unknown command "+r);fe.kb=void 0},e.onerror=e=>{throw x("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},_&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:P,wasmModule:k})},hb:function(){var e=T("ort-wasm-threaded.worker.js");fe.Oa.push(new Worker(e))},lb:function(){return 0==fe.Oa.length&&(fe.hb(),fe.nb(fe.Oa[0])),fe.Oa.pop()}};function pe(e){for(;0<e.length;)e.shift()(s)}function de(e){if(O)return He(2,0,e);try{le(e)}catch(e){e instanceof ie||"unwind"==e||v(1,e)}}s.PThread=fe,s.establishStackSpace=function(){var e=rt(),t=a()[e+44>>2>>>0];e=a()[e+48>>2>>>0],ft(t,t-e),dt(t)};var me,ge,he=[];function ye(e){this.Pa=e-24,this.gb=function(e){o()[this.Pa+4>>2>>>0]=e},this.cb=function(e){o()[this.Pa+8>>2>>>0]=e},this.eb=function(){a()[this.Pa>>2>>>0]=0},this.bb=function(){t()[this.Pa+12>>0>>>0]=0},this.fb=function(){t()[this.Pa+13>>0>>>0]=0},this.Ua=function(e,t){this.ab(),this.gb(e),this.cb(t),this.eb(),this.bb(),this.fb()},this.ab=function(){o()[this.Pa+16>>2>>>0]=0}}function ve(e,t,n,r){return O?He(3,1,e,t,n,r):be(e,t,n,r)}function be(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?ve(e,t,n,r):(e={pb:n,Ka:e,ib:r,vb:a},O?(e.wb="spawnThread",postMessage(e,a),0):ue(e))}function we(e,t,n){return O?He(4,1,e,t,n):0}function _e(e,t){if(O)return He(5,1,e,t)}function Oe(e,t){if(O)return He(6,1,e,t)}function Se(e,t,n){if(O)return He(7,1,e,t,n)}function Te(e,t,n){return O?He(8,1,e,t,n):0}function Ae(e,t){if(O)return He(9,1,e,t)}function Ee(e,t,n){if(O)return He(10,1,e,t,n)}function Me(e,t,n,r){if(O)return He(11,1,e,t,n,r)}function Re(e,t,n,r){if(O)return He(12,1,e,t,n,r)}function xe(e,t,n,r){if(O)return He(13,1,e,t,n,r)}function Ce(e){if(O)return He(14,1,e)}function Pe(e,t){if(O)return He(15,1,e,t)}function ke(e,t,n){if(O)return He(16,1,e,t,n)}function De(e){Atomics.store(a(),e>>2,1),rt()&&ut(e),Atomics.compareExchange(a(),e>>2,1,0)}function Fe(e){return o()[e>>>2]+4294967296*a()[e+4>>>2]}function Ue(e,t,n,r,a,o){return O?He(17,1,e,t,n,r,a,o):-52}function Ie(e,t,n,r,a,o){if(O)return He(18,1,e,t,n,r,a,o)}function We(e){var n=N(e)+1,r=at(n);return r&&B(e,t(),r,n),r}function je(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}if(O)return He(19,1,e,t,n);var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);a()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=r(s),t=r(u),e=We(e),t=We(t),c<i?(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t):(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e)}function He(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=pt();return e=e(),dt(t),e}((()=>{for(var a=mt(8*n),o=a>>3,s=0;s<n;s++){var u=r[2+s];i()[o+s>>>0]=u}return st(e,n,a,t)}))}s.invokeEntryPoint=function(e,t){var n=he[e];n||(e>=he.length&&(he.length=e+1),he[e]=n=$.get(e)),e=n(t),C?fe.Ya(e):lt(e)},s.executeNotifiedProxyingQueue=De,ge=_?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:O?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Le,Ye=[],ze={};function Be(){if(!Le){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in ze)void 0===ze[e]?delete t[e]:t[e]=ze[e];var n=[];for(e in t)n.push(e+"="+t[e]);Le=n}return Le}function Ne(e,n){if(O)return He(20,1,e,n);var r=0;return Be().forEach((function(a,i){var s=n+r;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,r+=a.length+1})),0}function Ge(e,t){if(O)return He(21,1,e,t);var n=Be();o()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),o()[t>>2>>>0]=r,0}function qe(e){return O?He(22,1,e):52}function $e(e,t,n,r){return O?He(23,1,e,t,n,r):52}function Ve(e,t,n,r,a){return O?He(24,1,e,t,n,r,a):70}var Je=[null,[],[]];function Qe(e,t,n,a){if(O)return He(25,1,e,t,n,a);for(var i=0,s=0;s<n;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=r()[u+l>>>0],p=Je[e];0===f||10===f?((1===e?R:x)(Y(p,0)),p.length=0):p.push(f)}i+=c}return o()[a>>2>>>0]=i,0}function Xe(e){return 0==e%4&&(0!=e%100||0==e%400)}var Ke=[31,29,31,30,31,30,31,31,30,31,30,31],Ze=[31,28,31,30,31,30,31,31,30,31,30,31];function et(e,n,r,o){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return i(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function c(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Ma;for(e=new Date(new Date(e.Na+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?Ke:Ze)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=c(new Date(e.getFullYear(),0,4)),n=c(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var f=a()[o+40>>2>>>0];for(var p in o={tb:a()[o>>2>>>0],sb:a()[o+4>>2>>>0],Sa:a()[o+8>>2>>>0],Va:a()[o+12>>2>>>0],Ta:a()[o+16>>2>>>0],Na:a()[o+20>>2>>>0],Ja:a()[o+24>>2>>>0],Ma:a()[o+28>>2>>>0],zb:a()[o+32>>2>>>0],rb:a()[o+36>>2>>>0],ub:f?z(f):""},r=z(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),m="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(e){return d[e.Ja].substring(0,3)},"%A":function(e){return d[e.Ja]},"%b":function(e){return m[e.Ta].substring(0,3)},"%B":function(e){return m[e.Ta]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Va,2)},"%e":function(e){return i(e.Va,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return s(e.Sa,2)},"%I":function(e){return 0==(e=e.Sa)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Ta-1;t+=(Xe(e.Na+1900)?Ke:Ze)[n++]);return s(e.Va+t,3)},"%m":function(e){return s(e.Ta+1,2)},"%M":function(e){return s(e.sb,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.Sa&&12>e.Sa?"AM":"PM"},"%S":function(e){return s(e.tb,2)},"%t":function(){return"\\t"},"%u":function(e){return e.Ja||7},"%U":function(e){return s(Math.floor((e.Ma+7-e.Ja)/7),2)},"%V":function(e){var t=Math.floor((e.Ma+7-(e.Ja+6)%7)/7);if(2>=(e.Ja+371-e.Ma-2)%7&&t++,t)53==t&&(4==(n=(e.Ja+371-e.Ma)%7)||3==n&&Xe(e.Na)||(t=1));else{t=52;var n=(e.Ja+7-e.Ma-1)%7;(4==n||5==n&&Xe(e.Na%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Ja},"%W":function(e){return s(Math.floor((e.Ma+7-(e.Ja+6)%7)/7),2)},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.rb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ub},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](o)));return p=function(e){var t=Array(N(e)+1);return B(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(e,n){t().set(e,n>>>0)}(p,e),p.length-1)}fe.Ua();var tt=[null,ce,de,ve,we,_e,Oe,Se,Te,Ae,Ee,Me,Re,xe,Ce,Pe,ke,Ue,Ie,je,Ne,Ge,qe,$e,Ve,Qe],nt={b:function(e){return at(e+24)+24},c:function(e,t,n){throw new ye(e).Ua(t,n),e},L:function(e){ot(e,!w,1,!b),fe.Za()},l:function(e){O?postMessage({cmd:"cleanupThread",thread:e}):se(e)},D:be,i:we,R:_e,z:Oe,B:Se,T:Te,P:Ae,I:Ee,O:Me,p:Re,A:xe,x:Ce,Q:Pe,y:ke,r:function(){},j:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(e,t,n,r){if(e==t)setTimeout((()=>De(r)));else if(O)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=fe.La[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},K:function(){return-1},W:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getUTCSeconds(),a()[t+4>>2>>>0]=e.getUTCMinutes(),a()[t+8>>2>>>0]=e.getUTCHours(),a()[t+12>>2>>>0]=e.getUTCDate(),a()[t+16>>2>>>0]=e.getUTCMonth(),a()[t+20>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2>>>0]=e},X:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),a()[t+20>>2>>>0]=e.getFullYear()-1900,a()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2>>>0]=r,a()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2>>>0]=e},Y:function(e){var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=s&&u==r):0<n!=(u==r)&&(i=Math.max(s,i),t.setTime(t.getTime()+6e4*((0<n?u:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-o.getTime())/864e5|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},G:Ue,H:Ie,Z:function e(t,n,r){e.jb||(e.jb=!0,je(t,n,r))},d:function(){ne("")},m:function(){if(!_&&!w){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";me||(me={}),me[e]||(me[e]=1,_&&(e="warning: "+e),x(e))}},w:function(){return 4294901760},f:ge,S:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},g:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},J:function(e,t,n){Ye.length=t,n>>=3;for(var r=0;r<t;r++)Ye[r]=i()[n+r>>>0];return(0>e?oe[-e-1]:tt[e]).apply(null,Ye)},v:function(e){var t=r().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a),o=o.min.call(o,4294901760,a+(65536-a%65536)%65536);e:{try{P.grow(o-D.byteLength+65535>>>16),G(P.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},U:function(){throw"unwind"},M:Ne,N:Ge,k:le,h:qe,o:$e,t:Ve,n:Qe,u:function e(r,a){e.Wa||(e.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(_)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>ne("randomDevice")}());for(var o=0;o<a;o++)t()[r+o>>0>>>0]=e.Wa();return 0},a:P||s.wasmMemory,C:et,e:function(e,t,n,r){return et(e,t,n,r)}};!function(){function e(e,t){s.asm=e.exports,fe.$a.push(s.asm.wa),$=s.asm.za,J.unshift(s.asm._),k=t,O||(Z--,s.monitorRunDependencies&&s.monitorRunDependencies(Z),0==Z&&(null!==ee&&(clearInterval(ee),ee=null),te&&(e=te,te=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!M&&(b||w)){if("function"==typeof fetch&&!K.startsWith("file://"))return fetch(K,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+K+"\'";return e.arrayBuffer()})).catch((function(){return ae()}));if(f)return new Promise((function(e,t){f(K,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ae()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){x("failed to asynchronously prepare wasm: "+e),ne(e)}))}var r={a:nt};if(O||(Z++,s.monitorRunDependencies&&s.monitorRunDependencies(Z)),s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(e){return x("Module.instantiateWasm callback failed with error: "+e),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||re()||K.startsWith("file://")||_||"function"!=typeof fetch?n(t):fetch(K,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var rt=s._pthread_self=function(){return(rt=s._pthread_self=s.asm.ta).apply(null,arguments)},at=s._malloc=function(){return(at=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var ot=s.__emscripten_thread_init=function(){return(ot=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var it,st=s._emscripten_run_in_main_runtime_thread_js=function(){return(st=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},ut=s.__emscripten_proxy_execute_task_queue=function(){return(ut=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},ct=s.__emscripten_thread_free_data=function(){return(ct=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},lt=s.__emscripten_thread_exit=function(){return(lt=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},ft=s._emscripten_stack_set_limits=function(){return(ft=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},pt=s.stackSave=function(){return(pt=s.stackSave=s.asm.Fa).apply(null,arguments)},dt=s.stackRestore=function(){return(dt=s.stackRestore=s.asm.Ga).apply(null,arguments)},mt=s.stackAlloc=function(){return(mt=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function gt(){function e(){if(!it&&(it=!0,s.calledRun=!0,!H)&&(O||pe(J),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!O)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();Q.unshift(e)}pe(Q)}}if(!(0<Z))if(O)u(s),O||pe(J),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)X();pe(V),0<Z||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),e()}),1)):e())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=z,s.stringToUTF8=function(e,t,n){return B(e,r(),t,n)},s.lengthBytesUTF8=N,s.keepRuntimeAlive=function(){return C},s.wasmMemory=P,s.stackSave=pt,s.stackRestore=dt,s.stackAlloc=mt,s.ExitStatus=ie,s.PThread=fe,te=function e(){it||gt(),it||(te=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return gt(),e.ready});e.exports=r},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,r,a;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){r=e,a=t}));var o,i,s,u,c,l,f=Object.assign({},t),p="./this.program",d=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,h="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";h?(y=g?n(908).dirname(y)+"/":"//",l=()=>{c||(u=n(384),c=n(908))},o=function(e,t){return l(),e=c.normalize(e),u.readFileSync(e,t?void 0:"utf8")},s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,n)=>{l(),e=c.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof $))throw e})),process.on("unhandledRejection",(function(e){throw e})),d=(e,t)=>{if(_)throw process.exitCode=e,t;t instanceof $||w("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var v,b=t.print||console.log.bind(console),w=t.printErr||console.warn.bind(console);Object.assign(t,f),f=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(d=t.quit),t.wasmBinary&&(v=t.wasmBinary);var _=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&B("no native wasm support detected");var O,S,T,A,E,M,R=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&x)return x.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function P(e,t){return(e>>>=0)?C(A,e,t):""}function k(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function D(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function F(){var e=O.buffer;S=e,t.HEAP8=T=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=E=new Int32Array(e),t.HEAPU8=A=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=M=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var U=[],I=[],W=[];function j(){var e=t.preRun.shift();U.unshift(e)}var H,L=0,Y=null,z=null;function B(e){throw t.onAbort&&t.onAbort(e),w(e="Aborted("+e+")"),R=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function N(){return H.startsWith("data:application/octet-stream;base64,")}if(H="ort-wasm.wasm",!N()){var G=H;H=t.locateFile?t.locateFile(G,y):y+G}function q(){var e=H;try{if(e==H&&v)return new Uint8Array(v);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){B(e)}}function $(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function V(e){for(;0<e.length;)e.shift()(t)}function J(e){this.sa=e-24,this.Ia=function(e){M[this.sa+4>>2>>>0]=e},this.Ba=function(e){M[this.sa+8>>2>>>0]=e},this.Ga=function(){E[this.sa>>2>>>0]=0},this.Aa=function(){T[this.sa+12>>0>>>0]=0},this.Ha=function(){T[this.sa+13>>0>>>0]=0},this.ya=function(e,t){this.za(),this.Ia(e),this.Ba(t),this.Ga(),this.Aa(),this.Ha()},this.za=function(){M[this.sa+16>>2>>>0]=0}}function Q(e){var t=D(e)+1,n=ie(t);return n&&k(e,T,n,t),n}var X={};function K(){if(!Z){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(e in X)void 0===X[e]?delete t[e]:t[e]=X[e];var n=[];for(e in t)n.push(e+"="+t[e]);Z=n}return Z}var Z,ee=[null,[],[]];function te(e){return 0==e%4&&(0!=e%100||0==e%400)}var ne=[31,29,31,30,31,30,31,31,30,31,30,31],re=[31,28,31,30,31,30,31,31,30,31,30,31];function ae(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.qa;for(e=new Date(new Date(e.ra+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?ne:re)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={Ea:E[r>>2>>>0],Da:E[r+4>>2>>>0],ta:E[r+8>>2>>>0],va:E[r+12>>2>>>0],ua:E[r+16>>2>>>0],ra:E[r+20>>2>>>0],la:E[r+24>>2>>>0],qa:E[r+28>>2>>>0],Ja:E[r+32>>2>>>0],Ca:E[r+36>>2>>>0],Fa:c?P(c):""},n=P(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(e){return f[e.la].substring(0,3)},"%A":function(e){return f[e.la]},"%b":function(e){return p[e.ua].substring(0,3)},"%B":function(e){return p[e.ua]},"%C":function(e){return o((e.ra+1900)/100|0,2)},"%d":function(e){return o(e.va,2)},"%e":function(e){return a(e.va,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return o(e.ta,2)},"%I":function(e){return 0==(e=e.ta)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ua-1;t+=(te(e.ra+1900)?ne:re)[n++]);return o(e.va+t,3)},"%m":function(e){return o(e.ua+1,2)},"%M":function(e){return o(e.Da,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.ta&&12>e.ta?"AM":"PM"},"%S":function(e){return o(e.Ea,2)},"%t":function(){return"\\t"},"%u":function(e){return e.la||7},"%U":function(e){return o(Math.floor((e.qa+7-e.la)/7),2)},"%V":function(e){var t=Math.floor((e.qa+7-(e.la+6)%7)/7);if(2>=(e.la+371-e.qa-2)%7&&t++,t)53==t&&(4==(n=(e.la+371-e.qa)%7)||3==n&&te(e.ra)||(t=1));else{t=52;var n=(e.la+7-e.qa-1)%7;(4==n||5==n&&te(e.ra%400-1))&&t++}return o(t,2)},"%w":function(e){return e.la},"%W":function(e){return o(Math.floor((e.qa+7-(e.la+6)%7)/7),2)},"%y":function(e){return(e.ra+1900).toString().substring(2)},"%Y":function(e){return e.ra+1900},"%z":function(e){var t=0<=(e=e.Ca);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Fa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(e){var t=Array(D(e)+1);return k(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),l.length>t?0:(T.set(l,e>>>0),l.length-1)}var oe={a:function(e){return ie(e+24)+24},b:function(e,t,n){throw new J(e).ya(t,n),e},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getUTCSeconds(),E[t+4>>2>>>0]=e.getUTCMinutes(),E[t+8>>2>>>0]=e.getUTCHours(),E[t+12>>2>>>0]=e.getUTCDate(),E[t+16>>2>>>0]=e.getUTCMonth(),E[t+20>>2>>>0]=e.getUTCFullYear()-1900,E[t+24>>2>>>0]=e.getUTCDay(),E[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),E[t+20>>2>>>0]=e.getFullYear()-1900,E[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);E[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,E[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},O:function(e){var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=a.getTimezoneOffset(),s=Math.min(i,o);return 0>n?E[e+32>>2>>>0]=Number(o!=i&&s==r):0<n!=(s==r)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<n?s:o)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(t.getTime()-a.getTime())/864e5|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();E[e>>2>>>0]=60*Math.max(a,s),E[t>>2>>>0]=Number(a!=s),e=r(o),t=r(i),e=Q(e),t=Q(t),s<a?(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t):(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e)}(t,n,r))},d:function(){B("")},t:function(){return 4294901760},h:h?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),J:function(e,t,n){A.copyWithin(e>>>0,t>>>0,t+n>>>0)},f:function(e){var t=A.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);e:{try{O.grow(a-S.byteLength+65535>>>16),F();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){var n=0;return K().forEach((function(r,a){var o=t+n;for(a=M[e+4*a>>2>>>0]=o,o=0;o<r.length;++o)T[a++>>0>>>0]=r.charCodeAt(o);T[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){var n=K();M[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),M[t>>2>>>0]=r,0},r:function(e){_||(t.onExit&&t.onExit(e),R=!0),d(e,new $(e))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(e,t,n,r){for(var a=0,o=0;o<n;o++){var i=M[t>>2>>>0],s=M[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=A[i+u>>>0],l=ee[e];0===c||10===c?((1===e?b:w)(C(l,0)),l.length=0):l.push(c)}a+=s}return M[r>>2>>>0]=a,0},s:function e(t,r){e.wa||(e.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(h)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>B("randomDevice")}());for(var a=0;a<r;a++)T[t+a>>0>>>0]=e.wa();return 0},A:ae,c:function(e,t,n,r){return ae(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,O=t.asm.P,F(),I.unshift(t.asm.Q),L--,t.monitorRunDependencies&&t.monitorRunDependencies(L),0==L&&(null!==Y&&(clearInterval(Y),Y=null),z&&(e=z,z=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!v&&(m||g)){if("function"==typeof fetch&&!H.startsWith("file://"))return fetch(H,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+H+"\'";return e.arrayBuffer()})).catch((function(){return q()}));if(i)return new Promise((function(e,t){i(H,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return q()}))}().then((function(e){return WebAssembly.instantiate(e,o)})).then((function(e){return e})).then(e,(function(e){w("failed to asynchronously prepare wasm: "+e),B(e)}))}var o={a:oe};if(L++,t.monitorRunDependencies&&t.monitorRunDependencies(L),t.instantiateWasm)try{return t.instantiateWasm(o,e)}catch(e){return w("Module.instantiateWasm callback failed with error: "+e),!1}(v||"function"!=typeof WebAssembly.instantiateStreaming||N()||H.startsWith("file://")||h||"function"!=typeof fetch?r(n):fetch(H,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,o).then(n,(function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.Q).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.R).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.S).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.T).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.U).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.V).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.W).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.X).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Y).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Z).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm._).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.$).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.aa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.ba).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ca).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.da).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ea).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.fa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ga).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ha).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ia).apply(null,arguments)};var ie=t._malloc=function(){return(ie=t._malloc=t.asm.ja).apply(null,arguments)};t._free=function(){return(t._free=t.asm.ka).apply(null,arguments)};var se,ue=t.stackSave=function(){return(ue=t.stackSave=t.asm.ma).apply(null,arguments)},ce=t.stackRestore=function(){return(ce=t.stackRestore=t.asm.na).apply(null,arguments)},le=t.stackAlloc=function(){return(le=t.stackAlloc=t.asm.oa).apply(null,arguments)};function fe(){function e(){if(!se&&(se=!0,t.calledRun=!0,!R)){if(V(I),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();W.unshift(e)}V(W)}}if(!(0<L)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)j();V(U),0<L||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.pa).apply(null,arguments)},t.UTF8ToString=P,t.stringToUTF8=function(e,t,n){return k(e,A,t,n)},t.lengthBytesUTF8=D,t.stackSave=ue,t.stackRestore=ce,t.stackAlloc=le,z=function e(){se||fe(),se||(z=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return fe(),e.ready});e.exports=r},154:e=>{"use strict";e.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{"use strict";const e=n(259),t=n(263);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,t.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})));break;case"init-ort":try{const{numThreads:t,loggingLevel:r}=n.data.in;(0,e.initOrt)(t,r),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=n.data.in,r=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:r})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:r}=n.data.in,a=(0,e.createSessionFinalize)(t,r);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=(0,e.createSession)(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:o,options:i}=n.data.in;(0,e.run)(t,r,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:R=>{R.exports=function(u,y,m,h){var f=self||window;try{try{var s;try{s=new f.Blob([u])}catch{(s=new(f.BlobBuilder||f.WebKitBlobBuilder||f.MozBlobBuilder||f.MSBlobBuilder)).append(u),s=s.getBlob()}var l=f.URL||f.webkitURL,p=l.createObjectURL(s),a=new f[y](p,m);return l.revokeObjectURL(p),a}catch{return new f[y]("data:application/javascript,".concat(encodeURIComponent(u)),m)}}catch{if(!h)throw Error("Inline worker is not supported");return new f[y](h,m)}}},3474:(R,u,y)=>{var m,h=(m=(m=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(f){function s(){return z.buffer!=q&&ut(z.buffer),tt}function l(){return z.buffer!=q&&ut(z.buffer),rt}function p(){return z.buffer!=q&&ut(z.buffer),Z}function a(){return z.buffer!=q&&ut(z.buffer),at}function i(){return z.buffer!=q&&ut(z.buffer),st}var e,t,n;f=f||{},e||(e=f!==void 0?f:{}),e.ready=new Promise(function(O,I){t=O,n=I});var r,o,c,d,g,b,v=Object.assign({},e),w="./this.program",x=(O,I)=>{throw I},T=typeof window=="object",S=typeof importScripts=="function",_=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",A=e.ENVIRONMENT_IS_PTHREAD||!1,E="";function C(O){return e.locateFile?e.locateFile(O,E):E+O}if(_){let O;E=S?y(908).dirname(E)+"/":"//",b=()=>{g||(d=y(1384),g=y(908))},r=function(I,F){return b(),I=g.normalize(I),d.readFileSync(I,F?void 0:"utf8")},c=I=>((I=r(I,!0)).buffer||(I=new Uint8Array(I)),I),o=(I,F,N)=>{b(),I=g.normalize(I),d.readFile(I,function(W,K){W?N(W):F(K.buffer)})},1<process.argv.length&&(w=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(I){if(!(I instanceof Nt))throw I}),process.on("unhandledRejection",function(I){throw I}),x=(I,F)=>{if(V)throw process.exitCode=I,F;F instanceof Nt||k("exiting due to exception: "+F),process.exit(I)},e.inspect=function(){return"[Emscripten Module object]"};try{O=y(9925)}catch(I){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),I}y.g.Worker=O.Worker}else(T||S)&&(S?E=self.location.href:typeof document<"u"&&document.currentScript&&(E=document.currentScript.src),m&&(E=m),E=E.indexOf("blob:")!==0?E.substr(0,E.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(r=O=>{var I=new XMLHttpRequest;return I.open("GET",O,!1),I.send(null),I.responseText},S&&(c=O=>{var I=new XMLHttpRequest;return I.open("GET",O,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)}),o=(O,I,F)=>{var N=new XMLHttpRequest;N.open("GET",O,!0),N.responseType="arraybuffer",N.onload=()=>{N.status==200||N.status==0&&N.response?I(N.response):F()},N.onerror=F,N.send(null)}));_&&typeof performance>"u"&&(y.g.performance=y(6953).performance);var D=console.log.bind(console),$=console.warn.bind(console);_&&(b(),D=O=>d.writeSync(1,O+`
`),$=O=>d.writeSync(2,O+`
`));var L,P=e.print||D,k=e.printErr||$;Object.assign(e,v),v=null,e.thisProgram&&(w=e.thisProgram),e.quit&&(x=e.quit),e.wasmBinary&&(L=e.wasmBinary);var V=e.noExitRuntime||!0;typeof WebAssembly!="object"&&xt("no native wasm support detected");var z,J,q,tt,rt,Z,at,st,et=!1,dt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function nt(O,I,F){var N=(I>>>=0)+F;for(F=I;O[F]&&!(F>=N);)++F;if(16<F-I&&O.buffer&&dt)return dt.decode(O.buffer instanceof SharedArrayBuffer?O.slice(I,F):O.subarray(I,F));for(N="";I<F;){var W=O[I++];if(128&W){var K=63&O[I++];if((224&W)==192)N+=String.fromCharCode((31&W)<<6|K);else{var ot=63&O[I++];65536>(W=(240&W)==224?(15&W)<<12|K<<6|ot:(7&W)<<18|K<<12|ot<<6|63&O[I++])?N+=String.fromCharCode(W):(W-=65536,N+=String.fromCharCode(55296|W>>10,56320|1023&W))}}else N+=String.fromCharCode(W)}return N}function gt(O,I){return(O>>>=0)?nt(l(),O,I):""}function ct(O,I,F,N){if(!(0<N))return 0;var W=F>>>=0;N=F+N-1;for(var K=0;K<O.length;++K){var ot=O.charCodeAt(K);if(55296<=ot&&57343>=ot&&(ot=65536+((1023&ot)<<10)|1023&O.charCodeAt(++K)),127>=ot){if(F>=N)break;I[F++>>>0]=ot}else{if(2047>=ot){if(F+1>=N)break;I[F++>>>0]=192|ot>>6}else{if(65535>=ot){if(F+2>=N)break;I[F++>>>0]=224|ot>>12}else{if(F+3>=N)break;I[F++>>>0]=240|ot>>18,I[F++>>>0]=128|ot>>12&63}I[F++>>>0]=128|ot>>6&63}I[F++>>>0]=128|63&ot}}return I[F>>>0]=0,F-W}function mt(O){for(var I=0,F=0;F<O.length;++F){var N=O.charCodeAt(F);127>=N?I++:2047>=N?I+=2:55296<=N&&57343>=N?(I+=4,++F):I+=3}return I}function ut(O){q=O,e.HEAP8=tt=new Int8Array(O),e.HEAP16=new Int16Array(O),e.HEAP32=Z=new Int32Array(O),e.HEAPU8=rt=new Uint8Array(O),e.HEAPU16=new Uint16Array(O),e.HEAPU32=at=new Uint32Array(O),e.HEAPF32=new Float32Array(O),e.HEAPF64=st=new Float64Array(O)}A&&(q=e.buffer);var wt=e.INITIAL_MEMORY||16777216;if(A)z=e.wasmMemory,q=e.buffer;else if(e.wasmMemory)z=e.wasmMemory;else if(!((z=new WebAssembly.Memory({initial:wt/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw k("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");z&&(q=z.buffer),wt=q.byteLength,ut(q);var Et,kt=[],Ct=[],Rt=[];function Mt(){var O=e.preRun.shift();kt.unshift(O)}var bt,It=0,_t=null;function xt(O){throw A?postMessage({cmd:"onAbort",arg:O}):e.onAbort&&e.onAbort(O),k(O="Aborted("+O+")"),et=!0,O=new WebAssembly.RuntimeError(O+". Build with -sASSERTIONS for more info."),n(O),O}function zt(){return bt.startsWith("data:application/octet-stream;base64,")}function Gt(){var O=bt;try{if(O==bt&&L)return new Uint8Array(L);if(c)return c(O);throw"both async and sync fetching of the wasm failed"}catch(I){xt(I)}}bt="ort-wasm-threaded.wasm",zt()||(bt=C(bt));var Lt={};function Nt(O){this.name="ExitStatus",this.message="Program terminated with exit("+O+")",this.status=O}function Vt(O){(O=Q.La[O])||xt(),Q.Xa(O)}function Wt(O){var I=Q.lb();if(!I)return 6;Q.Ra.push(I),Q.La[O.Ka]=I,I.Ka=O.Ka;var F={cmd:"run",start_routine:O.pb,arg:O.ib,pthread_ptr:O.Ka};return I.Qa=()=>{F.time=performance.now(),I.postMessage(F,O.vb)},I.loaded&&(I.Qa(),delete I.Qa),0}function qt(O){if(A)return ht(1,1,O);V||(Q.qb(),e.onExit&&e.onExit(O),et=!0),x(O,new Nt(O))}function Kt(O,I){if(!I&&A)throw j(O),"unwind";qt(O)}var Q={Oa:[],Ra:[],$a:[],La:{},Ua:function(){A&&Q.mb()},xb:function(){},mb:function(){Q.receiveObjectTransfer=Q.ob,Q.threadInitTLS=Q.Za,Q.setExitStatus=Q.Ya,V=!1},Ya:function(){},qb:function(){for(var O of Object.values(Q.La))Q.Xa(O);for(O of Q.Oa)O.terminate();Q.Oa=[]},Xa:function(O){var I=O.Ka;delete Q.La[I],Q.Oa.push(O),Q.Ra.splice(Q.Ra.indexOf(O),1),O.Ka=0,oe(I)},ob:function(){},Za:function(){Q.$a.forEach(O=>O())},nb:function(O,I){O.onmessage=F=>{var N=(F=F.data).cmd;if(O.Ka&&(Q.kb=O.Ka),F.targetThread&&F.targetThread!=Jt()){var W=Q.La[F.yb];W?W.postMessage(F,F.transferList):k('Internal error! Worker sent a message "'+N+'" to target pthread '+F.targetThread+", but that thread no longer exists!")}else N==="processProxyingQueue"?te(F.queue):N==="spawnThread"?Wt(F):N==="cleanupThread"?Vt(F.thread):N==="killThread"?(F=F.thread,N=Q.La[F],delete Q.La[F],N.terminate(),oe(F),Q.Ra.splice(Q.Ra.indexOf(N),1),N.Ka=0):N==="cancelThread"?Q.La[F.thread].postMessage({cmd:"cancel"}):N==="loaded"?(O.loaded=!0,I&&I(O),O.Qa&&(O.Qa(),delete O.Qa)):N==="print"?P("Thread "+F.threadId+": "+F.text):N==="printErr"?k("Thread "+F.threadId+": "+F.text):N==="alert"?alert("Thread "+F.threadId+": "+F.text):F.target==="setimmediate"?O.postMessage(F):N==="onAbort"?e.onAbort&&e.onAbort(F.arg):N&&k("worker sent an unknown command "+N);Q.kb=void 0},O.onerror=F=>{throw k("worker sent an error! "+F.filename+":"+F.lineno+": "+F.message),F},_&&(O.on("message",function(F){O.onmessage({data:F})}),O.on("error",function(F){O.onerror(F)}),O.on("detachedExit",function(){})),O.postMessage({cmd:"load",urlOrBlob:e.mainScriptUrlOrBlob||m,wasmMemory:z,wasmModule:J})},hb:function(){var O=C("ort-wasm-threaded.worker.js");Q.Oa.push(new Worker(O))},lb:function(){return Q.Oa.length==0&&(Q.hb(),Q.nb(Q.Oa[0])),Q.Oa.pop()}};function M(O){for(;0<O.length;)O.shift()(e)}function j(O){if(A)return ht(2,0,O);try{Kt(O)}catch(I){I instanceof Nt||I=="unwind"||x(1,I)}}e.PThread=Q,e.establishStackSpace=function(){var O=Jt(),I=p()[O+44>>2>>>0];O=p()[O+48>>2>>>0],Pe(I,I-O),Qt(I)};var G,H,X=[];function Y(O){this.Pa=O-24,this.gb=function(I){a()[this.Pa+4>>2>>>0]=I},this.cb=function(I){a()[this.Pa+8>>2>>>0]=I},this.eb=function(){p()[this.Pa>>2>>>0]=0},this.bb=function(){s()[this.Pa+12>>0>>>0]=0},this.fb=function(){s()[this.Pa+13>>0>>>0]=0},this.Ua=function(I,F){this.ab(),this.gb(I),this.cb(F),this.eb(),this.bb(),this.fb()},this.ab=function(){a()[this.Pa+16>>2>>>0]=0}}function it(O,I,F,N){return A?ht(3,1,O,I,F,N):Tt(O,I,F,N)}function Tt(O,I,F,N){if(typeof SharedArrayBuffer>"u")return k("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var W=[];return A&&W.length===0?it(O,I,F,N):(O={pb:F,Ka:O,ib:N,vb:W},A?(O.wb="spawnThread",postMessage(O,W),0):Wt(O))}function At(O,I,F){return A?ht(4,1,O,I,F):0}function St(O,I){if(A)return ht(5,1,O,I)}function vt(O,I){if(A)return ht(6,1,O,I)}function jt(O,I,F){if(A)return ht(7,1,O,I,F)}function Ut(O,I,F){return A?ht(8,1,O,I,F):0}function U(O,I){if(A)return ht(9,1,O,I)}function lt(O,I,F){if(A)return ht(10,1,O,I,F)}function ft(O,I,F,N){if(A)return ht(11,1,O,I,F,N)}function Ft(O,I,F,N){if(A)return ht(12,1,O,I,F,N)}function Xt(O,I,F,N){if(A)return ht(13,1,O,I,F,N)}function ue(O){if(A)return ht(14,1,O)}function le(O,I){if(A)return ht(15,1,O,I)}function ce(O,I,F){if(A)return ht(16,1,O,I,F)}function te(O){Atomics.store(p(),O>>2,1),Jt()&&Ie(O),Atomics.compareExchange(p(),O>>2,1,0)}function pe(O){return a()[O>>>2]+4294967296*p()[O+4>>>2]}function de(O,I,F,N,W,K){return A?ht(17,1,O,I,F,N,W,K):-52}function he(O,I,F,N,W,K){if(A)return ht(18,1,O,I,F,N,W,K)}function fe(O){var I=mt(O)+1,F=ie(I);return F&&ct(O,s(),F,I),F}function ge(O,I,F){function N($t){return($t=$t.toTimeString().match(/\(([A-Za-z ]+)\)$/))?$t[1]:"GMT"}if(A)return ht(19,1,O,I,F);var W=new Date().getFullYear(),K=new Date(W,0,1),ot=new Date(W,6,1);W=K.getTimezoneOffset();var Ot=ot.getTimezoneOffset(),Bt=Math.max(W,Ot);p()[O>>2>>>0]=60*Bt,p()[I>>2>>>0]=+(W!=Ot),O=N(K),I=N(ot),O=fe(O),I=fe(I),Ot<W?(a()[F>>2>>>0]=O,a()[F+4>>2>>>0]=I):(a()[F>>2>>>0]=I,a()[F+4>>2>>>0]=O)}function ht(O,I){var F=arguments.length-2,N=arguments;return function(W){var K=ae();return W=W(),Qt(K),W}(()=>{for(var W=se(8*F),K=W>>3,ot=0;ot<F;ot++){var Ot=N[2+ot];i()[K+ot>>>0]=Ot}return Ee(O,F,W,I)})}e.invokeEntryPoint=function(O,I){var F=X[O];F||(O>=X.length&&(X.length=O+1),X[O]=F=Et.get(O)),O=F(I),V?Q.Ya(O):$e(O)},e.executeNotifiedProxyingQueue=te,H=_?()=>{var O=process.hrtime();return 1e3*O[0]+O[1]/1e6}:A?()=>performance.now()-e.__performance_now_clock_drift:()=>performance.now();var ee,ne=[],re={};function me(){if(!ee){var O,I={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:w||"./this.program"};for(O in re)re[O]===void 0?delete I[O]:I[O]=re[O];var F=[];for(O in I)F.push(O+"="+I[O]);ee=F}return ee}function be(O,I){if(A)return ht(20,1,O,I);var F=0;return me().forEach(function(N,W){var K=I+F;for(W=a()[O+4*W>>2>>>0]=K,K=0;K<N.length;++K)s()[W++>>0>>>0]=N.charCodeAt(K);s()[W>>0>>>0]=0,F+=N.length+1}),0}function ye(O,I){if(A)return ht(21,1,O,I);var F=me();a()[O>>2>>>0]=F.length;var N=0;return F.forEach(function(W){N+=W.length+1}),a()[I>>2>>>0]=N,0}function we(O){return A?ht(22,1,O):52}function ve(O,I,F,N){return A?ht(23,1,O,I,F,N):52}function _e(O,I,F,N,W){return A?ht(24,1,O,I,F,N,W):70}var Me=[null,[],[]];function xe(O,I,F,N){if(A)return ht(25,1,O,I,F,N);for(var W=0,K=0;K<F;K++){var ot=a()[I>>2>>>0],Ot=a()[I+4>>2>>>0];I+=8;for(var Bt=0;Bt<Ot;Bt++){var $t=l()[ot+Bt>>>0],Dt=Me[O];$t===0||$t===10?((O===1?P:k)(nt(Dt,0)),Dt.length=0):Dt.push($t)}W+=Ot}return a()[N>>2>>>0]=W,0}function Yt(O){return O%4==0&&(O%100!=0||O%400==0)}var Te=[31,29,31,30,31,30,31,31,30,31,30,31],Se=[31,28,31,30,31,30,31,31,30,31,30,31];function Oe(O,I,F,N){function W(B,pt,yt){for(B=typeof B=="number"?B.toString():B||"";B.length<pt;)B=yt[0]+B;return B}function K(B,pt){return W(B,pt,"0")}function ot(B,pt){function yt(Re){return 0>Re?-1:0<Re?1:0}var Ht;return(Ht=yt(B.getFullYear()-pt.getFullYear()))===0&&(Ht=yt(B.getMonth()-pt.getMonth()))===0&&(Ht=yt(B.getDate()-pt.getDate())),Ht}function Ot(B){switch(B.getDay()){case 0:return new Date(B.getFullYear()-1,11,29);case 1:return B;case 2:return new Date(B.getFullYear(),0,3);case 3:return new Date(B.getFullYear(),0,2);case 4:return new Date(B.getFullYear(),0,1);case 5:return new Date(B.getFullYear()-1,11,31);case 6:return new Date(B.getFullYear()-1,11,30)}}function Bt(B){var pt=B.Ma;for(B=new Date(new Date(B.Na+1900,0,1).getTime());0<pt;){var yt=B.getMonth(),Ht=(Yt(B.getFullYear())?Te:Se)[yt];if(!(pt>Ht-B.getDate())){B.setDate(B.getDate()+pt);break}pt-=Ht-B.getDate()+1,B.setDate(1),11>yt?B.setMonth(yt+1):(B.setMonth(0),B.setFullYear(B.getFullYear()+1))}return yt=new Date(B.getFullYear()+1,0,4),pt=Ot(new Date(B.getFullYear(),0,4)),yt=Ot(yt),0>=ot(pt,B)?0>=ot(yt,B)?B.getFullYear()+1:B.getFullYear():B.getFullYear()-1}var $t=p()[N+40>>2>>>0];for(var Dt in N={tb:p()[N>>2>>>0],sb:p()[N+4>>2>>>0],Sa:p()[N+8>>2>>>0],Va:p()[N+12>>2>>>0],Ta:p()[N+16>>2>>>0],Na:p()[N+20>>2>>>0],Ja:p()[N+24>>2>>>0],Ma:p()[N+28>>2>>>0],zb:p()[N+32>>2>>>0],rb:p()[N+36>>2>>>0],ub:$t?gt($t):""},F=gt(F),$t={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})F=F.replace(new RegExp(Dt,"g"),$t[Dt]);var ke="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ce="January February March April May June July August September October November December".split(" ");for(Dt in $t={"%a":function(B){return ke[B.Ja].substring(0,3)},"%A":function(B){return ke[B.Ja]},"%b":function(B){return Ce[B.Ta].substring(0,3)},"%B":function(B){return Ce[B.Ta]},"%C":function(B){return K((B.Na+1900)/100|0,2)},"%d":function(B){return K(B.Va,2)},"%e":function(B){return W(B.Va,2," ")},"%g":function(B){return Bt(B).toString().substring(2)},"%G":function(B){return Bt(B)},"%H":function(B){return K(B.Sa,2)},"%I":function(B){return(B=B.Sa)==0?B=12:12<B&&(B-=12),K(B,2)},"%j":function(B){for(var pt=0,yt=0;yt<=B.Ta-1;pt+=(Yt(B.Na+1900)?Te:Se)[yt++]);return K(B.Va+pt,3)},"%m":function(B){return K(B.Ta+1,2)},"%M":function(B){return K(B.sb,2)},"%n":function(){return`
`},"%p":function(B){return 0<=B.Sa&&12>B.Sa?"AM":"PM"},"%S":function(B){return K(B.tb,2)},"%t":function(){return"	"},"%u":function(B){return B.Ja||7},"%U":function(B){return K(Math.floor((B.Ma+7-B.Ja)/7),2)},"%V":function(B){var pt=Math.floor((B.Ma+7-(B.Ja+6)%7)/7);if(2>=(B.Ja+371-B.Ma-2)%7&&pt++,pt)pt==53&&((yt=(B.Ja+371-B.Ma)%7)==4||yt==3&&Yt(B.Na)||(pt=1));else{pt=52;var yt=(B.Ja+7-B.Ma-1)%7;(yt==4||yt==5&&Yt(B.Na%400-1))&&pt++}return K(pt,2)},"%w":function(B){return B.Ja},"%W":function(B){return K(Math.floor((B.Ma+7-(B.Ja+6)%7)/7),2)},"%y":function(B){return(B.Na+1900).toString().substring(2)},"%Y":function(B){return B.Na+1900},"%z":function(B){var pt=0<=(B=B.rb);return B=Math.abs(B)/60,(pt?"+":"-")+("0000"+(B/60*100+B%60)).slice(-4)},"%Z":function(B){return B.ub},"%%":function(){return"%"}},F=F.replace(/%%/g,"\0\0"),$t)F.includes(Dt)&&(F=F.replace(new RegExp(Dt,"g"),$t[Dt](N)));return Dt=function(B){var pt=Array(mt(B)+1);return ct(B,pt,0,pt.length),pt}(F=F.replace(/\0\0/g,"%")),Dt.length>I?0:(function(B,pt){s().set(B,pt>>>0)}(Dt,O),Dt.length-1)}Q.Ua();var Fe=[null,qt,j,it,At,St,vt,jt,Ut,U,lt,ft,Ft,Xt,ue,le,ce,de,he,ge,be,ye,we,ve,_e,xe],Le={b:function(O){return ie(O+24)+24},c:function(O,I,F){throw new Y(O).Ua(I,F),O},L:function(O){Ae(O,!S,1,!T),Q.Za()},l:function(O){A?postMessage({cmd:"cleanupThread",thread:O}):Vt(O)},D:Tt,i:At,R:St,z:vt,B:jt,T:Ut,P:U,I:lt,O:ft,p:Ft,A:Xt,x:ue,Q:le,y:ce,r:function(){},j:function(){xt("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){xt("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(O,I,F,N){if(O==I)setTimeout(()=>te(N));else if(A)postMessage({targetThread:O,cmd:"processProxyingQueue",queue:N});else{if(!(O=Q.La[O]))return;O.postMessage({cmd:"processProxyingQueue",queue:N})}return 1},K:function(){return-1},W:function(O,I){O=new Date(1e3*pe(O)),p()[I>>2>>>0]=O.getUTCSeconds(),p()[I+4>>2>>>0]=O.getUTCMinutes(),p()[I+8>>2>>>0]=O.getUTCHours(),p()[I+12>>2>>>0]=O.getUTCDate(),p()[I+16>>2>>>0]=O.getUTCMonth(),p()[I+20>>2>>>0]=O.getUTCFullYear()-1900,p()[I+24>>2>>>0]=O.getUTCDay(),O=(O.getTime()-Date.UTC(O.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,p()[I+28>>2>>>0]=O},X:function(O,I){O=new Date(1e3*pe(O)),p()[I>>2>>>0]=O.getSeconds(),p()[I+4>>2>>>0]=O.getMinutes(),p()[I+8>>2>>>0]=O.getHours(),p()[I+12>>2>>>0]=O.getDate(),p()[I+16>>2>>>0]=O.getMonth(),p()[I+20>>2>>>0]=O.getFullYear()-1900,p()[I+24>>2>>>0]=O.getDay();var F=new Date(O.getFullYear(),0,1),N=(O.getTime()-F.getTime())/864e5|0;p()[I+28>>2>>>0]=N,p()[I+36>>2>>>0]=-60*O.getTimezoneOffset(),N=new Date(O.getFullYear(),6,1).getTimezoneOffset(),O=0|(N!=(F=F.getTimezoneOffset())&&O.getTimezoneOffset()==Math.min(F,N)),p()[I+32>>2>>>0]=O},Y:function(O){var I=new Date(p()[O+20>>2>>>0]+1900,p()[O+16>>2>>>0],p()[O+12>>2>>>0],p()[O+8>>2>>>0],p()[O+4>>2>>>0],p()[O>>2>>>0],0),F=p()[O+32>>2>>>0],N=I.getTimezoneOffset(),W=new Date(I.getFullYear(),0,1),K=new Date(I.getFullYear(),6,1).getTimezoneOffset(),ot=W.getTimezoneOffset(),Ot=Math.min(ot,K);return 0>F?p()[O+32>>2>>>0]=+(K!=ot&&Ot==N):0<F!=(Ot==N)&&(K=Math.max(ot,K),I.setTime(I.getTime()+6e4*((0<F?Ot:K)-N))),p()[O+24>>2>>>0]=I.getDay(),F=(I.getTime()-W.getTime())/864e5|0,p()[O+28>>2>>>0]=F,p()[O>>2>>>0]=I.getSeconds(),p()[O+4>>2>>>0]=I.getMinutes(),p()[O+8>>2>>>0]=I.getHours(),p()[O+12>>2>>>0]=I.getDate(),p()[O+16>>2>>>0]=I.getMonth(),I.getTime()/1e3|0},G:de,H:he,Z:function O(I,F,N){O.jb||(O.jb=!0,ge(I,F,N))},d:function(){xt("")},m:function(){if(!_&&!S){var O="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";G||(G={}),G[O]||(G[O]=1,_&&(O="warning: "+O),k(O))}},w:function(){return 4294901760},f:H,S:function(O,I,F){l().copyWithin(O>>>0,I>>>0,I+F>>>0)},g:function(){return _?y(3993).cpus().length:navigator.hardwareConcurrency},J:function(O,I,F){ne.length=I,F>>=3;for(var N=0;N<I;N++)ne[N]=i()[F+N>>>0];return(0>O?Lt[-O-1]:Fe[O]).apply(null,ne)},v:function(O){var I=l().length;if((O>>>=0)<=I||4294901760<O)return!1;for(var F=1;4>=F;F*=2){var N=I*(1+.2/F);N=Math.min(N,O+100663296);var W=Math;N=Math.max(O,N),W=W.min.call(W,4294901760,N+(65536-N%65536)%65536);t:{try{z.grow(W-q.byteLength+65535>>>16),ut(z.buffer);var K=1;break t}catch{}K=void 0}if(K)return!0}return!1},U:function(){throw"unwind"},M:be,N:ye,k:Kt,h:we,o:ve,t:_e,n:xe,u:function O(I,F){O.Wa||(O.Wa=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var W=new Uint8Array(1);return()=>(crypto.getRandomValues(W),W[0])}if(_)try{var K=y(760);return()=>K.randomBytes(1)[0]}catch{}return()=>xt("randomDevice")}());for(var N=0;N<F;N++)s()[I+N>>0>>>0]=O.Wa();return 0},a:z||e.wasmMemory,C:Oe,e:function(O,I,F,N){return Oe(O,I,F,N)}};(function(){function O(W,K){e.asm=W.exports,Q.$a.push(e.asm.wa),Et=e.asm.za,Ct.unshift(e.asm._),J=K,A||(It--,e.monitorRunDependencies&&e.monitorRunDependencies(It),It==0&&_t&&(W=_t,_t=null,W()))}function I(W){O(W.instance,W.module)}function F(W){return function(){if(!L&&(T||S)){if(typeof fetch=="function"&&!bt.startsWith("file://"))return fetch(bt,{credentials:"same-origin"}).then(function(K){if(!K.ok)throw"failed to load wasm binary file at '"+bt+"'";return K.arrayBuffer()}).catch(function(){return Gt()});if(o)return new Promise(function(K,ot){o(bt,function(Ot){K(new Uint8Array(Ot))},ot)})}return Promise.resolve().then(function(){return Gt()})}().then(function(K){return WebAssembly.instantiate(K,N)}).then(function(K){return K}).then(W,function(K){k("failed to asynchronously prepare wasm: "+K),xt(K)})}var N={a:Le};if(A||(It++,e.monitorRunDependencies&&e.monitorRunDependencies(It)),e.instantiateWasm)try{return e.instantiateWasm(N,O)}catch(W){return k("Module.instantiateWasm callback failed with error: "+W),!1}(L||typeof WebAssembly.instantiateStreaming!="function"||zt()||bt.startsWith("file://")||_||typeof fetch!="function"?F(I):fetch(bt,{credentials:"same-origin"}).then(function(W){return WebAssembly.instantiateStreaming(W,N).then(I,function(K){return k("wasm streaming compile failed: "+K),k("falling back to ArrayBuffer instantiation"),F(I)})})).catch(n)})(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm._).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.$).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.aa).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.ba).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.ca).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.da).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.ea).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.fa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.ga).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.ha).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.ia).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.ja).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.ka).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.la).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.ma).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm.na).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.oa).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.pa).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.qa).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.ra).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.sa).apply(null,arguments)};var Jt=e._pthread_self=function(){return(Jt=e._pthread_self=e.asm.ta).apply(null,arguments)},ie=e._malloc=function(){return(ie=e._malloc=e.asm.ua).apply(null,arguments)};e._free=function(){return(e._free=e.asm.va).apply(null,arguments)},e.__emscripten_tls_init=function(){return(e.__emscripten_tls_init=e.asm.wa).apply(null,arguments)};var Ae=e.__emscripten_thread_init=function(){return(Ae=e.__emscripten_thread_init=e.asm.xa).apply(null,arguments)};e.__emscripten_thread_crashed=function(){return(e.__emscripten_thread_crashed=e.asm.ya).apply(null,arguments)};var Zt,Ee=e._emscripten_run_in_main_runtime_thread_js=function(){return(Ee=e._emscripten_run_in_main_runtime_thread_js=e.asm.Aa).apply(null,arguments)},Ie=e.__emscripten_proxy_execute_task_queue=function(){return(Ie=e.__emscripten_proxy_execute_task_queue=e.asm.Ba).apply(null,arguments)},oe=e.__emscripten_thread_free_data=function(){return(oe=e.__emscripten_thread_free_data=e.asm.Ca).apply(null,arguments)},$e=e.__emscripten_thread_exit=function(){return($e=e.__emscripten_thread_exit=e.asm.Da).apply(null,arguments)},Pe=e._emscripten_stack_set_limits=function(){return(Pe=e._emscripten_stack_set_limits=e.asm.Ea).apply(null,arguments)},ae=e.stackSave=function(){return(ae=e.stackSave=e.asm.Fa).apply(null,arguments)},Qt=e.stackRestore=function(){return(Qt=e.stackRestore=e.asm.Ga).apply(null,arguments)},se=e.stackAlloc=function(){return(se=e.stackAlloc=e.asm.Ha).apply(null,arguments)};function De(){function O(){if(!Zt&&(Zt=!0,e.calledRun=!0,!et)&&(A||M(Ct),t(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),!A)){if(e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;){var I=e.postRun.shift();Rt.unshift(I)}M(Rt)}}if(!(0<It))if(A)t(e),A||M(Ct),postMessage({cmd:"loaded"});else{if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)Mt();M(kt),0<It||(e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),O()},1)):O())}}if(e.___cxa_is_pointer_type=function(){return(e.___cxa_is_pointer_type=e.asm.Ia).apply(null,arguments)},e.UTF8ToString=gt,e.stringToUTF8=function(O,I,F){return ct(O,l(),I,F)},e.lengthBytesUTF8=mt,e.keepRuntimeAlive=function(){return V},e.wasmMemory=z,e.stackSave=ae,e.stackRestore=Qt,e.stackAlloc=se,e.ExitStatus=Nt,e.PThread=Q,_t=function O(){Zt||De(),Zt||(_t=O)},e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return De(),f.ready});R.exports=h},932:(R,u,y)=>{var m,h=(m=(m=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(f){var s,l,p;f=f||{},s||(s=f!==void 0?f:{}),s.ready=new Promise(function(M,j){l=M,p=j});var a,i,e,t,n,r,o=Object.assign({},s),c="./this.program",d=(M,j)=>{throw j},g=typeof window=="object",b=typeof importScripts=="function",v=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",w="";v?(w=b?y(908).dirname(w)+"/":"//",r=()=>{n||(t=y(1384),n=y(908))},a=function(M,j){return r(),M=n.normalize(M),t.readFileSync(M,j?void 0:"utf8")},e=M=>((M=a(M,!0)).buffer||(M=new Uint8Array(M)),M),i=(M,j,G)=>{r(),M=n.normalize(M),t.readFile(M,function(H,X){H?G(H):j(X.buffer)})},1<process.argv.length&&(c=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(M){if(!(M instanceof wt))throw M}),process.on("unhandledRejection",function(M){throw M}),d=(M,j)=>{if(_)throw process.exitCode=M,j;j instanceof wt||S("exiting due to exception: "+j),process.exit(M)},s.inspect=function(){return"[Emscripten Module object]"}):(g||b)&&(b?w=self.location.href:typeof document<"u"&&document.currentScript&&(w=document.currentScript.src),m&&(w=m),w=w.indexOf("blob:")!==0?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",a=M=>{var j=new XMLHttpRequest;return j.open("GET",M,!1),j.send(null),j.responseText},b&&(e=M=>{var j=new XMLHttpRequest;return j.open("GET",M,!1),j.responseType="arraybuffer",j.send(null),new Uint8Array(j.response)}),i=(M,j,G)=>{var H=new XMLHttpRequest;H.open("GET",M,!0),H.responseType="arraybuffer",H.onload=()=>{H.status==200||H.status==0&&H.response?j(H.response):G()},H.onerror=G,H.send(null)});var x,T=s.print||console.log.bind(console),S=s.printErr||console.warn.bind(console);Object.assign(s,o),o=null,s.thisProgram&&(c=s.thisProgram),s.quit&&(d=s.quit),s.wasmBinary&&(x=s.wasmBinary);var _=s.noExitRuntime||!0;typeof WebAssembly!="object"&&gt("no native wasm support detected");var A,E,C,D,$,L,P=!1,k=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function V(M,j,G){var H=(j>>>=0)+G;for(G=j;M[G]&&!(G>=H);)++G;if(16<G-j&&M.buffer&&k)return k.decode(M.subarray(j,G));for(H="";j<G;){var X=M[j++];if(128&X){var Y=63&M[j++];if((224&X)==192)H+=String.fromCharCode((31&X)<<6|Y);else{var it=63&M[j++];65536>(X=(240&X)==224?(15&X)<<12|Y<<6|it:(7&X)<<18|Y<<12|it<<6|63&M[j++])?H+=String.fromCharCode(X):(X-=65536,H+=String.fromCharCode(55296|X>>10,56320|1023&X))}}else H+=String.fromCharCode(X)}return H}function z(M,j){return(M>>>=0)?V(D,M,j):""}function J(M,j,G,H){if(!(0<H))return 0;var X=G>>>=0;H=G+H-1;for(var Y=0;Y<M.length;++Y){var it=M.charCodeAt(Y);if(55296<=it&&57343>=it&&(it=65536+((1023&it)<<10)|1023&M.charCodeAt(++Y)),127>=it){if(G>=H)break;j[G++>>>0]=it}else{if(2047>=it){if(G+1>=H)break;j[G++>>>0]=192|it>>6}else{if(65535>=it){if(G+2>=H)break;j[G++>>>0]=224|it>>12}else{if(G+3>=H)break;j[G++>>>0]=240|it>>18,j[G++>>>0]=128|it>>12&63}j[G++>>>0]=128|it>>6&63}j[G++>>>0]=128|63&it}}return j[G>>>0]=0,G-X}function q(M){for(var j=0,G=0;G<M.length;++G){var H=M.charCodeAt(G);127>=H?j++:2047>=H?j+=2:55296<=H&&57343>=H?(j+=4,++G):j+=3}return j}function tt(){var M=A.buffer;E=M,s.HEAP8=C=new Int8Array(M),s.HEAP16=new Int16Array(M),s.HEAP32=$=new Int32Array(M),s.HEAPU8=D=new Uint8Array(M),s.HEAPU16=new Uint16Array(M),s.HEAPU32=L=new Uint32Array(M),s.HEAPF32=new Float32Array(M),s.HEAPF64=new Float64Array(M)}var rt=[],Z=[],at=[];function st(){var M=s.preRun.shift();rt.unshift(M)}var et,dt=0,nt=null;function gt(M){throw s.onAbort&&s.onAbort(M),S(M="Aborted("+M+")"),P=!0,M=new WebAssembly.RuntimeError(M+". Build with -sASSERTIONS for more info."),p(M),M}function ct(){return et.startsWith("data:application/octet-stream;base64,")}if(et="ort-wasm.wasm",!ct()){var mt=et;et=s.locateFile?s.locateFile(mt,w):w+mt}function ut(){var M=et;try{if(M==et&&x)return new Uint8Array(x);if(e)return e(M);throw"both async and sync fetching of the wasm failed"}catch(j){gt(j)}}function wt(M){this.name="ExitStatus",this.message="Program terminated with exit("+M+")",this.status=M}function Et(M){for(;0<M.length;)M.shift()(s)}function kt(M){this.sa=M-24,this.Ia=function(j){L[this.sa+4>>2>>>0]=j},this.Ba=function(j){L[this.sa+8>>2>>>0]=j},this.Ga=function(){$[this.sa>>2>>>0]=0},this.Aa=function(){C[this.sa+12>>0>>>0]=0},this.Ha=function(){C[this.sa+13>>0>>>0]=0},this.ya=function(j,G){this.za(),this.Ia(j),this.Ba(G),this.Ga(),this.Aa(),this.Ha()},this.za=function(){L[this.sa+16>>2>>>0]=0}}function Ct(M){var j=q(M)+1,G=Nt(j);return G&&J(M,C,G,j),G}var Rt={};function Mt(){if(!bt){var M,j={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:c||"./this.program"};for(M in Rt)Rt[M]===void 0?delete j[M]:j[M]=Rt[M];var G=[];for(M in j)G.push(M+"="+j[M]);bt=G}return bt}var bt,It=[null,[],[]];function _t(M){return M%4==0&&(M%100!=0||M%400==0)}var xt=[31,29,31,30,31,30,31,31,30,31,30,31],zt=[31,28,31,30,31,30,31,31,30,31,30,31];function Gt(M,j,G,H){function X(U,lt,ft){for(U=typeof U=="number"?U.toString():U||"";U.length<lt;)U=ft[0]+U;return U}function Y(U,lt){return X(U,lt,"0")}function it(U,lt){function ft(Xt){return 0>Xt?-1:0<Xt?1:0}var Ft;return(Ft=ft(U.getFullYear()-lt.getFullYear()))===0&&(Ft=ft(U.getMonth()-lt.getMonth()))===0&&(Ft=ft(U.getDate()-lt.getDate())),Ft}function Tt(U){switch(U.getDay()){case 0:return new Date(U.getFullYear()-1,11,29);case 1:return U;case 2:return new Date(U.getFullYear(),0,3);case 3:return new Date(U.getFullYear(),0,2);case 4:return new Date(U.getFullYear(),0,1);case 5:return new Date(U.getFullYear()-1,11,31);case 6:return new Date(U.getFullYear()-1,11,30)}}function At(U){var lt=U.qa;for(U=new Date(new Date(U.ra+1900,0,1).getTime());0<lt;){var ft=U.getMonth(),Ft=(_t(U.getFullYear())?xt:zt)[ft];if(!(lt>Ft-U.getDate())){U.setDate(U.getDate()+lt);break}lt-=Ft-U.getDate()+1,U.setDate(1),11>ft?U.setMonth(ft+1):(U.setMonth(0),U.setFullYear(U.getFullYear()+1))}return ft=new Date(U.getFullYear()+1,0,4),lt=Tt(new Date(U.getFullYear(),0,4)),ft=Tt(ft),0>=it(lt,U)?0>=it(ft,U)?U.getFullYear()+1:U.getFullYear():U.getFullYear()-1}var St=$[H+40>>2>>>0];for(var vt in H={Ea:$[H>>2>>>0],Da:$[H+4>>2>>>0],ta:$[H+8>>2>>>0],va:$[H+12>>2>>>0],ua:$[H+16>>2>>>0],ra:$[H+20>>2>>>0],la:$[H+24>>2>>>0],qa:$[H+28>>2>>>0],Ja:$[H+32>>2>>>0],Ca:$[H+36>>2>>>0],Fa:St?z(St):""},G=z(G),St={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})G=G.replace(new RegExp(vt,"g"),St[vt]);var jt="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ut="January February March April May June July August September October November December".split(" ");for(vt in St={"%a":function(U){return jt[U.la].substring(0,3)},"%A":function(U){return jt[U.la]},"%b":function(U){return Ut[U.ua].substring(0,3)},"%B":function(U){return Ut[U.ua]},"%C":function(U){return Y((U.ra+1900)/100|0,2)},"%d":function(U){return Y(U.va,2)},"%e":function(U){return X(U.va,2," ")},"%g":function(U){return At(U).toString().substring(2)},"%G":function(U){return At(U)},"%H":function(U){return Y(U.ta,2)},"%I":function(U){return(U=U.ta)==0?U=12:12<U&&(U-=12),Y(U,2)},"%j":function(U){for(var lt=0,ft=0;ft<=U.ua-1;lt+=(_t(U.ra+1900)?xt:zt)[ft++]);return Y(U.va+lt,3)},"%m":function(U){return Y(U.ua+1,2)},"%M":function(U){return Y(U.Da,2)},"%n":function(){return`
`},"%p":function(U){return 0<=U.ta&&12>U.ta?"AM":"PM"},"%S":function(U){return Y(U.Ea,2)},"%t":function(){return"	"},"%u":function(U){return U.la||7},"%U":function(U){return Y(Math.floor((U.qa+7-U.la)/7),2)},"%V":function(U){var lt=Math.floor((U.qa+7-(U.la+6)%7)/7);if(2>=(U.la+371-U.qa-2)%7&&lt++,lt)lt==53&&((ft=(U.la+371-U.qa)%7)==4||ft==3&&_t(U.ra)||(lt=1));else{lt=52;var ft=(U.la+7-U.qa-1)%7;(ft==4||ft==5&&_t(U.ra%400-1))&&lt++}return Y(lt,2)},"%w":function(U){return U.la},"%W":function(U){return Y(Math.floor((U.qa+7-(U.la+6)%7)/7),2)},"%y":function(U){return(U.ra+1900).toString().substring(2)},"%Y":function(U){return U.ra+1900},"%z":function(U){var lt=0<=(U=U.Ca);return U=Math.abs(U)/60,(lt?"+":"-")+("0000"+(U/60*100+U%60)).slice(-4)},"%Z":function(U){return U.Fa},"%%":function(){return"%"}},G=G.replace(/%%/g,"\0\0"),St)G.includes(vt)&&(G=G.replace(new RegExp(vt,"g"),St[vt](H)));return vt=function(U){var lt=Array(q(U)+1);return J(U,lt,0,lt.length),lt}(G=G.replace(/\0\0/g,"%")),vt.length>j?0:(C.set(vt,M>>>0),vt.length-1)}var Lt={a:function(M){return Nt(M+24)+24},b:function(M,j,G){throw new kt(M).ya(j,G),M},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){gt("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){gt("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(M,j){M=new Date(1e3*(L[M>>>2]+4294967296*$[M+4>>>2])),$[j>>2>>>0]=M.getUTCSeconds(),$[j+4>>2>>>0]=M.getUTCMinutes(),$[j+8>>2>>>0]=M.getUTCHours(),$[j+12>>2>>>0]=M.getUTCDate(),$[j+16>>2>>>0]=M.getUTCMonth(),$[j+20>>2>>>0]=M.getUTCFullYear()-1900,$[j+24>>2>>>0]=M.getUTCDay(),$[j+28>>2>>>0]=(M.getTime()-Date.UTC(M.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(M,j){M=new Date(1e3*(L[M>>>2]+4294967296*$[M+4>>>2])),$[j>>2>>>0]=M.getSeconds(),$[j+4>>2>>>0]=M.getMinutes(),$[j+8>>2>>>0]=M.getHours(),$[j+12>>2>>>0]=M.getDate(),$[j+16>>2>>>0]=M.getMonth(),$[j+20>>2>>>0]=M.getFullYear()-1900,$[j+24>>2>>>0]=M.getDay();var G=new Date(M.getFullYear(),0,1);$[j+28>>2>>>0]=(M.getTime()-G.getTime())/864e5|0,$[j+36>>2>>>0]=-60*M.getTimezoneOffset();var H=new Date(M.getFullYear(),6,1).getTimezoneOffset();G=G.getTimezoneOffset(),$[j+32>>2>>>0]=0|(H!=G&&M.getTimezoneOffset()==Math.min(G,H))},O:function(M){var j=new Date($[M+20>>2>>>0]+1900,$[M+16>>2>>>0],$[M+12>>2>>>0],$[M+8>>2>>>0],$[M+4>>2>>>0],$[M>>2>>>0],0),G=$[M+32>>2>>>0],H=j.getTimezoneOffset(),X=new Date(j.getFullYear(),0,1),Y=new Date(j.getFullYear(),6,1).getTimezoneOffset(),it=X.getTimezoneOffset(),Tt=Math.min(it,Y);return 0>G?$[M+32>>2>>>0]=+(Y!=it&&Tt==H):0<G!=(Tt==H)&&(Y=Math.max(it,Y),j.setTime(j.getTime()+6e4*((0<G?Tt:Y)-H))),$[M+24>>2>>>0]=j.getDay(),$[M+28>>2>>>0]=(j.getTime()-X.getTime())/864e5|0,$[M>>2>>>0]=j.getSeconds(),$[M+4>>2>>>0]=j.getMinutes(),$[M+8>>2>>>0]=j.getHours(),$[M+12>>2>>>0]=j.getDate(),$[M+16>>2>>>0]=j.getMonth(),j.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function M(j,G,H){M.xa||(M.xa=!0,function(X,Y,it){function Tt(Ut){return(Ut=Ut.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Ut[1]:"GMT"}var At=new Date().getFullYear(),St=new Date(At,0,1),vt=new Date(At,6,1);At=St.getTimezoneOffset();var jt=vt.getTimezoneOffset();$[X>>2>>>0]=60*Math.max(At,jt),$[Y>>2>>>0]=+(At!=jt),X=Tt(St),Y=Tt(vt),X=Ct(X),Y=Ct(Y),jt<At?(L[it>>2>>>0]=X,L[it+4>>2>>>0]=Y):(L[it>>2>>>0]=Y,L[it+4>>2>>>0]=X)}(j,G,H))},d:function(){gt("")},t:function(){return 4294901760},h:v?()=>{var M=process.hrtime();return 1e3*M[0]+M[1]/1e6}:()=>performance.now(),J:function(M,j,G){D.copyWithin(M>>>0,j>>>0,j+G>>>0)},f:function(M){var j=D.length;if(4294901760<(M>>>=0))return!1;for(var G=1;4>=G;G*=2){var H=j*(1+.2/G);H=Math.min(H,M+100663296);var X=Math;H=Math.max(M,H),X=X.min.call(X,4294901760,H+(65536-H%65536)%65536);t:{try{A.grow(X-E.byteLength+65535>>>16),tt();var Y=1;break t}catch{}Y=void 0}if(Y)return!0}return!1},D:function(M,j){var G=0;return Mt().forEach(function(H,X){var Y=j+G;for(X=L[M+4*X>>2>>>0]=Y,Y=0;Y<H.length;++Y)C[X++>>0>>>0]=H.charCodeAt(Y);C[X>>0>>>0]=0,G+=H.length+1}),0},E:function(M,j){var G=Mt();L[M>>2>>>0]=G.length;var H=0;return G.forEach(function(X){H+=X.length+1}),L[j>>2>>>0]=H,0},r:function(M){_||(s.onExit&&s.onExit(M),P=!0),d(M,new wt(M))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(M,j,G,H){for(var X=0,Y=0;Y<G;Y++){var it=L[j>>2>>>0],Tt=L[j+4>>2>>>0];j+=8;for(var At=0;At<Tt;At++){var St=D[it+At>>>0],vt=It[M];St===0||St===10?((M===1?T:S)(V(vt,0)),vt.length=0):vt.push(St)}X+=Tt}return L[H>>2>>>0]=X,0},s:function M(j,G){M.wa||(M.wa=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var X=new Uint8Array(1);return()=>(crypto.getRandomValues(X),X[0])}if(v)try{var Y=y(760);return()=>Y.randomBytes(1)[0]}catch{}return()=>gt("randomDevice")}());for(var H=0;H<G;H++)C[j+H>>0>>>0]=M.wa();return 0},A:Gt,c:function(M,j,G,H){return Gt(M,j,G,H)}};(function(){function M(X){s.asm=X.exports,A=s.asm.P,tt(),Z.unshift(s.asm.Q),dt--,s.monitorRunDependencies&&s.monitorRunDependencies(dt),dt==0&&nt&&(X=nt,nt=null,X())}function j(X){M(X.instance)}function G(X){return function(){if(!x&&(g||b)){if(typeof fetch=="function"&&!et.startsWith("file://"))return fetch(et,{credentials:"same-origin"}).then(function(Y){if(!Y.ok)throw"failed to load wasm binary file at '"+et+"'";return Y.arrayBuffer()}).catch(function(){return ut()});if(i)return new Promise(function(Y,it){i(et,function(Tt){Y(new Uint8Array(Tt))},it)})}return Promise.resolve().then(function(){return ut()})}().then(function(Y){return WebAssembly.instantiate(Y,H)}).then(function(Y){return Y}).then(X,function(Y){S("failed to asynchronously prepare wasm: "+Y),gt(Y)})}var H={a:Lt};if(dt++,s.monitorRunDependencies&&s.monitorRunDependencies(dt),s.instantiateWasm)try{return s.instantiateWasm(H,M)}catch(X){return S("Module.instantiateWasm callback failed with error: "+X),!1}(x||typeof WebAssembly.instantiateStreaming!="function"||ct()||et.startsWith("file://")||v||typeof fetch!="function"?G(j):fetch(et,{credentials:"same-origin"}).then(function(X){return WebAssembly.instantiateStreaming(X,H).then(j,function(Y){return S("wasm streaming compile failed: "+Y),S("falling back to ArrayBuffer instantiation"),G(j)})})).catch(p)})(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.Q).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.R).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.S).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.T).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.U).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.V).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.W).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.X).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.Y).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.Z).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm._).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.$).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.aa).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.ba).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ca).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.da).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.ea).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.fa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.ga).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ha).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.ia).apply(null,arguments)};var Nt=s._malloc=function(){return(Nt=s._malloc=s.asm.ja).apply(null,arguments)};s._free=function(){return(s._free=s.asm.ka).apply(null,arguments)};var Vt,Wt=s.stackSave=function(){return(Wt=s.stackSave=s.asm.ma).apply(null,arguments)},qt=s.stackRestore=function(){return(qt=s.stackRestore=s.asm.na).apply(null,arguments)},Kt=s.stackAlloc=function(){return(Kt=s.stackAlloc=s.asm.oa).apply(null,arguments)};function Q(){function M(){if(!Vt&&(Vt=!0,s.calledRun=!0,!P)){if(Et(Z),l(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;){var j=s.postRun.shift();at.unshift(j)}Et(at)}}if(!(0<dt)){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)st();Et(rt),0<dt||(s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),M()},1)):M())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.pa).apply(null,arguments)},s.UTF8ToString=z,s.stringToUTF8=function(M,j,G){return J(M,D,j,G)},s.lengthBytesUTF8=q,s.stackSave=Wt,s.stackRestore=qt,s.stackAlloc=Kt,nt=function M(){Vt||Q(),Vt||(nt=M)},s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return Q(),f.ready});R.exports=h},4537:R=>{R.exports=function(u,y){for(var m=new Array(arguments.length-1),h=0,f=2,s=!0;f<arguments.length;)m[h++]=arguments[f++];return new Promise(function(l,p){m[h]=function(a){if(s)if(s=!1,a)p(a);else{for(var i=new Array(arguments.length-1),e=0;e<i.length;)i[e++]=arguments[e];l.apply(null,i)}};try{u.apply(y||null,m)}catch(a){s&&(s=!1,p(a))}})}},7419:(R,u)=>{var y=u;y.length=function(l){var p=l.length;if(!p)return 0;for(var a=0;--p%4>1&&l.charAt(p)==="=";)++a;return Math.ceil(3*l.length)/4-a};for(var m=new Array(64),h=new Array(123),f=0;f<64;)h[m[f]=f<26?f+65:f<52?f+71:f<62?f-4:f-59|43]=f++;y.encode=function(l,p,a){for(var i,e=null,t=[],n=0,r=0;p<a;){var o=l[p++];switch(r){case 0:t[n++]=m[o>>2],i=(3&o)<<4,r=1;break;case 1:t[n++]=m[i|o>>4],i=(15&o)<<2,r=2;break;case 2:t[n++]=m[i|o>>6],t[n++]=m[63&o],r=0}n>8191&&((e||(e=[])).push(String.fromCharCode.apply(String,t)),n=0)}return r&&(t[n++]=m[i],t[n++]=61,r===1&&(t[n++]=61)),e?(n&&e.push(String.fromCharCode.apply(String,t.slice(0,n))),e.join("")):String.fromCharCode.apply(String,t.slice(0,n))};var s="invalid encoding";y.decode=function(l,p,a){for(var i,e=a,t=0,n=0;n<l.length;){var r=l.charCodeAt(n++);if(r===61&&t>1)break;if((r=h[r])===void 0)throw Error(s);switch(t){case 0:i=r,t=1;break;case 1:p[a++]=i<<2|(48&r)>>4,i=r,t=2;break;case 2:p[a++]=(15&i)<<4|(60&r)>>2,i=r,t=3;break;case 3:p[a++]=(3&i)<<6|r,t=0}}if(t===1)throw Error(s);return a-e},y.test=function(l){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(l)}},9211:R=>{function u(){this._listeners={}}R.exports=u,u.prototype.on=function(y,m,h){return(this._listeners[y]||(this._listeners[y]=[])).push({fn:m,ctx:h||this}),this},u.prototype.off=function(y,m){if(y===void 0)this._listeners={};else if(m===void 0)this._listeners[y]=[];else for(var h=this._listeners[y],f=0;f<h.length;)h[f].fn===m?h.splice(f,1):++f;return this},u.prototype.emit=function(y){var m=this._listeners[y];if(m){for(var h=[],f=1;f<arguments.length;)h.push(arguments[f++]);for(f=0;f<m.length;)m[f].fn.apply(m[f++].ctx,h)}return this}},945:R=>{function u(s){return typeof Float32Array<"u"?function(){var l=new Float32Array([-0]),p=new Uint8Array(l.buffer),a=p[3]===128;function i(r,o,c){l[0]=r,o[c]=p[0],o[c+1]=p[1],o[c+2]=p[2],o[c+3]=p[3]}function e(r,o,c){l[0]=r,o[c]=p[3],o[c+1]=p[2],o[c+2]=p[1],o[c+3]=p[0]}function t(r,o){return p[0]=r[o],p[1]=r[o+1],p[2]=r[o+2],p[3]=r[o+3],l[0]}function n(r,o){return p[3]=r[o],p[2]=r[o+1],p[1]=r[o+2],p[0]=r[o+3],l[0]}s.writeFloatLE=a?i:e,s.writeFloatBE=a?e:i,s.readFloatLE=a?t:n,s.readFloatBE=a?n:t}():function(){function l(a,i,e,t){var n=i<0?1:0;if(n&&(i=-i),i===0)a(1/i>0?0:2147483648,e,t);else if(isNaN(i))a(2143289344,e,t);else if(i>34028234663852886e22)a((n<<31|2139095040)>>>0,e,t);else if(i<11754943508222875e-54)a((n<<31|Math.round(i/1401298464324817e-60))>>>0,e,t);else{var r=Math.floor(Math.log(i)/Math.LN2);a((n<<31|r+127<<23|8388607&Math.round(i*Math.pow(2,-r)*8388608))>>>0,e,t)}}function p(a,i,e){var t=a(i,e),n=2*(t>>31)+1,r=t>>>23&255,o=8388607&t;return r===255?o?NaN:n*(1/0):r===0?1401298464324817e-60*n*o:n*Math.pow(2,r-150)*(o+8388608)}s.writeFloatLE=l.bind(null,y),s.writeFloatBE=l.bind(null,m),s.readFloatLE=p.bind(null,h),s.readFloatBE=p.bind(null,f)}(),typeof Float64Array<"u"?function(){var l=new Float64Array([-0]),p=new Uint8Array(l.buffer),a=p[7]===128;function i(r,o,c){l[0]=r,o[c]=p[0],o[c+1]=p[1],o[c+2]=p[2],o[c+3]=p[3],o[c+4]=p[4],o[c+5]=p[5],o[c+6]=p[6],o[c+7]=p[7]}function e(r,o,c){l[0]=r,o[c]=p[7],o[c+1]=p[6],o[c+2]=p[5],o[c+3]=p[4],o[c+4]=p[3],o[c+5]=p[2],o[c+6]=p[1],o[c+7]=p[0]}function t(r,o){return p[0]=r[o],p[1]=r[o+1],p[2]=r[o+2],p[3]=r[o+3],p[4]=r[o+4],p[5]=r[o+5],p[6]=r[o+6],p[7]=r[o+7],l[0]}function n(r,o){return p[7]=r[o],p[6]=r[o+1],p[5]=r[o+2],p[4]=r[o+3],p[3]=r[o+4],p[2]=r[o+5],p[1]=r[o+6],p[0]=r[o+7],l[0]}s.writeDoubleLE=a?i:e,s.writeDoubleBE=a?e:i,s.readDoubleLE=a?t:n,s.readDoubleBE=a?n:t}():function(){function l(a,i,e,t,n,r){var o=t<0?1:0;if(o&&(t=-t),t===0)a(0,n,r+i),a(1/t>0?0:2147483648,n,r+e);else if(isNaN(t))a(0,n,r+i),a(2146959360,n,r+e);else if(t>17976931348623157e292)a(0,n,r+i),a((o<<31|2146435072)>>>0,n,r+e);else{var c;if(t<22250738585072014e-324)a((c=t/5e-324)>>>0,n,r+i),a((o<<31|c/4294967296)>>>0,n,r+e);else{var d=Math.floor(Math.log(t)/Math.LN2);d===1024&&(d=1023),a(4503599627370496*(c=t*Math.pow(2,-d))>>>0,n,r+i),a((o<<31|d+1023<<20|1048576*c&1048575)>>>0,n,r+e)}}}function p(a,i,e,t,n){var r=a(t,n+i),o=a(t,n+e),c=2*(o>>31)+1,d=o>>>20&2047,g=4294967296*(1048575&o)+r;return d===2047?g?NaN:c*(1/0):d===0?5e-324*c*g:c*Math.pow(2,d-1075)*(g+4503599627370496)}s.writeDoubleLE=l.bind(null,y,0,4),s.writeDoubleBE=l.bind(null,m,4,0),s.readDoubleLE=p.bind(null,h,0,4),s.readDoubleBE=p.bind(null,f,4,0)}(),s}function y(s,l,p){l[p]=255&s,l[p+1]=s>>>8&255,l[p+2]=s>>>16&255,l[p+3]=s>>>24}function m(s,l,p){l[p]=s>>>24,l[p+1]=s>>>16&255,l[p+2]=s>>>8&255,l[p+3]=255&s}function h(s,l){return(s[l]|s[l+1]<<8|s[l+2]<<16|s[l+3]<<24)>>>0}function f(s,l){return(s[l]<<24|s[l+1]<<16|s[l+2]<<8|s[l+3])>>>0}R.exports=u(u)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(R){}return null}module.exports=inquire},6662:R=>{R.exports=function(u,y,m){var h=m||8192,f=h>>>1,s=null,l=h;return function(p){if(p<1||p>f)return u(p);l+p>h&&(s=u(h),l=0);var a=y.call(s,l,l+=p);return 7&l&&(l=1+(7|l)),a}}},4997:(R,u)=>{var y=u;y.length=function(m){for(var h=0,f=0,s=0;s<m.length;++s)(f=m.charCodeAt(s))<128?h+=1:f<2048?h+=2:(64512&f)==55296&&(64512&m.charCodeAt(s+1))==56320?(++s,h+=4):h+=3;return h},y.read=function(m,h,f){if(f-h<1)return"";for(var s,l=null,p=[],a=0;h<f;)(s=m[h++])<128?p[a++]=s:s>191&&s<224?p[a++]=(31&s)<<6|63&m[h++]:s>239&&s<365?(s=((7&s)<<18|(63&m[h++])<<12|(63&m[h++])<<6|63&m[h++])-65536,p[a++]=55296+(s>>10),p[a++]=56320+(1023&s)):p[a++]=(15&s)<<12|(63&m[h++])<<6|63&m[h++],a>8191&&((l||(l=[])).push(String.fromCharCode.apply(String,p)),a=0);return l?(a&&l.push(String.fromCharCode.apply(String,p.slice(0,a))),l.join("")):String.fromCharCode.apply(String,p.slice(0,a))},y.write=function(m,h,f){for(var s,l,p=f,a=0;a<m.length;++a)(s=m.charCodeAt(a))<128?h[f++]=s:s<2048?(h[f++]=s>>6|192,h[f++]=63&s|128):(64512&s)==55296&&(64512&(l=m.charCodeAt(a+1)))==56320?(s=65536+((1023&s)<<10)+(1023&l),++a,h[f++]=s>>18|240,h[f++]=s>>12&63|128,h[f++]=s>>6&63|128,h[f++]=63&s|128):(h[f++]=s>>12|224,h[f++]=s>>6&63|128,h[f++]=63&s|128);return f-p}},3442:(R,u)=>{u.__esModule=!0;var y=function(){function m(h){if(!h)throw new TypeError("Invalid argument; `value` has no value.");this.value=m.EMPTY,h&&m.isGuid(h)&&(this.value=h)}return m.isGuid=function(h){var f=h.toString();return h&&(h instanceof m||m.validator.test(f))},m.create=function(){return new m([m.gen(2),m.gen(1),m.gen(1),m.gen(1),m.gen(3)].join("-"))},m.createEmpty=function(){return new m("emptyguid")},m.parse=function(h){return new m(h)},m.raw=function(){return[m.gen(2),m.gen(1),m.gen(1),m.gen(1),m.gen(3)].join("-")},m.gen=function(h){for(var f="",s=0;s<h;s++)f+=(65536*(1+Math.random())|0).toString(16).substring(1);return f},m.prototype.equals=function(h){return m.isGuid(h)&&this.value===h.toString()},m.prototype.isEmpty=function(){return this.value===m.EMPTY},m.prototype.toString=function(){return this.value},m.prototype.toJSON=function(){return{value:this.value}},m.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),m.EMPTY="00000000-0000-0000-0000-000000000000",m}();u.Guid=y},3720:R=>{R.exports=y;var u=null;try{u=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function y(_,A,E){this.low=0|_,this.high=0|A,this.unsigned=!!E}function m(_){return(_&&_.__isLong__)===!0}y.prototype.__isLong__,Object.defineProperty(y.prototype,"__isLong__",{value:!0}),y.isLong=m;var h={},f={};function s(_,A){var E,C,D;return A?(D=0<=(_>>>=0)&&_<256)&&(C=f[_])?C:(E=p(_,(0|_)<0?-1:0,!0),D&&(f[_]=E),E):(D=-128<=(_|=0)&&_<128)&&(C=h[_])?C:(E=p(_,_<0?-1:0,!1),D&&(h[_]=E),E)}function l(_,A){if(isNaN(_))return A?d:c;if(A){if(_<0)return d;if(_>=n)return x}else{if(_<=-r)return T;if(_+1>=r)return w}return _<0?l(-_,A).neg():p(_%t|0,_/t|0,A)}function p(_,A,E){return new y(_,A,E)}y.fromInt=s,y.fromNumber=l,y.fromBits=p;var a=Math.pow;function i(_,A,E){if(_.length===0)throw Error("empty string");if(_==="NaN"||_==="Infinity"||_==="+Infinity"||_==="-Infinity")return c;if(typeof A=="number"?(E=A,A=!1):A=!!A,(E=E||10)<2||36<E)throw RangeError("radix");var C;if((C=_.indexOf("-"))>0)throw Error("interior hyphen");if(C===0)return i(_.substring(1),A,E).neg();for(var D=l(a(E,8)),$=c,L=0;L<_.length;L+=8){var P=Math.min(8,_.length-L),k=parseInt(_.substring(L,L+P),E);if(P<8){var V=l(a(E,P));$=$.mul(V).add(l(k))}else $=($=$.mul(D)).add(l(k))}return $.unsigned=A,$}function e(_,A){return typeof _=="number"?l(_,A):typeof _=="string"?i(_,A):p(_.low,_.high,typeof A=="boolean"?A:_.unsigned)}y.fromString=i,y.fromValue=e;var t=4294967296,n=t*t,r=n/2,o=s(1<<24),c=s(0);y.ZERO=c;var d=s(0,!0);y.UZERO=d;var g=s(1);y.ONE=g;var b=s(1,!0);y.UONE=b;var v=s(-1);y.NEG_ONE=v;var w=p(-1,2147483647,!1);y.MAX_VALUE=w;var x=p(-1,-1,!0);y.MAX_UNSIGNED_VALUE=x;var T=p(0,-2147483648,!1);y.MIN_VALUE=T;var S=y.prototype;S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*t+(this.low>>>0):this.high*t+(this.low>>>0)},S.toString=function(_){if((_=_||10)<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(T)){var A=l(_),E=this.div(A),C=E.mul(A).sub(this);return E.toString(_)+C.toInt().toString(_)}return"-"+this.neg().toString(_)}for(var D=l(a(_,6),this.unsigned),$=this,L="";;){var P=$.div(D),k=($.sub(P.mul(D)).toInt()>>>0).toString(_);if(($=P).isZero())return k+L;for(;k.length<6;)k="0"+k;L=""+k+L}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var _=this.high!=0?this.high:this.low,A=31;A>0&&!(_&1<<A);A--);return this.high!=0?A+33:A+1},S.isZero=function(){return this.high===0&&this.low===0},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return(1&this.low)==1},S.isEven=function(){return(1&this.low)==0},S.equals=function(_){return m(_)||(_=e(_)),(this.unsigned===_.unsigned||this.high>>>31!=1||_.high>>>31!=1)&&this.high===_.high&&this.low===_.low},S.eq=S.equals,S.notEquals=function(_){return!this.eq(_)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(_){return this.comp(_)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(_){return this.comp(_)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(_){return this.comp(_)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(_){return this.comp(_)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(_){if(m(_)||(_=e(_)),this.eq(_))return 0;var A=this.isNegative(),E=_.isNegative();return A&&!E?-1:!A&&E?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(g)},S.neg=S.negate,S.add=function(_){m(_)||(_=e(_));var A=this.high>>>16,E=65535&this.high,C=this.low>>>16,D=65535&this.low,$=_.high>>>16,L=65535&_.high,P=_.low>>>16,k=0,V=0,z=0,J=0;return z+=(J+=D+(65535&_.low))>>>16,V+=(z+=C+P)>>>16,k+=(V+=E+L)>>>16,k+=A+$,p((z&=65535)<<16|(J&=65535),(k&=65535)<<16|(V&=65535),this.unsigned)},S.subtract=function(_){return m(_)||(_=e(_)),this.add(_.neg())},S.sub=S.subtract,S.multiply=function(_){if(this.isZero())return c;if(m(_)||(_=e(_)),u)return p(u.mul(this.low,this.high,_.low,_.high),u.get_high(),this.unsigned);if(_.isZero())return c;if(this.eq(T))return _.isOdd()?T:c;if(_.eq(T))return this.isOdd()?T:c;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(o)&&_.lt(o))return l(this.toNumber()*_.toNumber(),this.unsigned);var A=this.high>>>16,E=65535&this.high,C=this.low>>>16,D=65535&this.low,$=_.high>>>16,L=65535&_.high,P=_.low>>>16,k=65535&_.low,V=0,z=0,J=0,q=0;return J+=(q+=D*k)>>>16,z+=(J+=C*k)>>>16,J&=65535,z+=(J+=D*P)>>>16,V+=(z+=E*k)>>>16,z&=65535,V+=(z+=C*P)>>>16,z&=65535,V+=(z+=D*L)>>>16,V+=A*k+E*P+C*L+D*$,p((J&=65535)<<16|(q&=65535),(V&=65535)<<16|(z&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(_){if(m(_)||(_=e(_)),_.isZero())throw Error("division by zero");var A,E,C;if(u)return this.unsigned||this.high!==-2147483648||_.low!==-1||_.high!==-1?p((this.unsigned?u.div_u:u.div_s)(this.low,this.high,_.low,_.high),u.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?d:c;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return d;if(_.gt(this.shru(1)))return b;C=d}else{if(this.eq(T))return _.eq(g)||_.eq(v)?T:_.eq(T)?g:(A=this.shr(1).div(_).shl(1)).eq(c)?_.isNegative()?g:v:(E=this.sub(_.mul(A)),C=A.add(E.div(_)));if(_.eq(T))return this.unsigned?d:c;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();C=c}for(E=this;E.gte(_);){A=Math.max(1,Math.floor(E.toNumber()/_.toNumber()));for(var D=Math.ceil(Math.log(A)/Math.LN2),$=D<=48?1:a(2,D-48),L=l(A),P=L.mul(_);P.isNegative()||P.gt(E);)P=(L=l(A-=$,this.unsigned)).mul(_);L.isZero()&&(L=g),C=C.add(L),E=E.sub(P)}return C},S.div=S.divide,S.modulo=function(_){return m(_)||(_=e(_)),u?p((this.unsigned?u.rem_u:u.rem_s)(this.low,this.high,_.low,_.high),u.get_high(),this.unsigned):this.sub(this.div(_).mul(_))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return p(~this.low,~this.high,this.unsigned)},S.and=function(_){return m(_)||(_=e(_)),p(this.low&_.low,this.high&_.high,this.unsigned)},S.or=function(_){return m(_)||(_=e(_)),p(this.low|_.low,this.high|_.high,this.unsigned)},S.xor=function(_){return m(_)||(_=e(_)),p(this.low^_.low,this.high^_.high,this.unsigned)},S.shiftLeft=function(_){return m(_)&&(_=_.toInt()),(_&=63)==0?this:_<32?p(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):p(0,this.low<<_-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(_){return m(_)&&(_=_.toInt()),(_&=63)==0?this:_<32?p(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):p(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(_){if(m(_)&&(_=_.toInt()),(_&=63)==0)return this;var A=this.high;return _<32?p(this.low>>>_|A<<32-_,A>>>_,this.unsigned):p(_===32?A:A>>>_-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?p(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:p(this.low,this.high,!0)},S.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var _=this.high,A=this.low;return[255&A,A>>>8&255,A>>>16&255,A>>>24,255&_,_>>>8&255,_>>>16&255,_>>>24]},S.toBytesBE=function(){var _=this.high,A=this.low;return[_>>>24,_>>>16&255,_>>>8&255,255&_,A>>>24,A>>>16&255,A>>>8&255,255&A]},y.fromBytes=function(_,A,E){return E?y.fromBytesLE(_,A):y.fromBytesBE(_,A)},y.fromBytesLE=function(_,A){return new y(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,A)},y.fromBytesBE=function(_,A){return new y(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],A)}},1446:(R,u,y)=>{var m,h,f,s=y(2100),l=s.Reader,p=s.Writer,a=s.util,i=s.roots.default||(s.roots.default={});i.onnx=((f={}).Version=(m={},(h=Object.create(m))[m[0]="_START_VERSION"]=0,h[m[1]="IR_VERSION_2017_10_10"]=1,h[m[2]="IR_VERSION_2017_10_30"]=2,h[m[3]="IR_VERSION_2017_11_3"]=3,h[m[4]="IR_VERSION_2019_1_22"]=4,h[m[5]="IR_VERSION"]=5,h),f.AttributeProto=function(){function e(t){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}return e.prototype.name="",e.prototype.refAttrName="",e.prototype.docString="",e.prototype.type=0,e.prototype.f=0,e.prototype.i=a.Long?a.Long.fromBits(0,0,!1):0,e.prototype.s=a.newBuffer([]),e.prototype.t=null,e.prototype.g=null,e.prototype.floats=a.emptyArray,e.prototype.ints=a.emptyArray,e.prototype.strings=a.emptyArray,e.prototype.tensors=a.emptyArray,e.prototype.graphs=a.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=p.create()),t.name!=null&&t.hasOwnProperty("name")&&n.uint32(10).string(t.name),t.f!=null&&t.hasOwnProperty("f")&&n.uint32(21).float(t.f),t.i!=null&&t.hasOwnProperty("i")&&n.uint32(24).int64(t.i),t.s!=null&&t.hasOwnProperty("s")&&n.uint32(34).bytes(t.s),t.t!=null&&t.hasOwnProperty("t")&&i.onnx.TensorProto.encode(t.t,n.uint32(42).fork()).ldelim(),t.g!=null&&t.hasOwnProperty("g")&&i.onnx.GraphProto.encode(t.g,n.uint32(50).fork()).ldelim(),t.floats!=null&&t.floats.length){n.uint32(58).fork();for(var r=0;r<t.floats.length;++r)n.float(t.floats[r]);n.ldelim()}if(t.ints!=null&&t.ints.length){for(n.uint32(66).fork(),r=0;r<t.ints.length;++r)n.int64(t.ints[r]);n.ldelim()}if(t.strings!=null&&t.strings.length)for(r=0;r<t.strings.length;++r)n.uint32(74).bytes(t.strings[r]);if(t.tensors!=null&&t.tensors.length)for(r=0;r<t.tensors.length;++r)i.onnx.TensorProto.encode(t.tensors[r],n.uint32(82).fork()).ldelim();if(t.graphs!=null&&t.graphs.length)for(r=0;r<t.graphs.length;++r)i.onnx.GraphProto.encode(t.graphs[r],n.uint32(90).fork()).ldelim();return t.docString!=null&&t.hasOwnProperty("docString")&&n.uint32(106).string(t.docString),t.type!=null&&t.hasOwnProperty("type")&&n.uint32(160).int32(t.type),t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&n.uint32(170).string(t.refAttrName),n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof l||(t=l.create(t));for(var r=n===void 0?t.len:t.pos+n,o=new i.onnx.AttributeProto;t.pos<r;){var c=t.uint32();switch(c>>>3){case 1:o.name=t.string();break;case 21:o.refAttrName=t.string();break;case 13:o.docString=t.string();break;case 20:o.type=t.int32();break;case 2:o.f=t.float();break;case 3:o.i=t.int64();break;case 4:o.s=t.bytes();break;case 5:o.t=i.onnx.TensorProto.decode(t,t.uint32());break;case 6:o.g=i.onnx.GraphProto.decode(t,t.uint32());break;case 7:if(o.floats&&o.floats.length||(o.floats=[]),(7&c)==2)for(var d=t.uint32()+t.pos;t.pos<d;)o.floats.push(t.float());else o.floats.push(t.float());break;case 8:if(o.ints&&o.ints.length||(o.ints=[]),(7&c)==2)for(d=t.uint32()+t.pos;t.pos<d;)o.ints.push(t.int64());else o.ints.push(t.int64());break;case 9:o.strings&&o.strings.length||(o.strings=[]),o.strings.push(t.bytes());break;case 10:o.tensors&&o.tensors.length||(o.tensors=[]),o.tensors.push(i.onnx.TensorProto.decode(t,t.uint32()));break;case 11:o.graphs&&o.graphs.length||(o.graphs=[]),o.graphs.push(i.onnx.GraphProto.decode(t,t.uint32()));break;default:t.skipType(7&c)}}return o},e.decodeDelimited=function(t){return t instanceof l||(t=new l(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!a.isString(t.name))return"name: string expected";if(t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&!a.isString(t.refAttrName))return"refAttrName: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString))return"docString: string expected";if(t.type!=null&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(t.f!=null&&t.hasOwnProperty("f")&&typeof t.f!="number")return"f: number expected";if(t.i!=null&&t.hasOwnProperty("i")&&!(a.isInteger(t.i)||t.i&&a.isInteger(t.i.low)&&a.isInteger(t.i.high)))return"i: integer|Long expected";if(t.s!=null&&t.hasOwnProperty("s")&&!(t.s&&typeof t.s.length=="number"||a.isString(t.s)))return"s: buffer expected";if(t.t!=null&&t.hasOwnProperty("t")&&(r=i.onnx.TensorProto.verify(t.t)))return"t."+r;if(t.g!=null&&t.hasOwnProperty("g")&&(r=i.onnx.GraphProto.verify(t.g)))return"g."+r;if(t.floats!=null&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var n=0;n<t.floats.length;++n)if(typeof t.floats[n]!="number")return"floats: number[] expected"}if(t.ints!=null&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(n=0;n<t.ints.length;++n)if(!(a.isInteger(t.ints[n])||t.ints[n]&&a.isInteger(t.ints[n].low)&&a.isInteger(t.ints[n].high)))return"ints: integer|Long[] expected"}if(t.strings!=null&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(n=0;n<t.strings.length;++n)if(!(t.strings[n]&&typeof t.strings[n].length=="number"||a.isString(t.strings[n])))return"strings: buffer[] expected"}if(t.tensors!=null&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(n=0;n<t.tensors.length;++n)if(r=i.onnx.TensorProto.verify(t.tensors[n]))return"tensors."+r}if(t.graphs!=null&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(n=0;n<t.graphs.length;++n){var r;if(r=i.onnx.GraphProto.verify(t.graphs[n]))return"graphs."+r}}return null},e.fromObject=function(t){if(t instanceof i.onnx.AttributeProto)return t;var n=new i.onnx.AttributeProto;switch(t.name!=null&&(n.name=String(t.name)),t.refAttrName!=null&&(n.refAttrName=String(t.refAttrName)),t.docString!=null&&(n.docString=String(t.docString)),t.type){case"UNDEFINED":case 0:n.type=0;break;case"FLOAT":case 1:n.type=1;break;case"INT":case 2:n.type=2;break;case"STRING":case 3:n.type=3;break;case"TENSOR":case 4:n.type=4;break;case"GRAPH":case 5:n.type=5;break;case"FLOATS":case 6:n.type=6;break;case"INTS":case 7:n.type=7;break;case"STRINGS":case 8:n.type=8;break;case"TENSORS":case 9:n.type=9;break;case"GRAPHS":case 10:n.type=10}if(t.f!=null&&(n.f=Number(t.f)),t.i!=null&&(a.Long?(n.i=a.Long.fromValue(t.i)).unsigned=!1:typeof t.i=="string"?n.i=parseInt(t.i,10):typeof t.i=="number"?n.i=t.i:typeof t.i=="object"&&(n.i=new a.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),t.s!=null&&(typeof t.s=="string"?a.base64.decode(t.s,n.s=a.newBuffer(a.base64.length(t.s)),0):t.s.length&&(n.s=t.s)),t.t!=null){if(typeof t.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");n.t=i.onnx.TensorProto.fromObject(t.t)}if(t.g!=null){if(typeof t.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");n.g=i.onnx.GraphProto.fromObject(t.g)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");n.floats=[];for(var r=0;r<t.floats.length;++r)n.floats[r]=Number(t.floats[r])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(n.ints=[],r=0;r<t.ints.length;++r)a.Long?(n.ints[r]=a.Long.fromValue(t.ints[r])).unsigned=!1:typeof t.ints[r]=="string"?n.ints[r]=parseInt(t.ints[r],10):typeof t.ints[r]=="number"?n.ints[r]=t.ints[r]:typeof t.ints[r]=="object"&&(n.ints[r]=new a.LongBits(t.ints[r].low>>>0,t.ints[r].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(n.strings=[],r=0;r<t.strings.length;++r)typeof t.strings[r]=="string"?a.base64.decode(t.strings[r],n.strings[r]=a.newBuffer(a.base64.length(t.strings[r])),0):t.strings[r].length&&(n.strings[r]=t.strings[r])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(n.tensors=[],r=0;r<t.tensors.length;++r){if(typeof t.tensors[r]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");n.tensors[r]=i.onnx.TensorProto.fromObject(t.tensors[r])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(n.graphs=[],r=0;r<t.graphs.length;++r){if(typeof t.graphs[r]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");n.graphs[r]=i.onnx.GraphProto.fromObject(t.graphs[r])}}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.floats=[],r.ints=[],r.strings=[],r.tensors=[],r.graphs=[]),n.defaults){if(r.name="",r.f=0,a.Long){var o=new a.Long(0,0,!1);r.i=n.longs===String?o.toString():n.longs===Number?o.toNumber():o}else r.i=n.longs===String?"0":0;n.bytes===String?r.s="":(r.s=[],n.bytes!==Array&&(r.s=a.newBuffer(r.s))),r.t=null,r.g=null,r.docString="",r.type=n.enums===String?"UNDEFINED":0,r.refAttrName=""}if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.f!=null&&t.hasOwnProperty("f")&&(r.f=n.json&&!isFinite(t.f)?String(t.f):t.f),t.i!=null&&t.hasOwnProperty("i")&&(typeof t.i=="number"?r.i=n.longs===String?String(t.i):t.i:r.i=n.longs===String?a.Long.prototype.toString.call(t.i):n.longs===Number?new a.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),t.s!=null&&t.hasOwnProperty("s")&&(r.s=n.bytes===String?a.base64.encode(t.s,0,t.s.length):n.bytes===Array?Array.prototype.slice.call(t.s):t.s),t.t!=null&&t.hasOwnProperty("t")&&(r.t=i.onnx.TensorProto.toObject(t.t,n)),t.g!=null&&t.hasOwnProperty("g")&&(r.g=i.onnx.GraphProto.toObject(t.g,n)),t.floats&&t.floats.length){r.floats=[];for(var c=0;c<t.floats.length;++c)r.floats[c]=n.json&&!isFinite(t.floats[c])?String(t.floats[c]):t.floats[c]}if(t.ints&&t.ints.length)for(r.ints=[],c=0;c<t.ints.length;++c)typeof t.ints[c]=="number"?r.ints[c]=n.longs===String?String(t.ints[c]):t.ints[c]:r.ints[c]=n.longs===String?a.Long.prototype.toString.call(t.ints[c]):n.longs===Number?new a.LongBits(t.ints[c].low>>>0,t.ints[c].high>>>0).toNumber():t.ints[c];if(t.strings&&t.strings.length)for(r.strings=[],c=0;c<t.strings.length;++c)r.strings[c]=n.bytes===String?a.base64.encode(t.strings[c],0,t.strings[c].length):n.bytes===Array?Array.prototype.slice.call(t.strings[c]):t.strings[c];if(t.tensors&&t.tensors.length)for(r.tensors=[],c=0;c<t.tensors.length;++c)r.tensors[c]=i.onnx.TensorProto.toObject(t.tensors[c],n);if(t.graphs&&t.graphs.length)for(r.graphs=[],c=0;c<t.graphs.length;++c)r.graphs[c]=i.onnx.GraphProto.toObject(t.graphs[c],n);return t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.type!=null&&t.hasOwnProperty("type")&&(r.type=n.enums===String?i.onnx.AttributeProto.AttributeType[t.type]:t.type),t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&(r.refAttrName=t.refAttrName),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e.AttributeType=function(){var t={},n=Object.create(t);return n[t[0]="UNDEFINED"]=0,n[t[1]="FLOAT"]=1,n[t[2]="INT"]=2,n[t[3]="STRING"]=3,n[t[4]="TENSOR"]=4,n[t[5]="GRAPH"]=5,n[t[6]="FLOATS"]=6,n[t[7]="INTS"]=7,n[t[8]="STRINGS"]=8,n[t[9]="TENSORS"]=9,n[t[10]="GRAPHS"]=10,n}(),e}(),f.ValueInfoProto=function(){function e(t){if(t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}return e.prototype.name="",e.prototype.type=null,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,n){return n||(n=p.create()),t.name!=null&&t.hasOwnProperty("name")&&n.uint32(10).string(t.name),t.type!=null&&t.hasOwnProperty("type")&&i.onnx.TypeProto.encode(t.type,n.uint32(18).fork()).ldelim(),t.docString!=null&&t.hasOwnProperty("docString")&&n.uint32(26).string(t.docString),n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof l||(t=l.create(t));for(var r=n===void 0?t.len:t.pos+n,o=new i.onnx.ValueInfoProto;t.pos<r;){var c=t.uint32();switch(c>>>3){case 1:o.name=t.string();break;case 2:o.type=i.onnx.TypeProto.decode(t,t.uint32());break;case 3:o.docString=t.string();break;default:t.skipType(7&c)}}return o},e.decodeDelimited=function(t){return t instanceof l||(t=new l(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!a.isString(t.name))return"name: string expected";if(t.type!=null&&t.hasOwnProperty("type")){var n=i.onnx.TypeProto.verify(t.type);if(n)return"type."+n}return t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof i.onnx.ValueInfoProto)return t;var n=new i.onnx.ValueInfoProto;if(t.name!=null&&(n.name=String(t.name)),t.type!=null){if(typeof t.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");n.type=i.onnx.TypeProto.fromObject(t.type)}return t.docString!=null&&(n.docString=String(t.docString)),n},e.toObject=function(t,n){n||(n={});var r={};return n.defaults&&(r.name="",r.type=null,r.docString=""),t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.type!=null&&t.hasOwnProperty("type")&&(r.type=i.onnx.TypeProto.toObject(t.type,n)),t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e}(),f.NodeProto=function(){function e(t){if(this.input=[],this.output=[],this.attribute=[],t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}return e.prototype.input=a.emptyArray,e.prototype.output=a.emptyArray,e.prototype.name="",e.prototype.opType="",e.prototype.domain="",e.prototype.attribute=a.emptyArray,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=p.create()),t.input!=null&&t.input.length)for(var r=0;r<t.input.length;++r)n.uint32(10).string(t.input[r]);if(t.output!=null&&t.output.length)for(r=0;r<t.output.length;++r)n.uint32(18).string(t.output[r]);if(t.name!=null&&t.hasOwnProperty("name")&&n.uint32(26).string(t.name),t.opType!=null&&t.hasOwnProperty("opType")&&n.uint32(34).string(t.opType),t.attribute!=null&&t.attribute.length)for(r=0;r<t.attribute.length;++r)i.onnx.AttributeProto.encode(t.attribute[r],n.uint32(42).fork()).ldelim();return t.docString!=null&&t.hasOwnProperty("docString")&&n.uint32(50).string(t.docString),t.domain!=null&&t.hasOwnProperty("domain")&&n.uint32(58).string(t.domain),n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof l||(t=l.create(t));for(var r=n===void 0?t.len:t.pos+n,o=new i.onnx.NodeProto;t.pos<r;){var c=t.uint32();switch(c>>>3){case 1:o.input&&o.input.length||(o.input=[]),o.input.push(t.string());break;case 2:o.output&&o.output.length||(o.output=[]),o.output.push(t.string());break;case 3:o.name=t.string();break;case 4:o.opType=t.string();break;case 7:o.domain=t.string();break;case 5:o.attribute&&o.attribute.length||(o.attribute=[]),o.attribute.push(i.onnx.AttributeProto.decode(t,t.uint32()));break;case 6:o.docString=t.string();break;default:t.skipType(7&c)}}return o},e.decodeDelimited=function(t){return t instanceof l||(t=new l(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var n=0;n<t.input.length;++n)if(!a.isString(t.input[n]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(n=0;n<t.output.length;++n)if(!a.isString(t.output[n]))return"output: string[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!a.isString(t.name))return"name: string expected";if(t.opType!=null&&t.hasOwnProperty("opType")&&!a.isString(t.opType))return"opType: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!a.isString(t.domain))return"domain: string expected";if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(n=0;n<t.attribute.length;++n){var r=i.onnx.AttributeProto.verify(t.attribute[n]);if(r)return"attribute."+r}}return t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof i.onnx.NodeProto)return t;var n=new i.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");n.input=[];for(var r=0;r<t.input.length;++r)n.input[r]=String(t.input[r])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");for(n.output=[],r=0;r<t.output.length;++r)n.output[r]=String(t.output[r])}if(t.name!=null&&(n.name=String(t.name)),t.opType!=null&&(n.opType=String(t.opType)),t.domain!=null&&(n.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(n.attribute=[],r=0;r<t.attribute.length;++r){if(typeof t.attribute[r]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");n.attribute[r]=i.onnx.AttributeProto.fromObject(t.attribute[r])}}return t.docString!=null&&(n.docString=String(t.docString)),n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.input=[],r.output=[],r.attribute=[]),n.defaults&&(r.name="",r.opType="",r.docString="",r.domain=""),t.input&&t.input.length){r.input=[];for(var o=0;o<t.input.length;++o)r.input[o]=t.input[o]}if(t.output&&t.output.length)for(r.output=[],o=0;o<t.output.length;++o)r.output[o]=t.output[o];if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.opType!=null&&t.hasOwnProperty("opType")&&(r.opType=t.opType),t.attribute&&t.attribute.length)for(r.attribute=[],o=0;o<t.attribute.length;++o)r.attribute[o]=i.onnx.AttributeProto.toObject(t.attribute[o],n);return t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.domain!=null&&t.hasOwnProperty("domain")&&(r.domain=t.domain),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e}(),f.ModelProto=function(){function e(t){if(this.opsetImport=[],this.metadataProps=[],t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}return e.prototype.irVersion=a.Long?a.Long.fromBits(0,0,!1):0,e.prototype.opsetImport=a.emptyArray,e.prototype.producerName="",e.prototype.producerVersion="",e.prototype.domain="",e.prototype.modelVersion=a.Long?a.Long.fromBits(0,0,!1):0,e.prototype.docString="",e.prototype.graph=null,e.prototype.metadataProps=a.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=p.create()),t.irVersion!=null&&t.hasOwnProperty("irVersion")&&n.uint32(8).int64(t.irVersion),t.producerName!=null&&t.hasOwnProperty("producerName")&&n.uint32(18).string(t.producerName),t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&n.uint32(26).string(t.producerVersion),t.domain!=null&&t.hasOwnProperty("domain")&&n.uint32(34).string(t.domain),t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&n.uint32(40).int64(t.modelVersion),t.docString!=null&&t.hasOwnProperty("docString")&&n.uint32(50).string(t.docString),t.graph!=null&&t.hasOwnProperty("graph")&&i.onnx.GraphProto.encode(t.graph,n.uint32(58).fork()).ldelim(),t.opsetImport!=null&&t.opsetImport.length)for(var r=0;r<t.opsetImport.length;++r)i.onnx.OperatorSetIdProto.encode(t.opsetImport[r],n.uint32(66).fork()).ldelim();if(t.metadataProps!=null&&t.metadataProps.length)for(r=0;r<t.metadataProps.length;++r)i.onnx.StringStringEntryProto.encode(t.metadataProps[r],n.uint32(114).fork()).ldelim();return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof l||(t=l.create(t));for(var r=n===void 0?t.len:t.pos+n,o=new i.onnx.ModelProto;t.pos<r;){var c=t.uint32();switch(c>>>3){case 1:o.irVersion=t.int64();break;case 8:o.opsetImport&&o.opsetImport.length||(o.opsetImport=[]),o.opsetImport.push(i.onnx.OperatorSetIdProto.decode(t,t.uint32()));break;case 2:o.producerName=t.string();break;case 3:o.producerVersion=t.string();break;case 4:o.domain=t.string();break;case 5:o.modelVersion=t.int64();break;case 6:o.docString=t.string();break;case 7:o.graph=i.onnx.GraphProto.decode(t,t.uint32());break;case 14:o.metadataProps&&o.metadataProps.length||(o.metadataProps=[]),o.metadataProps.push(i.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&c)}}return o},e.decodeDelimited=function(t){return t instanceof l||(t=new l(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&!(a.isInteger(t.irVersion)||t.irVersion&&a.isInteger(t.irVersion.low)&&a.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var n=0;n<t.opsetImport.length;++n)if(r=i.onnx.OperatorSetIdProto.verify(t.opsetImport[n]))return"opsetImport."+r}if(t.producerName!=null&&t.hasOwnProperty("producerName")&&!a.isString(t.producerName))return"producerName: string expected";if(t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&!a.isString(t.producerVersion))return"producerVersion: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!a.isString(t.domain))return"domain: string expected";if(t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&!(a.isInteger(t.modelVersion)||t.modelVersion&&a.isInteger(t.modelVersion.low)&&a.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString))return"docString: string expected";if(t.graph!=null&&t.hasOwnProperty("graph")&&(r=i.onnx.GraphProto.verify(t.graph)))return"graph."+r;if(t.metadataProps!=null&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(n=0;n<t.metadataProps.length;++n){var r;if(r=i.onnx.StringStringEntryProto.verify(t.metadataProps[n]))return"metadataProps."+r}}return null},e.fromObject=function(t){if(t instanceof i.onnx.ModelProto)return t;var n=new i.onnx.ModelProto;if(t.irVersion!=null&&(a.Long?(n.irVersion=a.Long.fromValue(t.irVersion)).unsigned=!1:typeof t.irVersion=="string"?n.irVersion=parseInt(t.irVersion,10):typeof t.irVersion=="number"?n.irVersion=t.irVersion:typeof t.irVersion=="object"&&(n.irVersion=new a.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");n.opsetImport=[];for(var r=0;r<t.opsetImport.length;++r){if(typeof t.opsetImport[r]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");n.opsetImport[r]=i.onnx.OperatorSetIdProto.fromObject(t.opsetImport[r])}}if(t.producerName!=null&&(n.producerName=String(t.producerName)),t.producerVersion!=null&&(n.producerVersion=String(t.producerVersion)),t.domain!=null&&(n.domain=String(t.domain)),t.modelVersion!=null&&(a.Long?(n.modelVersion=a.Long.fromValue(t.modelVersion)).unsigned=!1:typeof t.modelVersion=="string"?n.modelVersion=parseInt(t.modelVersion,10):typeof t.modelVersion=="number"?n.modelVersion=t.modelVersion:typeof t.modelVersion=="object"&&(n.modelVersion=new a.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),t.docString!=null&&(n.docString=String(t.docString)),t.graph!=null){if(typeof t.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");n.graph=i.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(n.metadataProps=[],r=0;r<t.metadataProps.length;++r){if(typeof t.metadataProps[r]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");n.metadataProps[r]=i.onnx.StringStringEntryProto.fromObject(t.metadataProps[r])}}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.opsetImport=[],r.metadataProps=[]),n.defaults){if(a.Long){var o=new a.Long(0,0,!1);r.irVersion=n.longs===String?o.toString():n.longs===Number?o.toNumber():o}else r.irVersion=n.longs===String?"0":0;r.producerName="",r.producerVersion="",r.domain="",a.Long?(o=new a.Long(0,0,!1),r.modelVersion=n.longs===String?o.toString():n.longs===Number?o.toNumber():o):r.modelVersion=n.longs===String?"0":0,r.docString="",r.graph=null}if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&(typeof t.irVersion=="number"?r.irVersion=n.longs===String?String(t.irVersion):t.irVersion:r.irVersion=n.longs===String?a.Long.prototype.toString.call(t.irVersion):n.longs===Number?new a.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),t.producerName!=null&&t.hasOwnProperty("producerName")&&(r.producerName=t.producerName),t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&(r.producerVersion=t.producerVersion),t.domain!=null&&t.hasOwnProperty("domain")&&(r.domain=t.domain),t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&(typeof t.modelVersion=="number"?r.modelVersion=n.longs===String?String(t.modelVersion):t.modelVersion:r.modelVersion=n.longs===String?a.Long.prototype.toString.call(t.modelVersion):n.longs===Number?new a.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.graph!=null&&t.hasOwnProperty("graph")&&(r.graph=i.onnx.GraphProto.toObject(t.graph,n)),t.opsetImport&&t.opsetImport.length){r.opsetImport=[];for(var c=0;c<t.opsetImport.length;++c)r.opsetImport[c]=i.onnx.OperatorSetIdProto.toObject(t.opsetImport[c],n)}if(t.metadataProps&&t.metadataProps.length)for(r.metadataProps=[],c=0;c<t.metadataProps.length;++c)r.metadataProps[c]=i.onnx.StringStringEntryProto.toObject(t.metadataProps[c],n);return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e}(),f.StringStringEntryProto=function(){function e(t){if(t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}return e.prototype.key="",e.prototype.value="",e.create=function(t){return new e(t)},e.encode=function(t,n){return n||(n=p.create()),t.key!=null&&t.hasOwnProperty("key")&&n.uint32(10).string(t.key),t.value!=null&&t.hasOwnProperty("value")&&n.uint32(18).string(t.value),n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof l||(t=l.create(t));for(var r=n===void 0?t.len:t.pos+n,o=new i.onnx.StringStringEntryProto;t.pos<r;){var c=t.uint32();switch(c>>>3){case 1:o.key=t.string();break;case 2:o.value=t.string();break;default:t.skipType(7&c)}}return o},e.decodeDelimited=function(t){return t instanceof l||(t=new l(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.key!=null&&t.hasOwnProperty("key")&&!a.isString(t.key)?"key: string expected":t.value!=null&&t.hasOwnProperty("value")&&!a.isString(t.value)?"value: string expected":null},e.fromObject=function(t){if(t instanceof i.onnx.StringStringEntryProto)return t;var n=new i.onnx.StringStringEntryProto;return t.key!=null&&(n.key=String(t.key)),t.value!=null&&(n.value=String(t.value)),n},e.toObject=function(t,n){n||(n={});var r={};return n.defaults&&(r.key="",r.value=""),t.key!=null&&t.hasOwnProperty("key")&&(r.key=t.key),t.value!=null&&t.hasOwnProperty("value")&&(r.value=t.value),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e}(),f.TensorAnnotation=function(){function e(t){if(this.quantParameterTensorNames=[],t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}return e.prototype.tensorName="",e.prototype.quantParameterTensorNames=a.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=p.create()),t.tensorName!=null&&t.hasOwnProperty("tensorName")&&n.uint32(10).string(t.tensorName),t.quantParameterTensorNames!=null&&t.quantParameterTensorNames.length)for(var r=0;r<t.quantParameterTensorNames.length;++r)i.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[r],n.uint32(18).fork()).ldelim();return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof l||(t=l.create(t));for(var r=n===void 0?t.len:t.pos+n,o=new i.onnx.TensorAnnotation;t.pos<r;){var c=t.uint32();switch(c>>>3){case 1:o.tensorName=t.string();break;case 2:o.quantParameterTensorNames&&o.quantParameterTensorNames.length||(o.quantParameterTensorNames=[]),o.quantParameterTensorNames.push(i.onnx.StringStringEntryProto.decode(t,t.uint32()));break;default:t.skipType(7&c)}}return o},e.decodeDelimited=function(t){return t instanceof l||(t=new l(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.tensorName!=null&&t.hasOwnProperty("tensorName")&&!a.isString(t.tensorName))return"tensorName: string expected";if(t.quantParameterTensorNames!=null&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var n=0;n<t.quantParameterTensorNames.length;++n){var r=i.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[n]);if(r)return"quantParameterTensorNames."+r}}return null},e.fromObject=function(t){if(t instanceof i.onnx.TensorAnnotation)return t;var n=new i.onnx.TensorAnnotation;if(t.tensorName!=null&&(n.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");n.quantParameterTensorNames=[];for(var r=0;r<t.quantParameterTensorNames.length;++r){if(typeof t.quantParameterTensorNames[r]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");n.quantParameterTensorNames[r]=i.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[r])}}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.quantParameterTensorNames=[]),n.defaults&&(r.tensorName=""),t.tensorName!=null&&t.hasOwnProperty("tensorName")&&(r.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){r.quantParameterTensorNames=[];for(var o=0;o<t.quantParameterTensorNames.length;++o)r.quantParameterTensorNames[o]=i.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[o],n)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e}(),f.GraphProto=function(){function e(t){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}return e.prototype.node=a.emptyArray,e.prototype.name="",e.prototype.initializer=a.emptyArray,e.prototype.docString="",e.prototype.input=a.emptyArray,e.prototype.output=a.emptyArray,e.prototype.valueInfo=a.emptyArray,e.prototype.quantizationAnnotation=a.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=p.create()),t.node!=null&&t.node.length)for(var r=0;r<t.node.length;++r)i.onnx.NodeProto.encode(t.node[r],n.uint32(10).fork()).ldelim();if(t.name!=null&&t.hasOwnProperty("name")&&n.uint32(18).string(t.name),t.initializer!=null&&t.initializer.length)for(r=0;r<t.initializer.length;++r)i.onnx.TensorProto.encode(t.initializer[r],n.uint32(42).fork()).ldelim();if(t.docString!=null&&t.hasOwnProperty("docString")&&n.uint32(82).string(t.docString),t.input!=null&&t.input.length)for(r=0;r<t.input.length;++r)i.onnx.ValueInfoProto.encode(t.input[r],n.uint32(90).fork()).ldelim();if(t.output!=null&&t.output.length)for(r=0;r<t.output.length;++r)i.onnx.ValueInfoProto.encode(t.output[r],n.uint32(98).fork()).ldelim();if(t.valueInfo!=null&&t.valueInfo.length)for(r=0;r<t.valueInfo.length;++r)i.onnx.ValueInfoProto.encode(t.valueInfo[r],n.uint32(106).fork()).ldelim();if(t.quantizationAnnotation!=null&&t.quantizationAnnotation.length)for(r=0;r<t.quantizationAnnotation.length;++r)i.onnx.TensorAnnotation.encode(t.quantizationAnnotation[r],n.uint32(114).fork()).ldelim();return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof l||(t=l.create(t));for(var r=n===void 0?t.len:t.pos+n,o=new i.onnx.GraphProto;t.pos<r;){var c=t.uint32();switch(c>>>3){case 1:o.node&&o.node.length||(o.node=[]),o.node.push(i.onnx.NodeProto.decode(t,t.uint32()));break;case 2:o.name=t.string();break;case 5:o.initializer&&o.initializer.length||(o.initializer=[]),o.initializer.push(i.onnx.TensorProto.decode(t,t.uint32()));break;case 10:o.docString=t.string();break;case 11:o.input&&o.input.length||(o.input=[]),o.input.push(i.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 12:o.output&&o.output.length||(o.output=[]),o.output.push(i.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 13:o.valueInfo&&o.valueInfo.length||(o.valueInfo=[]),o.valueInfo.push(i.onnx.ValueInfoProto.decode(t,t.uint32()));break;case 14:o.quantizationAnnotation&&o.quantizationAnnotation.length||(o.quantizationAnnotation=[]),o.quantizationAnnotation.push(i.onnx.TensorAnnotation.decode(t,t.uint32()));break;default:t.skipType(7&c)}}return o},e.decodeDelimited=function(t){return t instanceof l||(t=new l(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var n=0;n<t.node.length;++n)if(r=i.onnx.NodeProto.verify(t.node[n]))return"node."+r}if(t.name!=null&&t.hasOwnProperty("name")&&!a.isString(t.name))return"name: string expected";if(t.initializer!=null&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(n=0;n<t.initializer.length;++n)if(r=i.onnx.TensorProto.verify(t.initializer[n]))return"initializer."+r}if(t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString))return"docString: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(n=0;n<t.input.length;++n)if(r=i.onnx.ValueInfoProto.verify(t.input[n]))return"input."+r}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(n=0;n<t.output.length;++n)if(r=i.onnx.ValueInfoProto.verify(t.output[n]))return"output."+r}if(t.valueInfo!=null&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(n=0;n<t.valueInfo.length;++n)if(r=i.onnx.ValueInfoProto.verify(t.valueInfo[n]))return"valueInfo."+r}if(t.quantizationAnnotation!=null&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(n=0;n<t.quantizationAnnotation.length;++n){var r;if(r=i.onnx.TensorAnnotation.verify(t.quantizationAnnotation[n]))return"quantizationAnnotation."+r}}return null},e.fromObject=function(t){if(t instanceof i.onnx.GraphProto)return t;var n=new i.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");n.node=[];for(var r=0;r<t.node.length;++r){if(typeof t.node[r]!="object")throw TypeError(".onnx.GraphProto.node: object expected");n.node[r]=i.onnx.NodeProto.fromObject(t.node[r])}}if(t.name!=null&&(n.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(n.initializer=[],r=0;r<t.initializer.length;++r){if(typeof t.initializer[r]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");n.initializer[r]=i.onnx.TensorProto.fromObject(t.initializer[r])}}if(t.docString!=null&&(n.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");for(n.input=[],r=0;r<t.input.length;++r){if(typeof t.input[r]!="object")throw TypeError(".onnx.GraphProto.input: object expected");n.input[r]=i.onnx.ValueInfoProto.fromObject(t.input[r])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");for(n.output=[],r=0;r<t.output.length;++r){if(typeof t.output[r]!="object")throw TypeError(".onnx.GraphProto.output: object expected");n.output[r]=i.onnx.ValueInfoProto.fromObject(t.output[r])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(n.valueInfo=[],r=0;r<t.valueInfo.length;++r){if(typeof t.valueInfo[r]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");n.valueInfo[r]=i.onnx.ValueInfoProto.fromObject(t.valueInfo[r])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(n.quantizationAnnotation=[],r=0;r<t.quantizationAnnotation.length;++r){if(typeof t.quantizationAnnotation[r]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");n.quantizationAnnotation[r]=i.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[r])}}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.node=[],r.initializer=[],r.input=[],r.output=[],r.valueInfo=[],r.quantizationAnnotation=[]),n.defaults&&(r.name="",r.docString=""),t.node&&t.node.length){r.node=[];for(var o=0;o<t.node.length;++o)r.node[o]=i.onnx.NodeProto.toObject(t.node[o],n)}if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.initializer&&t.initializer.length)for(r.initializer=[],o=0;o<t.initializer.length;++o)r.initializer[o]=i.onnx.TensorProto.toObject(t.initializer[o],n);if(t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.input&&t.input.length)for(r.input=[],o=0;o<t.input.length;++o)r.input[o]=i.onnx.ValueInfoProto.toObject(t.input[o],n);if(t.output&&t.output.length)for(r.output=[],o=0;o<t.output.length;++o)r.output[o]=i.onnx.ValueInfoProto.toObject(t.output[o],n);if(t.valueInfo&&t.valueInfo.length)for(r.valueInfo=[],o=0;o<t.valueInfo.length;++o)r.valueInfo[o]=i.onnx.ValueInfoProto.toObject(t.valueInfo[o],n);if(t.quantizationAnnotation&&t.quantizationAnnotation.length)for(r.quantizationAnnotation=[],o=0;o<t.quantizationAnnotation.length;++o)r.quantizationAnnotation[o]=i.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[o],n);return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e}(),f.TensorProto=function(){function e(t){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}return e.prototype.dims=a.emptyArray,e.prototype.dataType=0,e.prototype.segment=null,e.prototype.floatData=a.emptyArray,e.prototype.int32Data=a.emptyArray,e.prototype.stringData=a.emptyArray,e.prototype.int64Data=a.emptyArray,e.prototype.name="",e.prototype.docString="",e.prototype.rawData=a.newBuffer([]),e.prototype.externalData=a.emptyArray,e.prototype.dataLocation=0,e.prototype.doubleData=a.emptyArray,e.prototype.uint64Data=a.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=p.create()),t.dims!=null&&t.dims.length){n.uint32(10).fork();for(var r=0;r<t.dims.length;++r)n.int64(t.dims[r]);n.ldelim()}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&n.uint32(16).int32(t.dataType),t.segment!=null&&t.hasOwnProperty("segment")&&i.onnx.TensorProto.Segment.encode(t.segment,n.uint32(26).fork()).ldelim(),t.floatData!=null&&t.floatData.length){for(n.uint32(34).fork(),r=0;r<t.floatData.length;++r)n.float(t.floatData[r]);n.ldelim()}if(t.int32Data!=null&&t.int32Data.length){for(n.uint32(42).fork(),r=0;r<t.int32Data.length;++r)n.int32(t.int32Data[r]);n.ldelim()}if(t.stringData!=null&&t.stringData.length)for(r=0;r<t.stringData.length;++r)n.uint32(50).bytes(t.stringData[r]);if(t.int64Data!=null&&t.int64Data.length){for(n.uint32(58).fork(),r=0;r<t.int64Data.length;++r)n.int64(t.int64Data[r]);n.ldelim()}if(t.name!=null&&t.hasOwnProperty("name")&&n.uint32(66).string(t.name),t.rawData!=null&&t.hasOwnProperty("rawData")&&n.uint32(74).bytes(t.rawData),t.doubleData!=null&&t.doubleData.length){for(n.uint32(82).fork(),r=0;r<t.doubleData.length;++r)n.double(t.doubleData[r]);n.ldelim()}if(t.uint64Data!=null&&t.uint64Data.length){for(n.uint32(90).fork(),r=0;r<t.uint64Data.length;++r)n.uint64(t.uint64Data[r]);n.ldelim()}if(t.docString!=null&&t.hasOwnProperty("docString")&&n.uint32(98).string(t.docString),t.externalData!=null&&t.externalData.length)for(r=0;r<t.externalData.length;++r)i.onnx.StringStringEntryProto.encode(t.externalData[r],n.uint32(106).fork()).ldelim();return t.dataLocation!=null&&t.hasOwnProperty("dataLocation")&&n.uint32(112).int32(t.dataLocation),n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof l||(t=l.create(t));for(var r=n===void 0?t.len:t.pos+n,o=new i.onnx.TensorProto;t.pos<r;){var c=t.uint32();switch(c>>>3){case 1:if(o.dims&&o.dims.length||(o.dims=[]),(7&c)==2)for(var d=t.uint32()+t.pos;t.pos<d;)o.dims.push(t.int64());else o.dims.push(t.int64());break;case 2:o.dataType=t.int32();break;case 3:o.segment=i.onnx.TensorProto.Segment.decode(t,t.uint32());break;case 4:if(o.floatData&&o.floatData.length||(o.floatData=[]),(7&c)==2)for(d=t.uint32()+t.pos;t.pos<d;)o.floatData.push(t.float());else o.floatData.push(t.float());break;case 5:if(o.int32Data&&o.int32Data.length||(o.int32Data=[]),(7&c)==2)for(d=t.uint32()+t.pos;t.pos<d;)o.int32Data.push(t.int32());else o.int32Data.push(t.int32());break;case 6:o.stringData&&o.stringData.length||(o.stringData=[]),o.stringData.push(t.bytes());break;case 7:if(o.int64Data&&o.int64Data.length||(o.int64Data=[]),(7&c)==2)for(d=t.uint32()+t.pos;t.pos<d;)o.int64Data.push(t.int64());else o.int64Data.push(t.int64());break;case 8:o.name=t.string();break;case 12:o.docString=t.string();break;case 9:o.rawData=t.bytes();break;case 13:o.externalData&&o.externalData.length||(o.externalData=[]),o.externalData.push(i.onnx.StringStringEntryProto.decode(t,t.uint32()));break;case 14:o.dataLocation=t.int32();break;case 10:if(o.doubleData&&o.doubleData.length||(o.doubleData=[]),(7&c)==2)for(d=t.uint32()+t.pos;t.pos<d;)o.doubleData.push(t.double());else o.doubleData.push(t.double());break;case 11:if(o.uint64Data&&o.uint64Data.length||(o.uint64Data=[]),(7&c)==2)for(d=t.uint32()+t.pos;t.pos<d;)o.uint64Data.push(t.uint64());else o.uint64Data.push(t.uint64());break;default:t.skipType(7&c)}}return o},e.decodeDelimited=function(t){return t instanceof l||(t=new l(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var n=0;n<t.dims.length;++n)if(!(a.isInteger(t.dims[n])||t.dims[n]&&a.isInteger(t.dims[n].low)&&a.isInteger(t.dims[n].high)))return"dims: integer|Long[] expected"}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&!a.isInteger(t.dataType))return"dataType: integer expected";if(t.segment!=null&&t.hasOwnProperty("segment")&&(r=i.onnx.TensorProto.Segment.verify(t.segment)))return"segment."+r;if(t.floatData!=null&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(n=0;n<t.floatData.length;++n)if(typeof t.floatData[n]!="number")return"floatData: number[] expected"}if(t.int32Data!=null&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(n=0;n<t.int32Data.length;++n)if(!a.isInteger(t.int32Data[n]))return"int32Data: integer[] expected"}if(t.stringData!=null&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(n=0;n<t.stringData.length;++n)if(!(t.stringData[n]&&typeof t.stringData[n].length=="number"||a.isString(t.stringData[n])))return"stringData: buffer[] expected"}if(t.int64Data!=null&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(n=0;n<t.int64Data.length;++n)if(!(a.isInteger(t.int64Data[n])||t.int64Data[n]&&a.isInteger(t.int64Data[n].low)&&a.isInteger(t.int64Data[n].high)))return"int64Data: integer|Long[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!a.isString(t.name))return"name: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!a.isString(t.docString))return"docString: string expected";if(t.rawData!=null&&t.hasOwnProperty("rawData")&&!(t.rawData&&typeof t.rawData.length=="number"||a.isString(t.rawData)))return"rawData: buffer expected";if(t.externalData!=null&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(n=0;n<t.externalData.length;++n){var r;if(r=i.onnx.StringStringEntryProto.verify(t.externalData[n]))return"externalData."+r}}if(t.dataLocation!=null&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(t.doubleData!=null&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(n=0;n<t.doubleData.length;++n)if(typeof t.doubleData[n]!="number")return"doubleData: number[] expected"}if(t.uint64Data!=null&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(n=0;n<t.uint64Data.length;++n)if(!(a.isInteger(t.uint64Data[n])||t.uint64Data[n]&&a.isInteger(t.uint64Data[n].low)&&a.isInteger(t.uint64Data[n].high)))return"uint64Data: integer|Long[] expected"}return null},e.fromObject=function(t){if(t instanceof i.onnx.TensorProto)return t;var n=new i.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");n.dims=[];for(var r=0;r<t.dims.length;++r)a.Long?(n.dims[r]=a.Long.fromValue(t.dims[r])).unsigned=!1:typeof t.dims[r]=="string"?n.dims[r]=parseInt(t.dims[r],10):typeof t.dims[r]=="number"?n.dims[r]=t.dims[r]:typeof t.dims[r]=="object"&&(n.dims[r]=new a.LongBits(t.dims[r].low>>>0,t.dims[r].high>>>0).toNumber())}if(t.dataType!=null&&(n.dataType=0|t.dataType),t.segment!=null){if(typeof t.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");n.segment=i.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(n.floatData=[],r=0;r<t.floatData.length;++r)n.floatData[r]=Number(t.floatData[r])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(n.int32Data=[],r=0;r<t.int32Data.length;++r)n.int32Data[r]=0|t.int32Data[r]}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(n.stringData=[],r=0;r<t.stringData.length;++r)typeof t.stringData[r]=="string"?a.base64.decode(t.stringData[r],n.stringData[r]=a.newBuffer(a.base64.length(t.stringData[r])),0):t.stringData[r].length&&(n.stringData[r]=t.stringData[r])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(n.int64Data=[],r=0;r<t.int64Data.length;++r)a.Long?(n.int64Data[r]=a.Long.fromValue(t.int64Data[r])).unsigned=!1:typeof t.int64Data[r]=="string"?n.int64Data[r]=parseInt(t.int64Data[r],10):typeof t.int64Data[r]=="number"?n.int64Data[r]=t.int64Data[r]:typeof t.int64Data[r]=="object"&&(n.int64Data[r]=new a.LongBits(t.int64Data[r].low>>>0,t.int64Data[r].high>>>0).toNumber())}if(t.name!=null&&(n.name=String(t.name)),t.docString!=null&&(n.docString=String(t.docString)),t.rawData!=null&&(typeof t.rawData=="string"?a.base64.decode(t.rawData,n.rawData=a.newBuffer(a.base64.length(t.rawData)),0):t.rawData.length&&(n.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(n.externalData=[],r=0;r<t.externalData.length;++r){if(typeof t.externalData[r]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");n.externalData[r]=i.onnx.StringStringEntryProto.fromObject(t.externalData[r])}}switch(t.dataLocation){case"DEFAULT":case 0:n.dataLocation=0;break;case"EXTERNAL":case 1:n.dataLocation=1}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(n.doubleData=[],r=0;r<t.doubleData.length;++r)n.doubleData[r]=Number(t.doubleData[r])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(n.uint64Data=[],r=0;r<t.uint64Data.length;++r)a.Long?(n.uint64Data[r]=a.Long.fromValue(t.uint64Data[r])).unsigned=!0:typeof t.uint64Data[r]=="string"?n.uint64Data[r]=parseInt(t.uint64Data[r],10):typeof t.uint64Data[r]=="number"?n.uint64Data[r]=t.uint64Data[r]:typeof t.uint64Data[r]=="object"&&(n.uint64Data[r]=new a.LongBits(t.uint64Data[r].low>>>0,t.uint64Data[r].high>>>0).toNumber(!0))}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.dims=[],r.floatData=[],r.int32Data=[],r.stringData=[],r.int64Data=[],r.doubleData=[],r.uint64Data=[],r.externalData=[]),n.defaults&&(r.dataType=0,r.segment=null,r.name="",n.bytes===String?r.rawData="":(r.rawData=[],n.bytes!==Array&&(r.rawData=a.newBuffer(r.rawData))),r.docString="",r.dataLocation=n.enums===String?"DEFAULT":0),t.dims&&t.dims.length){r.dims=[];for(var o=0;o<t.dims.length;++o)typeof t.dims[o]=="number"?r.dims[o]=n.longs===String?String(t.dims[o]):t.dims[o]:r.dims[o]=n.longs===String?a.Long.prototype.toString.call(t.dims[o]):n.longs===Number?new a.LongBits(t.dims[o].low>>>0,t.dims[o].high>>>0).toNumber():t.dims[o]}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&(r.dataType=t.dataType),t.segment!=null&&t.hasOwnProperty("segment")&&(r.segment=i.onnx.TensorProto.Segment.toObject(t.segment,n)),t.floatData&&t.floatData.length)for(r.floatData=[],o=0;o<t.floatData.length;++o)r.floatData[o]=n.json&&!isFinite(t.floatData[o])?String(t.floatData[o]):t.floatData[o];if(t.int32Data&&t.int32Data.length)for(r.int32Data=[],o=0;o<t.int32Data.length;++o)r.int32Data[o]=t.int32Data[o];if(t.stringData&&t.stringData.length)for(r.stringData=[],o=0;o<t.stringData.length;++o)r.stringData[o]=n.bytes===String?a.base64.encode(t.stringData[o],0,t.stringData[o].length):n.bytes===Array?Array.prototype.slice.call(t.stringData[o]):t.stringData[o];if(t.int64Data&&t.int64Data.length)for(r.int64Data=[],o=0;o<t.int64Data.length;++o)typeof t.int64Data[o]=="number"?r.int64Data[o]=n.longs===String?String(t.int64Data[o]):t.int64Data[o]:r.int64Data[o]=n.longs===String?a.Long.prototype.toString.call(t.int64Data[o]):n.longs===Number?new a.LongBits(t.int64Data[o].low>>>0,t.int64Data[o].high>>>0).toNumber():t.int64Data[o];if(t.name!=null&&t.hasOwnProperty("name")&&(r.name=t.name),t.rawData!=null&&t.hasOwnProperty("rawData")&&(r.rawData=n.bytes===String?a.base64.encode(t.rawData,0,t.rawData.length):n.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length)for(r.doubleData=[],o=0;o<t.doubleData.length;++o)r.doubleData[o]=n.json&&!isFinite(t.doubleData[o])?String(t.doubleData[o]):t.doubleData[o];if(t.uint64Data&&t.uint64Data.length)for(r.uint64Data=[],o=0;o<t.uint64Data.length;++o)typeof t.uint64Data[o]=="number"?r.uint64Data[o]=n.longs===String?String(t.uint64Data[o]):t.uint64Data[o]:r.uint64Data[o]=n.longs===String?a.Long.prototype.toString.call(t.uint64Data[o]):n.longs===Number?new a.LongBits(t.uint64Data[o].low>>>0,t.uint64Data[o].high>>>0).toNumber(!0):t.uint64Data[o];if(t.docString!=null&&t.hasOwnProperty("docString")&&(r.docString=t.docString),t.externalData&&t.externalData.length)for(r.externalData=[],o=0;o<t.externalData.length;++o)r.externalData[o]=i.onnx.StringStringEntryProto.toObject(t.externalData[o],n);return t.dataLocation!=null&&t.hasOwnProperty("dataLocation")&&(r.dataLocation=n.enums===String?i.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e.DataType=function(){var t={},n=Object.create(t);return n[t[0]="UNDEFINED"]=0,n[t[1]="FLOAT"]=1,n[t[2]="UINT8"]=2,n[t[3]="INT8"]=3,n[t[4]="UINT16"]=4,n[t[5]="INT16"]=5,n[t[6]="INT32"]=6,n[t[7]="INT64"]=7,n[t[8]="STRING"]=8,n[t[9]="BOOL"]=9,n[t[10]="FLOAT16"]=10,n[t[11]="DOUBLE"]=11,n[t[12]="UINT32"]=12,n[t[13]="UINT64"]=13,n[t[14]="COMPLEX64"]=14,n[t[15]="COMPLEX128"]=15,n[t[16]="BFLOAT16"]=16,n}(),e.Segment=function(){function t(n){if(n)for(var r=Object.keys(n),o=0;o<r.length;++o)n[r[o]]!=null&&(this[r[o]]=n[r[o]])}return t.prototype.begin=a.Long?a.Long.fromBits(0,0,!1):0,t.prototype.end=a.Long?a.Long.fromBits(0,0,!1):0,t.create=function(n){return new t(n)},t.encode=function(n,r){return r||(r=p.create()),n.begin!=null&&n.hasOwnProperty("begin")&&r.uint32(8).int64(n.begin),n.end!=null&&n.hasOwnProperty("end")&&r.uint32(16).int64(n.end),r},t.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},t.decode=function(n,r){n instanceof l||(n=l.create(n));for(var o=r===void 0?n.len:n.pos+r,c=new i.onnx.TensorProto.Segment;n.pos<o;){var d=n.uint32();switch(d>>>3){case 1:c.begin=n.int64();break;case 2:c.end=n.int64();break;default:n.skipType(7&d)}}return c},t.decodeDelimited=function(n){return n instanceof l||(n=new l(n)),this.decode(n,n.uint32())},t.verify=function(n){return typeof n!="object"||n===null?"object expected":n.begin!=null&&n.hasOwnProperty("begin")&&!(a.isInteger(n.begin)||n.begin&&a.isInteger(n.begin.low)&&a.isInteger(n.begin.high))?"begin: integer|Long expected":n.end!=null&&n.hasOwnProperty("end")&&!(a.isInteger(n.end)||n.end&&a.isInteger(n.end.low)&&a.isInteger(n.end.high))?"end: integer|Long expected":null},t.fromObject=function(n){if(n instanceof i.onnx.TensorProto.Segment)return n;var r=new i.onnx.TensorProto.Segment;return n.begin!=null&&(a.Long?(r.begin=a.Long.fromValue(n.begin)).unsigned=!1:typeof n.begin=="string"?r.begin=parseInt(n.begin,10):typeof n.begin=="number"?r.begin=n.begin:typeof n.begin=="object"&&(r.begin=new a.LongBits(n.begin.low>>>0,n.begin.high>>>0).toNumber())),n.end!=null&&(a.Long?(r.end=a.Long.fromValue(n.end)).unsigned=!1:typeof n.end=="string"?r.end=parseInt(n.end,10):typeof n.end=="number"?r.end=n.end:typeof n.end=="object"&&(r.end=new a.LongBits(n.end.low>>>0,n.end.high>>>0).toNumber())),r},t.toObject=function(n,r){r||(r={});var o={};if(r.defaults){if(a.Long){var c=new a.Long(0,0,!1);o.begin=r.longs===String?c.toString():r.longs===Number?c.toNumber():c}else o.begin=r.longs===String?"0":0;a.Long?(c=new a.Long(0,0,!1),o.end=r.longs===String?c.toString():r.longs===Number?c.toNumber():c):o.end=r.longs===String?"0":0}return n.begin!=null&&n.hasOwnProperty("begin")&&(typeof n.begin=="number"?o.begin=r.longs===String?String(n.begin):n.begin:o.begin=r.longs===String?a.Long.prototype.toString.call(n.begin):r.longs===Number?new a.LongBits(n.begin.low>>>0,n.begin.high>>>0).toNumber():n.begin),n.end!=null&&n.hasOwnProperty("end")&&(typeof n.end=="number"?o.end=r.longs===String?String(n.end):n.end:o.end=r.longs===String?a.Long.prototype.toString.call(n.end):r.longs===Number?new a.LongBits(n.end.low>>>0,n.end.high>>>0).toNumber():n.end),o},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t}(),e.DataLocation=function(){var t={},n=Object.create(t);return n[t[0]="DEFAULT"]=0,n[t[1]="EXTERNAL"]=1,n}(),e}(),f.TensorShapeProto=function(){function e(t){if(this.dim=[],t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}return e.prototype.dim=a.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,n){if(n||(n=p.create()),t.dim!=null&&t.dim.length)for(var r=0;r<t.dim.length;++r)i.onnx.TensorShapeProto.Dimension.encode(t.dim[r],n.uint32(10).fork()).ldelim();return n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof l||(t=l.create(t));for(var r=n===void 0?t.len:t.pos+n,o=new i.onnx.TensorShapeProto;t.pos<r;){var c=t.uint32();c>>>3==1?(o.dim&&o.dim.length||(o.dim=[]),o.dim.push(i.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()))):t.skipType(7&c)}return o},e.decodeDelimited=function(t){return t instanceof l||(t=new l(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dim!=null&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var n=0;n<t.dim.length;++n){var r=i.onnx.TensorShapeProto.Dimension.verify(t.dim[n]);if(r)return"dim."+r}}return null},e.fromObject=function(t){if(t instanceof i.onnx.TensorShapeProto)return t;var n=new i.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");n.dim=[];for(var r=0;r<t.dim.length;++r){if(typeof t.dim[r]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");n.dim[r]=i.onnx.TensorShapeProto.Dimension.fromObject(t.dim[r])}}return n},e.toObject=function(t,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.dim=[]),t.dim&&t.dim.length){r.dim=[];for(var o=0;o<t.dim.length;++o)r.dim[o]=i.onnx.TensorShapeProto.Dimension.toObject(t.dim[o],n)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e.Dimension=function(){function t(r){if(r)for(var o=Object.keys(r),c=0;c<o.length;++c)r[o[c]]!=null&&(this[o[c]]=r[o[c]])}var n;return t.prototype.dimValue=a.Long?a.Long.fromBits(0,0,!1):0,t.prototype.dimParam="",t.prototype.denotation="",Object.defineProperty(t.prototype,"value",{get:a.oneOfGetter(n=["dimValue","dimParam"]),set:a.oneOfSetter(n)}),t.create=function(r){return new t(r)},t.encode=function(r,o){return o||(o=p.create()),r.dimValue!=null&&r.hasOwnProperty("dimValue")&&o.uint32(8).int64(r.dimValue),r.dimParam!=null&&r.hasOwnProperty("dimParam")&&o.uint32(18).string(r.dimParam),r.denotation!=null&&r.hasOwnProperty("denotation")&&o.uint32(26).string(r.denotation),o},t.encodeDelimited=function(r,o){return this.encode(r,o).ldelim()},t.decode=function(r,o){r instanceof l||(r=l.create(r));for(var c=o===void 0?r.len:r.pos+o,d=new i.onnx.TensorShapeProto.Dimension;r.pos<c;){var g=r.uint32();switch(g>>>3){case 1:d.dimValue=r.int64();break;case 2:d.dimParam=r.string();break;case 3:d.denotation=r.string();break;default:r.skipType(7&g)}}return d},t.decodeDelimited=function(r){return r instanceof l||(r=new l(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";var o={};if(r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(o.value=1,!(a.isInteger(r.dimValue)||r.dimValue&&a.isInteger(r.dimValue.low)&&a.isInteger(r.dimValue.high))))return"dimValue: integer|Long expected";if(r.dimParam!=null&&r.hasOwnProperty("dimParam")){if(o.value===1)return"value: multiple values";if(o.value=1,!a.isString(r.dimParam))return"dimParam: string expected"}return r.denotation!=null&&r.hasOwnProperty("denotation")&&!a.isString(r.denotation)?"denotation: string expected":null},t.fromObject=function(r){if(r instanceof i.onnx.TensorShapeProto.Dimension)return r;var o=new i.onnx.TensorShapeProto.Dimension;return r.dimValue!=null&&(a.Long?(o.dimValue=a.Long.fromValue(r.dimValue)).unsigned=!1:typeof r.dimValue=="string"?o.dimValue=parseInt(r.dimValue,10):typeof r.dimValue=="number"?o.dimValue=r.dimValue:typeof r.dimValue=="object"&&(o.dimValue=new a.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber())),r.dimParam!=null&&(o.dimParam=String(r.dimParam)),r.denotation!=null&&(o.denotation=String(r.denotation)),o},t.toObject=function(r,o){o||(o={});var c={};return o.defaults&&(c.denotation=""),r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(typeof r.dimValue=="number"?c.dimValue=o.longs===String?String(r.dimValue):r.dimValue:c.dimValue=o.longs===String?a.Long.prototype.toString.call(r.dimValue):o.longs===Number?new a.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber():r.dimValue,o.oneofs&&(c.value="dimValue")),r.dimParam!=null&&r.hasOwnProperty("dimParam")&&(c.dimParam=r.dimParam,o.oneofs&&(c.value="dimParam")),r.denotation!=null&&r.hasOwnProperty("denotation")&&(c.denotation=r.denotation),c},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t}(),e}(),f.TypeProto=function(){function e(n){if(n)for(var r=Object.keys(n),o=0;o<r.length;++o)n[r[o]]!=null&&(this[r[o]]=n[r[o]])}var t;return e.prototype.tensorType=null,e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:a.oneOfGetter(t=["tensorType"]),set:a.oneOfSetter(t)}),e.create=function(n){return new e(n)},e.encode=function(n,r){return r||(r=p.create()),n.tensorType!=null&&n.hasOwnProperty("tensorType")&&i.onnx.TypeProto.Tensor.encode(n.tensorType,r.uint32(10).fork()).ldelim(),n.denotation!=null&&n.hasOwnProperty("denotation")&&r.uint32(50).string(n.denotation),r},e.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},e.decode=function(n,r){n instanceof l||(n=l.create(n));for(var o=r===void 0?n.len:n.pos+r,c=new i.onnx.TypeProto;n.pos<o;){var d=n.uint32();switch(d>>>3){case 1:c.tensorType=i.onnx.TypeProto.Tensor.decode(n,n.uint32());break;case 6:c.denotation=n.string();break;default:n.skipType(7&d)}}return c},e.decodeDelimited=function(n){return n instanceof l||(n=new l(n)),this.decode(n,n.uint32())},e.verify=function(n){if(typeof n!="object"||n===null)return"object expected";if(n.tensorType!=null&&n.hasOwnProperty("tensorType")){var r=i.onnx.TypeProto.Tensor.verify(n.tensorType);if(r)return"tensorType."+r}return n.denotation!=null&&n.hasOwnProperty("denotation")&&!a.isString(n.denotation)?"denotation: string expected":null},e.fromObject=function(n){if(n instanceof i.onnx.TypeProto)return n;var r=new i.onnx.TypeProto;if(n.tensorType!=null){if(typeof n.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");r.tensorType=i.onnx.TypeProto.Tensor.fromObject(n.tensorType)}return n.denotation!=null&&(r.denotation=String(n.denotation)),r},e.toObject=function(n,r){r||(r={});var o={};return r.defaults&&(o.denotation=""),n.tensorType!=null&&n.hasOwnProperty("tensorType")&&(o.tensorType=i.onnx.TypeProto.Tensor.toObject(n.tensorType,r),r.oneofs&&(o.value="tensorType")),n.denotation!=null&&n.hasOwnProperty("denotation")&&(o.denotation=n.denotation),o},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e.Tensor=function(){function n(r){if(r)for(var o=Object.keys(r),c=0;c<o.length;++c)r[o[c]]!=null&&(this[o[c]]=r[o[c]])}return n.prototype.elemType=0,n.prototype.shape=null,n.create=function(r){return new n(r)},n.encode=function(r,o){return o||(o=p.create()),r.elemType!=null&&r.hasOwnProperty("elemType")&&o.uint32(8).int32(r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&i.onnx.TensorShapeProto.encode(r.shape,o.uint32(18).fork()).ldelim(),o},n.encodeDelimited=function(r,o){return this.encode(r,o).ldelim()},n.decode=function(r,o){r instanceof l||(r=l.create(r));for(var c=o===void 0?r.len:r.pos+o,d=new i.onnx.TypeProto.Tensor;r.pos<c;){var g=r.uint32();switch(g>>>3){case 1:d.elemType=r.int32();break;case 2:d.shape=i.onnx.TensorShapeProto.decode(r,r.uint32());break;default:r.skipType(7&g)}}return d},n.decodeDelimited=function(r){return r instanceof l||(r=new l(r)),this.decode(r,r.uint32())},n.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")&&!a.isInteger(r.elemType))return"elemType: integer expected";if(r.shape!=null&&r.hasOwnProperty("shape")){var o=i.onnx.TensorShapeProto.verify(r.shape);if(o)return"shape."+o}return null},n.fromObject=function(r){if(r instanceof i.onnx.TypeProto.Tensor)return r;var o=new i.onnx.TypeProto.Tensor;if(r.elemType!=null&&(o.elemType=0|r.elemType),r.shape!=null){if(typeof r.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");o.shape=i.onnx.TensorShapeProto.fromObject(r.shape)}return o},n.toObject=function(r,o){o||(o={});var c={};return o.defaults&&(c.elemType=0,c.shape=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(c.elemType=r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&(c.shape=i.onnx.TensorShapeProto.toObject(r.shape,o)),c},n.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},n}(),e}(),f.OperatorSetIdProto=function(){function e(t){if(t)for(var n=Object.keys(t),r=0;r<n.length;++r)t[n[r]]!=null&&(this[n[r]]=t[n[r]])}return e.prototype.domain="",e.prototype.version=a.Long?a.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(t,n){return n||(n=p.create()),t.domain!=null&&t.hasOwnProperty("domain")&&n.uint32(10).string(t.domain),t.version!=null&&t.hasOwnProperty("version")&&n.uint32(16).int64(t.version),n},e.encodeDelimited=function(t,n){return this.encode(t,n).ldelim()},e.decode=function(t,n){t instanceof l||(t=l.create(t));for(var r=n===void 0?t.len:t.pos+n,o=new i.onnx.OperatorSetIdProto;t.pos<r;){var c=t.uint32();switch(c>>>3){case 1:o.domain=t.string();break;case 2:o.version=t.int64();break;default:t.skipType(7&c)}}return o},e.decodeDelimited=function(t){return t instanceof l||(t=new l(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.domain!=null&&t.hasOwnProperty("domain")&&!a.isString(t.domain)?"domain: string expected":t.version!=null&&t.hasOwnProperty("version")&&!(a.isInteger(t.version)||t.version&&a.isInteger(t.version.low)&&a.isInteger(t.version.high))?"version: integer|Long expected":null},e.fromObject=function(t){if(t instanceof i.onnx.OperatorSetIdProto)return t;var n=new i.onnx.OperatorSetIdProto;return t.domain!=null&&(n.domain=String(t.domain)),t.version!=null&&(a.Long?(n.version=a.Long.fromValue(t.version)).unsigned=!1:typeof t.version=="string"?n.version=parseInt(t.version,10):typeof t.version=="number"?n.version=t.version:typeof t.version=="object"&&(n.version=new a.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),n},e.toObject=function(t,n){n||(n={});var r={};if(n.defaults)if(r.domain="",a.Long){var o=new a.Long(0,0,!1);r.version=n.longs===String?o.toString():n.longs===Number?o.toNumber():o}else r.version=n.longs===String?"0":0;return t.domain!=null&&t.hasOwnProperty("domain")&&(r.domain=t.domain),t.version!=null&&t.hasOwnProperty("version")&&(typeof t.version=="number"?r.version=n.longs===String?String(t.version):t.version:r.version=n.longs===String?a.Long.prototype.toString.call(t.version):n.longs===Number?new a.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e}(),f),R.exports=i},2100:(R,u,y)=>{R.exports=y(9482)},9482:(R,u,y)=>{var m=u;function h(){m.util._configure(),m.Writer._configure(m.BufferWriter),m.Reader._configure(m.BufferReader)}m.build="minimal",m.Writer=y(1173),m.BufferWriter=y(3155),m.Reader=y(1408),m.BufferReader=y(593),m.util=y(9693),m.rpc=y(5994),m.roots=y(5054),m.configure=h,h()},1408:(R,u,y)=>{R.exports=p;var m,h=y(9693),f=h.LongBits,s=h.utf8;function l(o,c){return RangeError("index out of range: "+o.pos+" + "+(c||1)+" > "+o.len)}function p(o){this.buf=o,this.pos=0,this.len=o.length}var a,i=typeof Uint8Array<"u"?function(o){if(o instanceof Uint8Array||Array.isArray(o))return new p(o);throw Error("illegal buffer")}:function(o){if(Array.isArray(o))return new p(o);throw Error("illegal buffer")},e=function(){return h.Buffer?function(o){return(p.create=function(c){return h.Buffer.isBuffer(c)?new m(c):i(c)})(o)}:i};function t(){var o=new f(0,0),c=0;if(!(this.len-this.pos>4)){for(;c<3;++c){if(this.pos>=this.len)throw l(this);if(o.lo=(o.lo|(127&this.buf[this.pos])<<7*c)>>>0,this.buf[this.pos++]<128)return o}return o.lo=(o.lo|(127&this.buf[this.pos++])<<7*c)>>>0,o}for(;c<4;++c)if(o.lo=(o.lo|(127&this.buf[this.pos])<<7*c)>>>0,this.buf[this.pos++]<128)return o;if(o.lo=(o.lo|(127&this.buf[this.pos])<<28)>>>0,o.hi=(o.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return o;if(c=0,this.len-this.pos>4){for(;c<5;++c)if(o.hi=(o.hi|(127&this.buf[this.pos])<<7*c+3)>>>0,this.buf[this.pos++]<128)return o}else for(;c<5;++c){if(this.pos>=this.len)throw l(this);if(o.hi=(o.hi|(127&this.buf[this.pos])<<7*c+3)>>>0,this.buf[this.pos++]<128)return o}throw Error("invalid varint encoding")}function n(o,c){return(o[c-4]|o[c-3]<<8|o[c-2]<<16|o[c-1]<<24)>>>0}function r(){if(this.pos+8>this.len)throw l(this,8);return new f(n(this.buf,this.pos+=4),n(this.buf,this.pos+=4))}p.create=e(),p.prototype._slice=h.Array.prototype.subarray||h.Array.prototype.slice,p.prototype.uint32=(a=4294967295,function(){if(a=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(a=(a|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(a=(a|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(a=(a|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(a=(a|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return a;if((this.pos+=5)>this.len)throw this.pos=this.len,l(this,10);return a}),p.prototype.int32=function(){return 0|this.uint32()},p.prototype.sint32=function(){var o=this.uint32();return o>>>1^-(1&o)|0},p.prototype.bool=function(){return this.uint32()!==0},p.prototype.fixed32=function(){if(this.pos+4>this.len)throw l(this,4);return n(this.buf,this.pos+=4)},p.prototype.sfixed32=function(){if(this.pos+4>this.len)throw l(this,4);return 0|n(this.buf,this.pos+=4)},p.prototype.float=function(){if(this.pos+4>this.len)throw l(this,4);var o=h.float.readFloatLE(this.buf,this.pos);return this.pos+=4,o},p.prototype.double=function(){if(this.pos+8>this.len)throw l(this,4);var o=h.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,o},p.prototype.bytes=function(){var o=this.uint32(),c=this.pos,d=this.pos+o;if(d>this.len)throw l(this,o);return this.pos+=o,Array.isArray(this.buf)?this.buf.slice(c,d):c===d?new this.buf.constructor(0):this._slice.call(this.buf,c,d)},p.prototype.string=function(){var o=this.bytes();return s.read(o,0,o.length)},p.prototype.skip=function(o){if(typeof o=="number"){if(this.pos+o>this.len)throw l(this,o);this.pos+=o}else do if(this.pos>=this.len)throw l(this);while(128&this.buf[this.pos++]);return this},p.prototype.skipType=function(o){switch(o){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(o=7&this.uint32())!=4;)this.skipType(o);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+o+" at offset "+this.pos)}return this},p._configure=function(o){m=o,p.create=e(),m._configure();var c=h.Long?"toLong":"toNumber";h.merge(p.prototype,{int64:function(){return t.call(this)[c](!1)},uint64:function(){return t.call(this)[c](!0)},sint64:function(){return t.call(this).zzDecode()[c](!1)},fixed64:function(){return r.call(this)[c](!0)},sfixed64:function(){return r.call(this)[c](!1)}})}},593:(R,u,y)=>{R.exports=f;var m=y(1408);(f.prototype=Object.create(m.prototype)).constructor=f;var h=y(9693);function f(s){m.call(this,s)}f._configure=function(){h.Buffer&&(f.prototype._slice=h.Buffer.prototype.slice)},f.prototype.string=function(){var s=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+s,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+s,this.len))},f._configure()},5054:R=>{R.exports={}},5994:(R,u,y)=>{u.Service=y(7948)},7948:(R,u,y)=>{R.exports=h;var m=y(9693);function h(f,s,l){if(typeof f!="function")throw TypeError("rpcImpl must be a function");m.EventEmitter.call(this),this.rpcImpl=f,this.requestDelimited=!!s,this.responseDelimited=!!l}(h.prototype=Object.create(m.EventEmitter.prototype)).constructor=h,h.prototype.rpcCall=function f(s,l,p,a,i){if(!a)throw TypeError("request must be specified");var e=this;if(!i)return m.asPromise(f,e,s,l,p,a);if(e.rpcImpl)try{return e.rpcImpl(s,l[e.requestDelimited?"encodeDelimited":"encode"](a).finish(),function(t,n){if(t)return e.emit("error",t,s),i(t);if(n!==null){if(!(n instanceof p))try{n=p[e.responseDelimited?"decodeDelimited":"decode"](n)}catch(r){return e.emit("error",r,s),i(r)}return e.emit("data",n,s),i(null,n)}e.end(!0)})}catch(t){return e.emit("error",t,s),void setTimeout(function(){i(t)},0)}else setTimeout(function(){i(Error("already ended"))},0)},h.prototype.end=function(f){return this.rpcImpl&&(f||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(R,u,y)=>{R.exports=h;var m=y(9693);function h(p,a){this.lo=p>>>0,this.hi=a>>>0}var f=h.zero=new h(0,0);f.toNumber=function(){return 0},f.zzEncode=f.zzDecode=function(){return this},f.length=function(){return 1};var s=h.zeroHash="\0\0\0\0\0\0\0\0";h.fromNumber=function(p){if(p===0)return f;var a=p<0;a&&(p=-p);var i=p>>>0,e=(p-i)/4294967296>>>0;return a&&(e=~e>>>0,i=~i>>>0,++i>4294967295&&(i=0,++e>4294967295&&(e=0))),new h(i,e)},h.from=function(p){if(typeof p=="number")return h.fromNumber(p);if(m.isString(p)){if(!m.Long)return h.fromNumber(parseInt(p,10));p=m.Long.fromString(p)}return p.low||p.high?new h(p.low>>>0,p.high>>>0):f},h.prototype.toNumber=function(p){if(!p&&this.hi>>>31){var a=1+~this.lo>>>0,i=~this.hi>>>0;return a||(i=i+1>>>0),-(a+4294967296*i)}return this.lo+4294967296*this.hi},h.prototype.toLong=function(p){return m.Long?new m.Long(0|this.lo,0|this.hi,!!p):{low:0|this.lo,high:0|this.hi,unsigned:!!p}};var l=String.prototype.charCodeAt;h.fromHash=function(p){return p===s?f:new h((l.call(p,0)|l.call(p,1)<<8|l.call(p,2)<<16|l.call(p,3)<<24)>>>0,(l.call(p,4)|l.call(p,5)<<8|l.call(p,6)<<16|l.call(p,7)<<24)>>>0)},h.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},h.prototype.zzEncode=function(){var p=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^p)>>>0,this.lo=(this.lo<<1^p)>>>0,this},h.prototype.zzDecode=function(){var p=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^p)>>>0,this.hi=(this.hi>>>1^p)>>>0,this},h.prototype.length=function(){var p=this.lo,a=(this.lo>>>28|this.hi<<4)>>>0,i=this.hi>>>24;return i===0?a===0?p<16384?p<128?1:2:p<2097152?3:4:a<16384?a<128?5:6:a<2097152?7:8:i<128?9:10}},9693:function(R,u,y){var m=u;function h(s,l,p){for(var a=Object.keys(l),i=0;i<a.length;++i)s[a[i]]!==void 0&&p||(s[a[i]]=l[a[i]]);return s}function f(s){function l(p,a){if(!(this instanceof l))return new l(p,a);Object.defineProperty(this,"message",{get:function(){return p}}),Error.captureStackTrace?Error.captureStackTrace(this,l):Object.defineProperty(this,"stack",{value:new Error().stack||""}),a&&h(this,a)}return(l.prototype=Object.create(Error.prototype)).constructor=l,Object.defineProperty(l.prototype,"name",{get:function(){return s}}),l.prototype.toString=function(){return this.name+": "+this.message},l}m.asPromise=y(4537),m.base64=y(7419),m.EventEmitter=y(9211),m.float=y(945),m.inquire=y(7199),m.utf8=y(4997),m.pool=y(6662),m.LongBits=y(1945),m.isNode=!!(y.g!==void 0&&y.g&&y.g.process&&y.g.process.versions&&y.g.process.versions.node),m.global=m.isNode&&y.g||typeof window<"u"&&window||typeof self<"u"&&self||this,m.emptyArray=Object.freeze?Object.freeze([]):[],m.emptyObject=Object.freeze?Object.freeze({}):{},m.isInteger=Number.isInteger||function(s){return typeof s=="number"&&isFinite(s)&&Math.floor(s)===s},m.isString=function(s){return typeof s=="string"||s instanceof String},m.isObject=function(s){return s&&typeof s=="object"},m.isset=m.isSet=function(s,l){var p=s[l];return!(p==null||!s.hasOwnProperty(l))&&(typeof p!="object"||(Array.isArray(p)?p.length:Object.keys(p).length)>0)},m.Buffer=function(){try{var s=m.inquire("buffer").Buffer;return s.prototype.utf8Write?s:null}catch{return null}}(),m._Buffer_from=null,m._Buffer_allocUnsafe=null,m.newBuffer=function(s){return typeof s=="number"?m.Buffer?m._Buffer_allocUnsafe(s):new m.Array(s):m.Buffer?m._Buffer_from(s):typeof Uint8Array>"u"?s:new Uint8Array(s)},m.Array=typeof Uint8Array<"u"?Uint8Array:Array,m.Long=m.global.dcodeIO&&m.global.dcodeIO.Long||m.global.Long||m.inquire("long"),m.key2Re=/^true|false|0|1$/,m.key32Re=/^-?(?:0|[1-9][0-9]*)$/,m.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,m.longToHash=function(s){return s?m.LongBits.from(s).toHash():m.LongBits.zeroHash},m.longFromHash=function(s,l){var p=m.LongBits.fromHash(s);return m.Long?m.Long.fromBits(p.lo,p.hi,l):p.toNumber(!!l)},m.merge=h,m.lcFirst=function(s){return s.charAt(0).toLowerCase()+s.substring(1)},m.newError=f,m.ProtocolError=f("ProtocolError"),m.oneOfGetter=function(s){for(var l={},p=0;p<s.length;++p)l[s[p]]=1;return function(){for(var a=Object.keys(this),i=a.length-1;i>-1;--i)if(l[a[i]]===1&&this[a[i]]!==void 0&&this[a[i]]!==null)return a[i]}},m.oneOfSetter=function(s){return function(l){for(var p=0;p<s.length;++p)s[p]!==l&&delete this[s[p]]}},m.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},m._configure=function(){var s=m.Buffer;s?(m._Buffer_from=s.from!==Uint8Array.from&&s.from||function(l,p){return new s(l,p)},m._Buffer_allocUnsafe=s.allocUnsafe||function(l){return new s(l)}):m._Buffer_from=m._Buffer_allocUnsafe=null}},1173:(R,u,y)=>{R.exports=e;var m,h=y(9693),f=h.LongBits,s=h.base64,l=h.utf8;function p(g,b,v){this.fn=g,this.len=b,this.next=void 0,this.val=v}function a(){}function i(g){this.head=g.head,this.tail=g.tail,this.len=g.len,this.next=g.states}function e(){this.len=0,this.head=new p(a,0,0),this.tail=this.head,this.states=null}var t=function(){return h.Buffer?function(){return(e.create=function(){return new m})()}:function(){return new e}};function n(g,b,v){b[v]=255&g}function r(g,b){this.len=g,this.next=void 0,this.val=b}function o(g,b,v){for(;g.hi;)b[v++]=127&g.lo|128,g.lo=(g.lo>>>7|g.hi<<25)>>>0,g.hi>>>=7;for(;g.lo>127;)b[v++]=127&g.lo|128,g.lo=g.lo>>>7;b[v++]=g.lo}function c(g,b,v){b[v]=255&g,b[v+1]=g>>>8&255,b[v+2]=g>>>16&255,b[v+3]=g>>>24}e.create=t(),e.alloc=function(g){return new h.Array(g)},h.Array!==Array&&(e.alloc=h.pool(e.alloc,h.Array.prototype.subarray)),e.prototype._push=function(g,b,v){return this.tail=this.tail.next=new p(g,b,v),this.len+=b,this},r.prototype=Object.create(p.prototype),r.prototype.fn=function(g,b,v){for(;g>127;)b[v++]=127&g|128,g>>>=7;b[v]=g},e.prototype.uint32=function(g){return this.len+=(this.tail=this.tail.next=new r((g>>>=0)<128?1:g<16384?2:g<2097152?3:g<268435456?4:5,g)).len,this},e.prototype.int32=function(g){return g<0?this._push(o,10,f.fromNumber(g)):this.uint32(g)},e.prototype.sint32=function(g){return this.uint32((g<<1^g>>31)>>>0)},e.prototype.uint64=function(g){var b=f.from(g);return this._push(o,b.length(),b)},e.prototype.int64=e.prototype.uint64,e.prototype.sint64=function(g){var b=f.from(g).zzEncode();return this._push(o,b.length(),b)},e.prototype.bool=function(g){return this._push(n,1,g?1:0)},e.prototype.fixed32=function(g){return this._push(c,4,g>>>0)},e.prototype.sfixed32=e.prototype.fixed32,e.prototype.fixed64=function(g){var b=f.from(g);return this._push(c,4,b.lo)._push(c,4,b.hi)},e.prototype.sfixed64=e.prototype.fixed64,e.prototype.float=function(g){return this._push(h.float.writeFloatLE,4,g)},e.prototype.double=function(g){return this._push(h.float.writeDoubleLE,8,g)};var d=h.Array.prototype.set?function(g,b,v){b.set(g,v)}:function(g,b,v){for(var w=0;w<g.length;++w)b[v+w]=g[w]};e.prototype.bytes=function(g){var b=g.length>>>0;if(!b)return this._push(n,1,0);if(h.isString(g)){var v=e.alloc(b=s.length(g));s.decode(g,v,0),g=v}return this.uint32(b)._push(d,b,g)},e.prototype.string=function(g){var b=l.length(g);return b?this.uint32(b)._push(l.write,b,g):this._push(n,1,0)},e.prototype.fork=function(){return this.states=new i(this),this.head=this.tail=new p(a,0,0),this.len=0,this},e.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new p(a,0,0),this.len=0),this},e.prototype.ldelim=function(){var g=this.head,b=this.tail,v=this.len;return this.reset().uint32(v),v&&(this.tail.next=g.next,this.tail=b,this.len+=v),this},e.prototype.finish=function(){for(var g=this.head.next,b=this.constructor.alloc(this.len),v=0;g;)g.fn(g.val,b,v),v+=g.len,g=g.next;return b},e._configure=function(g){m=g,e.create=t(),m._configure()}},3155:(R,u,y)=>{R.exports=f;var m=y(1173);(f.prototype=Object.create(m.prototype)).constructor=f;var h=y(9693);function f(){m.call(this)}function s(l,p,a){l.length<40?h.utf8.write(l,p,a):p.utf8Write?p.utf8Write(l,a):p.write(l,a)}f._configure=function(){f.alloc=h._Buffer_allocUnsafe,f.writeBytesBuffer=h.Buffer&&h.Buffer.prototype instanceof Uint8Array&&h.Buffer.prototype.set.name==="set"?function(l,p,a){p.set(l,a)}:function(l,p,a){if(l.copy)l.copy(p,a,0,l.length);else for(var i=0;i<l.length;)p[a++]=l[i++]}},f.prototype.bytes=function(l){h.isString(l)&&(l=h._Buffer_from(l,"base64"));var p=l.length>>>0;return this.uint32(p),p&&this._push(f.writeBytesBuffer,p,l),this},f.prototype.string=function(l){var p=h.Buffer.byteLength(l);return this.uint32(p),p&&this._push(s,p,l),this},f._configure()},4154:R=>{R.exports=`"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(R,u,y)=>{y.r(u),y.d(u,{flatbuffers:()=>m});var m={};m.Offset,m.Table,m.SIZEOF_SHORT=2,m.SIZEOF_INT=4,m.FILE_IDENTIFIER_LENGTH=4,m.SIZE_PREFIX_LENGTH=4,m.Encoding={UTF8_BYTES:1,UTF16_STRING:2},m.int32=new Int32Array(2),m.float32=new Float32Array(m.int32.buffer),m.float64=new Float64Array(m.int32.buffer),m.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,m.Long=function(h,f){this.low=0|h,this.high=0|f},m.Long.create=function(h,f){return h==0&&f==0?m.Long.ZERO:new m.Long(h,f)},m.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},m.Long.prototype.equals=function(h){return this.low==h.low&&this.high==h.high},m.Long.ZERO=new m.Long(0,0),m.Builder=function(h){if(h)f=h;else var f=1024;this.bb=m.ByteBuffer.allocate(f),this.space=f,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},m.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},m.Builder.prototype.forceDefaults=function(h){this.force_defaults=h},m.Builder.prototype.dataBuffer=function(){return this.bb},m.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},m.Builder.prototype.prep=function(h,f){h>this.minalign&&(this.minalign=h);for(var s=1+~(this.bb.capacity()-this.space+f)&h-1;this.space<s+h+f;){var l=this.bb.capacity();this.bb=m.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-l}this.pad(s)},m.Builder.prototype.pad=function(h){for(var f=0;f<h;f++)this.bb.writeInt8(--this.space,0)},m.Builder.prototype.writeInt8=function(h){this.bb.writeInt8(this.space-=1,h)},m.Builder.prototype.writeInt16=function(h){this.bb.writeInt16(this.space-=2,h)},m.Builder.prototype.writeInt32=function(h){this.bb.writeInt32(this.space-=4,h)},m.Builder.prototype.writeInt64=function(h){this.bb.writeInt64(this.space-=8,h)},m.Builder.prototype.writeFloat32=function(h){this.bb.writeFloat32(this.space-=4,h)},m.Builder.prototype.writeFloat64=function(h){this.bb.writeFloat64(this.space-=8,h)},m.Builder.prototype.addInt8=function(h){this.prep(1,0),this.writeInt8(h)},m.Builder.prototype.addInt16=function(h){this.prep(2,0),this.writeInt16(h)},m.Builder.prototype.addInt32=function(h){this.prep(4,0),this.writeInt32(h)},m.Builder.prototype.addInt64=function(h){this.prep(8,0),this.writeInt64(h)},m.Builder.prototype.addFloat32=function(h){this.prep(4,0),this.writeFloat32(h)},m.Builder.prototype.addFloat64=function(h){this.prep(8,0),this.writeFloat64(h)},m.Builder.prototype.addFieldInt8=function(h,f,s){(this.force_defaults||f!=s)&&(this.addInt8(f),this.slot(h))},m.Builder.prototype.addFieldInt16=function(h,f,s){(this.force_defaults||f!=s)&&(this.addInt16(f),this.slot(h))},m.Builder.prototype.addFieldInt32=function(h,f,s){(this.force_defaults||f!=s)&&(this.addInt32(f),this.slot(h))},m.Builder.prototype.addFieldInt64=function(h,f,s){!this.force_defaults&&f.equals(s)||(this.addInt64(f),this.slot(h))},m.Builder.prototype.addFieldFloat32=function(h,f,s){(this.force_defaults||f!=s)&&(this.addFloat32(f),this.slot(h))},m.Builder.prototype.addFieldFloat64=function(h,f,s){(this.force_defaults||f!=s)&&(this.addFloat64(f),this.slot(h))},m.Builder.prototype.addFieldOffset=function(h,f,s){(this.force_defaults||f!=s)&&(this.addOffset(f),this.slot(h))},m.Builder.prototype.addFieldStruct=function(h,f,s){f!=s&&(this.nested(f),this.slot(h))},m.Builder.prototype.nested=function(h){if(h!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},m.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},m.Builder.prototype.slot=function(h){this.vtable[h]=this.offset()},m.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},m.Builder.growByteBuffer=function(h){var f=h.capacity();if(3221225472&f)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var s=f<<1,l=m.ByteBuffer.allocate(s);return l.setPosition(s-f),l.bytes().set(h.bytes(),s-f),l},m.Builder.prototype.addOffset=function(h){this.prep(m.SIZEOF_INT,0),this.writeInt32(this.offset()-h+m.SIZEOF_INT)},m.Builder.prototype.startObject=function(h){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=h;for(var f=0;f<h;f++)this.vtable[f]=0;this.isNested=!0,this.object_start=this.offset()},m.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var h=this.offset(),f=this.vtable_in_use-1;f>=0&&this.vtable[f]==0;f--);for(var s=f+1;f>=0;f--)this.addInt16(this.vtable[f]!=0?h-this.vtable[f]:0);this.addInt16(h-this.object_start);var l=(s+2)*m.SIZEOF_SHORT;this.addInt16(l);var p=0,a=this.space;t:for(f=0;f<this.vtables.length;f++){var i=this.bb.capacity()-this.vtables[f];if(l==this.bb.readInt16(i)){for(var e=m.SIZEOF_SHORT;e<l;e+=m.SIZEOF_SHORT)if(this.bb.readInt16(a+e)!=this.bb.readInt16(i+e))continue t;p=this.vtables[f];break}}return p?(this.space=this.bb.capacity()-h,this.bb.writeInt32(this.space,p-h)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-h,this.offset()-h)),this.isNested=!1,h},m.Builder.prototype.finish=function(h,f,s){var l=s?m.SIZE_PREFIX_LENGTH:0;if(f){var p=f;if(this.prep(this.minalign,m.SIZEOF_INT+m.FILE_IDENTIFIER_LENGTH+l),p.length!=m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+m.FILE_IDENTIFIER_LENGTH);for(var a=m.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(p.charCodeAt(a))}this.prep(this.minalign,m.SIZEOF_INT+l),this.addOffset(h),l&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},m.Builder.prototype.finishSizePrefixed=function(h,f){this.finish(h,f,!0)},m.Builder.prototype.requiredField=function(h,f){var s=this.bb.capacity()-h,l=s-this.bb.readInt32(s);if(this.bb.readInt16(l+f)==0)throw new Error("FlatBuffers: field "+f+" must be set")},m.Builder.prototype.startVector=function(h,f,s){this.notNested(),this.vector_num_elems=f,this.prep(m.SIZEOF_INT,h*f),this.prep(s,h*f)},m.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},m.Builder.prototype.createString=function(h){if(h instanceof Uint8Array)var f=h;else{f=[];for(var s=0;s<h.length;){var l,p=h.charCodeAt(s++);(l=p<55296||p>=56320?p:(p<<10)+h.charCodeAt(s++)+-56613888)<128?f.push(l):(l<2048?f.push(l>>6&31|192):(l<65536?f.push(l>>12&15|224):f.push(l>>18&7|240,l>>12&63|128),f.push(l>>6&63|128)),f.push(63&l|128))}}this.addInt8(0),this.startVector(1,f.length,1),this.bb.setPosition(this.space-=f.length),s=0;for(var a=this.space,i=this.bb.bytes();s<f.length;s++)i[a++]=f[s];return this.endVector()},m.Builder.prototype.createLong=function(h,f){return m.Long.create(h,f)},m.ByteBuffer=function(h){this.bytes_=h,this.position_=0},m.ByteBuffer.allocate=function(h){return new m.ByteBuffer(new Uint8Array(h))},m.ByteBuffer.prototype.clear=function(){this.position_=0},m.ByteBuffer.prototype.bytes=function(){return this.bytes_},m.ByteBuffer.prototype.position=function(){return this.position_},m.ByteBuffer.prototype.setPosition=function(h){this.position_=h},m.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},m.ByteBuffer.prototype.readInt8=function(h){return this.readUint8(h)<<24>>24},m.ByteBuffer.prototype.readUint8=function(h){return this.bytes_[h]},m.ByteBuffer.prototype.readInt16=function(h){return this.readUint16(h)<<16>>16},m.ByteBuffer.prototype.readUint16=function(h){return this.bytes_[h]|this.bytes_[h+1]<<8},m.ByteBuffer.prototype.readInt32=function(h){return this.bytes_[h]|this.bytes_[h+1]<<8|this.bytes_[h+2]<<16|this.bytes_[h+3]<<24},m.ByteBuffer.prototype.readUint32=function(h){return this.readInt32(h)>>>0},m.ByteBuffer.prototype.readInt64=function(h){return new m.Long(this.readInt32(h),this.readInt32(h+4))},m.ByteBuffer.prototype.readUint64=function(h){return new m.Long(this.readUint32(h),this.readUint32(h+4))},m.ByteBuffer.prototype.readFloat32=function(h){return m.int32[0]=this.readInt32(h),m.float32[0]},m.ByteBuffer.prototype.readFloat64=function(h){return m.int32[m.isLittleEndian?0:1]=this.readInt32(h),m.int32[m.isLittleEndian?1:0]=this.readInt32(h+4),m.float64[0]},m.ByteBuffer.prototype.writeInt8=function(h,f){this.bytes_[h]=f},m.ByteBuffer.prototype.writeUint8=function(h,f){this.bytes_[h]=f},m.ByteBuffer.prototype.writeInt16=function(h,f){this.bytes_[h]=f,this.bytes_[h+1]=f>>8},m.ByteBuffer.prototype.writeUint16=function(h,f){this.bytes_[h]=f,this.bytes_[h+1]=f>>8},m.ByteBuffer.prototype.writeInt32=function(h,f){this.bytes_[h]=f,this.bytes_[h+1]=f>>8,this.bytes_[h+2]=f>>16,this.bytes_[h+3]=f>>24},m.ByteBuffer.prototype.writeUint32=function(h,f){this.bytes_[h]=f,this.bytes_[h+1]=f>>8,this.bytes_[h+2]=f>>16,this.bytes_[h+3]=f>>24},m.ByteBuffer.prototype.writeInt64=function(h,f){this.writeInt32(h,f.low),this.writeInt32(h+4,f.high)},m.ByteBuffer.prototype.writeUint64=function(h,f){this.writeUint32(h,f.low),this.writeUint32(h+4,f.high)},m.ByteBuffer.prototype.writeFloat32=function(h,f){m.float32[0]=f,this.writeInt32(h,m.int32[0])},m.ByteBuffer.prototype.writeFloat64=function(h,f){m.float64[0]=f,this.writeInt32(h,m.int32[m.isLittleEndian?0:1]),this.writeInt32(h+4,m.int32[m.isLittleEndian?1:0])},m.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+m.SIZEOF_INT+m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var h="",f=0;f<m.FILE_IDENTIFIER_LENGTH;f++)h+=String.fromCharCode(this.readInt8(this.position_+m.SIZEOF_INT+f));return h},m.ByteBuffer.prototype.__offset=function(h,f){var s=h-this.readInt32(h);return f<this.readInt16(s)?this.readInt16(s+f):0},m.ByteBuffer.prototype.__union=function(h,f){return h.bb_pos=f+this.readInt32(f),h.bb=this,h},m.ByteBuffer.prototype.__string=function(h,f){h+=this.readInt32(h);var s=this.readInt32(h),l="",p=0;if(h+=m.SIZEOF_INT,f===m.Encoding.UTF8_BYTES)return this.bytes_.subarray(h,h+s);for(;p<s;){var a,i=this.readUint8(h+p++);if(i<192)a=i;else{var e=this.readUint8(h+p++);if(i<224)a=(31&i)<<6|63&e;else{var t=this.readUint8(h+p++);a=i<240?(15&i)<<12|(63&e)<<6|63&t:(7&i)<<18|(63&e)<<12|(63&t)<<6|63&this.readUint8(h+p++)}}a<65536?l+=String.fromCharCode(a):(a-=65536,l+=String.fromCharCode(55296+(a>>10),56320+(1023&a)))}return l},m.ByteBuffer.prototype.__indirect=function(h){return h+this.readInt32(h)},m.ByteBuffer.prototype.__vector=function(h){return h+this.readInt32(h)+m.SIZEOF_INT},m.ByteBuffer.prototype.__vector_len=function(h){return this.readInt32(h+this.readInt32(h))},m.ByteBuffer.prototype.__has_identifier=function(h){if(h.length!=m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+m.FILE_IDENTIFIER_LENGTH);for(var f=0;f<m.FILE_IDENTIFIER_LENGTH;f++)if(h.charCodeAt(f)!=this.readInt8(this.position_+m.SIZEOF_INT+f))return!1;return!0},m.ByteBuffer.prototype.createLong=function(h,f){return m.Long.create(h,f)}}},__webpack_module_cache__={};function __webpack_require__(R){var u=__webpack_module_cache__[R];if(u!==void 0)return u.exports;var y=__webpack_module_cache__[R]={exports:{}};return __webpack_modules__[R].call(y.exports,y,y.exports,__webpack_require__),y.exports}__webpack_require__.n=R=>{var u=R&&R.__esModule?()=>R.default:()=>R;return __webpack_require__.d(u,{a:u}),u},__webpack_require__.d=(R,u)=>{for(var y in u)__webpack_require__.o(u,y)&&!__webpack_require__.o(R,y)&&Object.defineProperty(R,y,{enumerable:!0,get:u[y]})},__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),__webpack_require__.o=(R,u)=>Object.prototype.hasOwnProperty.call(R,u),__webpack_require__.r=R=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(R,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(R,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(1057);return __webpack_exports__})())})(ort_min);var ort_minExports=ort_min.exports;class ModelService{constructor(){Pt(this,"session");Pt(this,"gridSize");Pt(this,"batchSize");Pt(this,"channelSize");Pt(this,"outputChannelSize");Pt(this,"mass");Pt(this,"fpsLimit");Pt(this,"tensorShape");Pt(this,"tensorSize");Pt(this,"outputSize");Pt(this,"outputCallback");Pt(this,"matrixArray");Pt(this,"isPaused");Pt(this,"curFrameCountbyLastSecond");this.session=null,this.matrixArray=new Float32Array,this.gridSize=[0,0],this.batchSize=0,this.tensorShape=[0,0,0,0],this.tensorSize=0,this.outputSize=0,this.isPaused=!0,this.channelSize=0,this.outputChannelSize=0,this.mass=0,this.fpsLimit=30,this.curFrameCountbyLastSecond=0}static async createModelService(u,y=[64,64],m=1,h=5,f=3,s=15){console.log("createModelService called");const l=new ModelService;return await l.init(u,y,m,h,f),l.fpsLimit=s,console.log("createModelService finished"),l}async initMatrixFromPath(u){typeof u=="string"&&!u.startsWith("http")&&(u=new URL(u,self.location.href));const y=await fetch(u).then(async m=>await m.json());if(y==null)throw new Error("Cannot fetch matrix from path");this.initMatrixFromArray(y)}bindOutput(u){this.outputCallback=u}startSimulation(){this.isPaused=!1,this.curFrameCountbyLastSecond=0,this.fpsHeartbeat(),this.iterate()}fpsHeartbeat(){setTimeout(()=>{this.curFrameCountbyLastSecond=0,this.curFrameCountbyLastSecond>=this.fpsLimit?this.startSimulation():this.fpsHeartbeat()},1e3)}pauseSimulation(){this.isPaused=!0}async init(u,y,m,h,f){console.log("init called"),this.session=await ort_minExports.InferenceSession.create(u,{executionProviders:["wasm"],graphOptimizationLevel:"all"}),console.log("init session created"),this.channelSize=h,this.outputChannelSize=f,this.gridSize=y,this.batchSize=m,this.tensorShape=[m,y[0],y[1],h],this.tensorSize=m*y[0]*y[1]*h,this.outputSize=m*y[0]*y[1]*f}initMatrixFromArray(u){if(console.log(" ~ file: modelService.ts:132 ~ ModelService ~  initMatrixFromJSON ~ data:",u),this.matrixArray=new Float32Array(u.flat(3)),this.normalizeMatrix(this.matrixArray),this.matrixArray.length!==this.tensorSize)throw new Error(`matrixArray length ${this.matrixArray.length} does not match tensorSize ${this.tensorSize}`);this.matrixArray=this.matrixMap(this.matrixArray,[0,1],y=>Math.max(y,0)),this.mass=this.matrixSum(this.matrixArray,[0,1])}iterate(){if(this.session==null)throw new Error("session is null, createModelServices() must be called at first");console.log("iterate called"),console.log("this.matrixArray",this.matrixArray);const u=this.matrixSum(this.matrixArray,[1,5],h=>h**2),y=new ort_minExports.Tensor("float32",this.matrixArray,this.tensorShape),m={};m[this.session.inputNames[0]]=y,this.session.run(m).then(h=>{if(h.Output.data instanceof Float32Array){const f=this.constrainOutput(h.Output.data,u);this.outputCallback(f),this.curFrameCountbyLastSecond++,console.log("curFrameCountbyLastSecond",this.curFrameCountbyLastSecond),this.copyOutputToMatrix(f),setTimeout(()=>{this.isPaused||(this.curFrameCountbyLastSecond>this.fpsLimit?(this.isPaused=!0,console.log("fps limit reached, pause simulation, fpsLimit:",this.fpsLimit,"curFrameCountbyLastSecond:",this.curFrameCountbyLastSecond)):this.iterate())})}}).catch(h=>{console.error("error in session.run",h),this.isPaused=!0})}normalizeMatrix(u){console.log("normalizeMatrix called");for(let y=0;y<this.channelSize;y++)u=this.normalizeMatrixChannel(u,y)}normalizeMatrixChannel(u,y){const m=this.matrixSum(u,[y,y+1],s=>s),h=this.roundFloat(m/(this.gridSize[0]*this.gridSize[1]*this.batchSize),4),f=this.roundFloat(Math.sqrt(this.matrixSum(u,[y,y+1],s=>Math.pow(s-h,2))/(this.gridSize[0]*this.gridSize[1]*this.batchSize)),4);return console.log("normalizeMatrixChannel",y,h,f),this.matrixMap(u,[y,y+1],s=>(s-h)/f)}constrainOutput(u,y){let m=this.constrainDensity(u);return m=this.constrainVelocity(m,y),m}constrainDensity(u){u=this.matrixMap(u,[0,1],h=>Math.max(h,0),!0);const y=this.matrixSum(u,[0,1],h=>h,!0),m=this.mass/y;return console.log("Scaling density, cur mass:",y,"target mass:",this.mass,"scale:",m),this.matrixMap(u,[0,1],h=>h*m,!0)}constrainVelocity(u,y){const m=this.matrixSum(u,[1,3],f=>f**2,!0),h=this.roundFloat(Math.sqrt(y/m),4);return console.log("Scaling velocity, cur energy:",m,"target energy:",y,"scale:",h),h>=1?u:this.matrixMap(u,[1,3],f=>f*h,!0)}copyOutputToMatrix(u){if(this.matrixArray.length===0)throw new Error("matrixArray is empty");let y=0,m=0,h=0;for(;y<u.length;){if(h>=3&&(h=0,m+=2,m>=this.matrixArray.length))throw new Error(`toIndex ${m} exceeds matrixArray length ${this.matrixArray.length}`);this.matrixArray[m]=u[y],y++,m++,h++}if(y!==u.length)throw new Error(`fromIndex ${y} does not match outputs length ${u.length}`);if(m+2!==this.matrixArray.length)throw new Error(`toIndex ${m} does not match matrixArray length ${this.matrixArray.length}`)}updateForce(u,y){const m=this.getIndex(u);this.matrixArray[m+3]+=y.x,this.matrixArray[m+4]+=y.y}getIndex(u,y=0){return y*this.gridSize[0]*this.gridSize[1]*this.channelSize+u.y*this.gridSize[1]*this.channelSize+u.x*this.channelSize}matrixSum(u,y,m=f=>f,h=!1){const f=h?this.outputSize:this.tensorSize,s=h?this.outputChannelSize:this.channelSize;let l=0,p=0;for(;p<f;){for(let a=y[0];a<y[1];a++)l+=m(u[p+a]);p+=s}return l}matrixMap(u,y,m,h=!1){const f=h?this.outputSize:this.tensorSize,s=h?this.outputChannelSize:this.channelSize;let l=0;for(;l<f;){for(let p=y[0];p<y[1];p++)u[l+p]=m(u[l+p]);l+=s}return u}roundFloat(u,y=4){return Math.round(u*10**y)/10**y}getFullMatrix(){return this.matrixArray}getDensity(){return this.matrixMap(this.matrixArray,[0,1],u=>u)}getVelocity(){return this.matrixMap(this.matrixArray,[1,3],u=>u)}getForce(){return this.matrixMap(this.matrixArray,[3,5],u=>u)}}let modelService=null;function onmessage(R){const u=R.data;if(u==null)throw new Error("data is null");if(u.func==null)throw new Error("data.type is null");switch(console.log("worker received message",u),u.func){case"init":modelService==null&&initModelService(this).then(y=>{modelService=y,this.postMessage({type:"init",success:!0})}).catch(y=>{console.error("error in initModelService",y)});break;case"start":if(modelService==null)throw new Error("modelService is null");modelService.startSimulation();break;case"pause":if(modelService==null)throw new Error("modelService is null");modelService.pauseSimulation();break;case"updateForce":updateForce(u.args);break;case"getFullMatrix":if(modelService==null)throw new Error("modelService is null");this.postMessage({type:"fullMatrix",matrix:modelService.getFullMatrix()});break;case"getDensity":if(modelService==null)throw new Error("modelService is null");this.postMessage({type:"density",density:modelService.getDensity()});break;default:throw new Error(`unknown func ${u.func}`)}}function updateForce(R){if(modelService==null)throw new Error("modelService is null");modelService.updateForce(R.loc,R.forceDelta)}self.onmessage=onmessage;async function initModelService(R){const u="/model/bno_small.onnx",y=new URL("/initData/pvf_incomp_44_0.json",self.location),m=f=>{const s=new Float32Array(f.length/3);for(let l=0;l<s.length;l++)s[l]=f[l*3];R.postMessage({type:"output",density:s})},h=await ModelService.createModelService(u,[64,64],1);return h.bindOutput(m),await h.initMatrixFromPath(y),h}})();
