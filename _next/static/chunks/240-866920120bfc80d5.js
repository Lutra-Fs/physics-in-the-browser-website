(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[240],{3454:function(t,e,r){"use strict";var i,o;t.exports=(null==(i=r.g.process)?void 0:i.env)&&"object"==typeof(null==(o=r.g.process)?void 0:o.env)?r.g.process:r(7663)},7663:function(t){!function(){var e={229:function(t){var e,r,i,o=t.exports={};function n(){throw Error("setTimeout has not been defined")}function a(){throw Error("clearTimeout has not been defined")}function s(t){if(e===setTimeout)return setTimeout(t,0);if((e===n||!e)&&setTimeout)return e=setTimeout,setTimeout(t,0);try{return e(t,0)}catch(r){try{return e.call(null,t,0)}catch(r){return e.call(this,t,0)}}}!function(){try{e="function"==typeof setTimeout?setTimeout:n}catch(t){e=n}try{r="function"==typeof clearTimeout?clearTimeout:a}catch(t){r=a}}();var f=[],h=!1,d=-1;function l(){h&&i&&(h=!1,i.length?f=i.concat(f):d=-1,f.length&&u())}function u(){if(!h){var t=s(l);h=!0;for(var e=f.length;e;){for(i=f,f=[];++d<e;)i&&i[d].run();d=-1,e=f.length}i=null,h=!1,function(t){if(r===clearTimeout)return clearTimeout(t);if((r===a||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(t);try{r(t)}catch(e){try{return r.call(null,t)}catch(e){return r.call(this,t)}}}(t)}}function m(t,e){this.fun=t,this.array=e}function g(){}o.nextTick=function(t){var e=Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];f.push(new m(t,e)),1!==f.length||h||s(u)},m.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=g,o.addListener=g,o.once=g,o.off=g,o.removeListener=g,o.removeAllListeners=g,o.emit=g,o.prependListener=g,o.prependOnceListener=g,o.listeners=function(t){return[]},o.binding=function(t){throw Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(t){throw Error("process.chdir is not supported")},o.umask=function(){return 0}}},r={};function i(t){var o=r[t];if(void 0!==o)return o.exports;var n=r[t]={exports:{}},a=!0;try{e[t](n,n.exports,i),a=!1}finally{a&&delete r[t]}return n.exports}i.ab="//";var o=i(229);t.exports=o}()},226:function(t,e,r){"use strict";r.r(e),r.d(e,{InferenceSession:function(){return p},Tensor:function(){return g},env:function(){return s},registerBackend:function(){return n}});let i={},o=[],n=(t,e,r)=>{if(e&&"function"==typeof e.init&&"function"==typeof e.createSessionHandler){let n=i[t];if(void 0===n)i[t]={backend:e,priority:r};else if(n.priority>r)return;else if(n.priority===r&&n.backend!==e)throw Error(`cannot register backend "${t}" using priority ${r}`);if(r>=0){let e=o.indexOf(t);-1!==e&&o.splice(e,1);for(let e=0;e<o.length;e++)if(i[o[e]].priority<=r){o.splice(e,0,t);return}o.push(t)}return}throw TypeError("not a valid backend")},a=async t=>{let e=0===t.length?o:t,r=[];for(let t of e){let e=i[t];if(e){if(e.initialized)return e.backend;if(e.aborted)continue;let i=!!e.initPromise;try{return i||(e.initPromise=e.backend.init()),await e.initPromise,e.initialized=!0,e.backend}catch(o){i||r.push({name:t,err:o}),e.aborted=!0}finally{delete e.initPromise}}}throw Error(`no available backend found. ERR: ${r.map(t=>`[${t.name}] ${t.err}`).join(", ")}`)},s=new class{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(t){if(void 0!==t){if("string"!=typeof t||-1===["verbose","info","warning","error","fatal"].indexOf(t))throw Error(`Unsupported logging level: ${t}`);this.logLevelInternal=t}}get logLevel(){return this.logLevelInternal}},f="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,h="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from,d=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),l=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);f&&(d.set("int64",BigInt64Array),l.set(BigInt64Array,"int64")),h&&(d.set("uint64",BigUint64Array),l.set(BigUint64Array,"uint64"));let u=t=>{let e=1;for(let r=0;r<t.length;r++){let i=t[r];if("number"!=typeof i||!Number.isSafeInteger(i))throw TypeError(`dims[${r}] must be an integer, got: ${i}`);if(i<0)throw RangeError(`dims[${r}] must be a non-negative integer, got: ${i}`);e*=i}return e};class m{constructor(t,e,r){let i,o,n;if("string"==typeof t){if(i=t,n=r,"string"===t){if(!Array.isArray(e))throw TypeError("A string tensor's data must be a string array.");o=e}else{let r=d.get(t);if(void 0===r)throw TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(e))o=r.from(e);else if(e instanceof r)o=e;else throw TypeError(`A ${i} tensor's data must be type of ${r}`)}}else if(n=e,Array.isArray(t)){if(0===t.length)throw TypeError("Tensor type cannot be inferred from an empty array.");let e=typeof t[0];if("string"===e)i="string",o=t;else if("boolean"===e)i="bool",o=Uint8Array.from(t);else throw TypeError(`Invalid element type of data array: ${e}.`)}else{let e=l.get(t.constructor);if(void 0===e)throw TypeError(`Unsupported type for tensor data: ${t.constructor}.`);i=e,o=t}if(void 0===n)n=[o.length];else if(!Array.isArray(n))throw TypeError("A tensor's dims must be a number array");let a=u(n);if(a!==o.length)throw Error(`Tensor's size(${a}) does not match data length(${o.length}).`);this.dims=n,this.type=i,this.data=o,this.size=a}static bufferToTensor(t,e){let r,i;if(void 0===t)throw Error("Image buffer must be defined");if(void 0===e.height||void 0===e.width)throw Error("Image height and width must be defined");let{height:o,width:n}=e,a=e.norm;r=void 0===a||void 0===a.mean?255:a.mean,i=void 0===a||void 0===a.bias?0:a.bias;let s=void 0!==e.bitmapFormat?e.bitmapFormat:"RGBA",f=void 0!==e.tensorFormat&&void 0!==e.tensorFormat?e.tensorFormat:"RGB",h=o*n,d=new Float32Array("RGBA"===f?4*h:3*h),l=4,u=0,g=1,c=2,p=3,y=0,w=h,b=2*h,v=-1;"RGB"===s&&(l=3,u=0,g=1,c=2,p=-1),"RGBA"===f?v=3*h:"RBG"===f?(y=0,b=h,w=2*h):"BGR"===f&&(b=0,w=h,y=2*h);for(let e=0;e<h;e++,u+=l,c+=l,g+=l,p+=l)d[y++]=(t[u]+i)/r,d[w++]=(t[g]+i)/r,d[b++]=(t[c]+i)/r,-1!==v&&-1!==p&&(d[v++]=(t[p]+i)/r);let E="RGBA"===f?new m("float32",d,[1,4,o,n]):new m("float32",d,[1,3,o,n]);return E}static async fromImage(t,e){let r;let i="undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement,o="undefined"!=typeof ImageData&&t instanceof ImageData,n="undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap,a={};if(i){let i=document.createElement("canvas"),o=i.getContext("2d");if(null!=o){let n=t.naturalHeight,s=t.naturalWidth;if(void 0!==e&&void 0!==e.resizedHeight&&void 0!==e.resizedWidth&&(n=e.resizedHeight,s=e.resizedWidth),void 0!==e){if(a=e,void 0!==e.tensorFormat)throw Error("Image input config format must be RGBA for HTMLImageElement");if(a.tensorFormat="RGBA",void 0!==e.height&&e.height!==n)throw Error("Image input config height doesn't match HTMLImageElement height");if(a.height=n,void 0!==e.width&&e.width!==s)throw Error("Image input config width doesn't match HTMLImageElement width");a.width=s}else a.tensorFormat="RGBA",a.height=n,a.width=s;i.width=s,i.height=n,o.drawImage(t,0,0,s,n),r=o.getImageData(0,0,s,n).data}else throw Error("Can not access image data")}else if(o){let i,o;if(void 0!==e&&void 0!==e.resizedWidth&&void 0!==e.resizedHeight?(i=e.resizedHeight,o=e.resizedWidth):(i=t.height,o=t.width),void 0!==e){if(a=e,void 0!==e.bitmapFormat&&"RGBA"!==e.bitmapFormat)throw Error("Image input config format must be RGBA for ImageData");a.bitmapFormat="RGBA"}else a.bitmapFormat="RGBA";if(a.height=i,a.width=o,void 0!==e){let e=document.createElement("canvas");e.width=o,e.height=i;let n=e.getContext("2d");if(null!=n)n.putImageData(t,0,0),r=n.getImageData(0,0,o,i).data;else throw Error("Can not access image data")}else r=t.data}else if(n){if(void 0===e)throw Error("Please provide image config with format for Imagebitmap");if(void 0!==e.bitmapFormat)throw Error("Image input config format must be defined for ImageBitmap");let i=document.createElement("canvas").getContext("2d");if(null!=i){let o=t.height,n=t.width;if(i.drawImage(t,0,0,n,o),r=i.getImageData(0,0,n,o).data,void 0!==e){if(void 0!==e.height&&e.height!==o)throw Error("Image input config height doesn't match ImageBitmap height");if(a.height=o,void 0!==e.width&&e.width!==n)throw Error("Image input config width doesn't match ImageBitmap width");a.width=n}else a.height=o,a.width=n;return m.bufferToTensor(r,a)}throw Error("Can not access image data")}else if("undefined"!=typeof String&&(t instanceof String||"string"==typeof t))return new Promise((r,i)=>{let o=document.createElement("canvas"),n=o.getContext("2d");if(!t||!n)return i();let s=new Image;s.crossOrigin="Anonymous",s.src=t,s.onload=()=>{o.width=s.width,o.height=s.height,n.drawImage(s,0,0,o.width,o.height);let t=n.getImageData(0,0,o.width,o.height);if(void 0!==e){if(void 0!==e.height&&e.height!==o.height)throw Error("Image input config height doesn't match ImageBitmap height");if(a.height=o.height,void 0!==e.width&&e.width!==o.width)throw Error("Image input config width doesn't match ImageBitmap width");a.width=o.width}else a.height=o.height,a.width=o.width;r(m.bufferToTensor(t.data,a))}});else throw Error("Input data provided is not supported - aborted tensor creation");if(void 0!==r)return m.bufferToTensor(r,a);throw Error("Input data provided is not supported - aborted tensor creation")}toImageData(t){var e,r;let i;let o=document.createElement("canvas").getContext("2d");if(null!=o){let n=this.dims[3],a=this.dims[2],s=this.dims[1],f=void 0!==t&&void 0!==t.format?t.format:"RGB",h=void 0!==t&&(null===(e=t.norm)||void 0===e?void 0:e.mean)!==void 0?t.norm.mean:255,d=void 0!==t&&(null===(r=t.norm)||void 0===r?void 0:r.bias)!==void 0?t.norm.bias:0,l=a*n;if(void 0!==t){if(void 0!==t.height&&t.height!==a)throw Error("Image output config height doesn't match tensor height");if(void 0!==t.width&&t.width!==n)throw Error("Image output config width doesn't match tensor width");if(void 0!==t.format&&4===s&&"RGBA"!==t.format||3===s&&"RGB"!==t.format&&"BGR"!==t.format)throw Error("Tensor format doesn't match input tensor dims")}let u=0,m=1,g=2,c=3,p=0,y=l,w=2*l,b=-1;"RGBA"===f?(p=0,y=l,w=2*l,b=3*l):"RGB"===f?(p=0,y=l,w=2*l):"RBG"===f&&(p=0,w=l,y=2*l),i=o.createImageData(n,a);for(let t=0;t<a*n;u+=4,m+=4,g+=4,c+=4,t++)i.data[u]=(this.data[p++]-d)*h,i.data[m]=(this.data[y++]-d)*h,i.data[g]=(this.data[w++]-d)*h,i.data[c]=-1===b?255:(this.data[b++]-d)*h}else throw Error("Can not access image data");return i}reshape(t){return new m(this.type,this.data,t)}}let g=m;class c{constructor(t){this.handler=t}async run(t,e,r){let i={},o={};if("object"!=typeof t||null===t||t instanceof g||Array.isArray(t))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let n=!0;if("object"==typeof e){if(null===e)throw TypeError("Unexpected argument[1]: cannot be null.");if(e instanceof g)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(e)){if(0===e.length)throw TypeError("'fetches' cannot be an empty array.");for(let t of(n=!1,e)){if("string"!=typeof t)throw TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(t))throw RangeError(`'fetches' contains invalid output name: ${t}.`);i[t]=null}if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else{let t=!1,a=Object.getOwnPropertyNames(e);for(let r of this.outputNames)if(-1!==a.indexOf(r)){let o=e[r];(null===o||o instanceof g)&&(t=!0,n=!1,i[r]=o)}if(t){if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else o=e}}else if(void 0!==e)throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let e of this.inputNames)if(void 0===t[e])throw Error(`input '${e}' is missing in 'feeds'.`);if(n)for(let t of this.outputNames)i[t]=null;let a=await this.handler.run(t,i,o),s={};for(let t in a)Object.hasOwnProperty.call(a,t)&&(s[t]=new g(a[t].type,a[t].data,a[t].dims));return s}static async create(t,e,r,i){let o;let n={};if("string"==typeof t){if(o=t,"object"==typeof e&&null!==e)n=e;else if(void 0!==e)throw TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(o=t,"object"==typeof e&&null!==e)n=e;else if(void 0!==e)throw TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&t instanceof SharedArrayBuffer){let a=0,s=t.byteLength;if("object"==typeof e&&null!==e)n=e;else if("number"==typeof e){if(!Number.isSafeInteger(a=e))throw RangeError("'byteOffset' must be an integer.");if(a<0||a>=t.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${t.byteLength}).`);if(s=t.byteLength-a,"number"==typeof r){if(!Number.isSafeInteger(s=r))throw RangeError("'byteLength' must be an integer.");if(s<=0||a+s>t.byteLength)throw RangeError(`'byteLength' is out of range (0, ${t.byteLength-a}].`);if("object"==typeof i&&null!==i)n=i;else if(void 0!==i)throw TypeError("'options' must be an object.")}else if(void 0!==r)throw TypeError("'byteLength' must be a number.")}else if(void 0!==e)throw TypeError("'options' must be an object.");o=new Uint8Array(t,a,s)}else throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let s=n.executionProviders||[],f=s.map(t=>"string"==typeof t?t:t.name),h=await a(f),d=await h.createSessionHandler(o,n);return new c(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}let p=c}}]);